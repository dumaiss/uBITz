
# ŒºBITz Platform Specification v1.0

## Multi-Platform Retro-Modern Computing Architecture

---

# Part 0 ‚Äî Platform Overview and Architecture

**Status:** Normative
**Version:** 1.0
**Date:** 2025

---

## 0.1 What is ŒºBITz Platform?

The ŒºBITz Platform is a modular, multi-platform computing architecture designed for retro-modern systems. It provides a standardized framework for building complete computer systems by composing four fundamental subsystems:

- **ŒºBITz Host** ‚Äî CPU boards implementing complete platform logic
- **ŒºBITz Bank** ‚Äî Memory subsystem providing word-addressed RAM/ROM
- **ŒºBITz Dock** ‚Äî I/O expansion interconnect for peripherals
- **ŒºBITz Tile** ‚Äî Peripheral devices that attach to the Dock bus

Together, these subsystems enable hobbyists and enthusiasts to build authentic retro computing platforms (C64, Apple II, ZX Spectrum, etc.) while leveraging modern components, modularity, and cross-platform device compatibility.

**Key Characteristics:**
- **Platform-centric design**: Each CPU board defines a complete platform personality
- **Logical separation**: CPU, Memory, and I/O are independent, replaceable subsystems
- **Width flexibility**: Supports 8-bit through 32-bit address and data paths
- **Cross-platform devices**: Peripherals work across different CPU platforms
- **Hobbyist-first**: Accessible components, readable timing, thorough documentation

---

## 0.2 Design Philosophy, Scope and Non-Goals

### 0.2.1 Design principle: Appropriate Complexity

ŒºBITz is designed for **retro-friendly, hobbyist-scale, non-safety-critical** systems.

ŒºBITz targets environments where:

- Backplane trace lengths are **short** (typically < 6 inches).
- Data rates are **modest** (low hundreds of Mbps per lane).
- Applications are **not safety-critical**.
- Basic debugging tools are available (oscilloscope, logic analyser).

From these constraints follow the core trade-offs:

- ‚úì **Simplicity** over redundancy  
- ‚úì **Performance** over absolute integrity  
- ‚úì **Ease of implementation** over comprehensive protection  
- ‚úì **Clear failure modes** over silent error correction  

If your application requires any of the following, ŒºBITz is **not** the right standard:

- Safety certification (medical, automotive, aerospace).
- Strong cryptographic integrity / tamper detection on the bus.
- Long-distance communication (> 1 m links).
- Harsh environments (industrial, military).

In those cases, use PCIe, CAN, or other certified protocols designed for such requirements.

Author‚Äôs note, preserved for emphasis:

> ‚ÄúI‚Äôm going to personally hunt you down and smack you on the head if you use this standard for critical applications.‚Äù You have been warned. üòÑ

The **ŒºBITz Dock** explicitly inherits this Platform design philosophy; individual subsystem specs may add extra constraints but not weaken these.

---

### 0.2.2 Why ŒºBITz exists

ŒºBITz was created to:

- **Bridge retro and modern**  
  Keep 8/16-bit CPU friendliness while scaling up to **32-bit address and 32-bit data paths**.
- **Be hobbyist-first**  
  Readable timing, `/READY` wait-state stretching, open-drain interrupts, and widely available connectors.
- **Improve portability**  
  The same driver and logical I/O model work across **Parallel**, and **Minimal** profiles.
- **Encourage learning & reuse**  
  Clean separation between logic and physical layers; a single platform spec split into parts, so designs and code can be re-used across boards and builds.

---

### 0.2.3 Who this targets (and who it doesn‚Äôt)

**Intended targets**

- Hobbyists and educators building retro-style computers.
- Board/device designers who want a **portable register interface** across different physical buses.
- Firmware developers who want to **write drivers once** and reuse them on Parallel, and Minimal builds.
- Portable/minimal systems using an MCU to emulate many peripherals behind a simple CPU bus.

**Explicit non-targets**

- Safety-critical or life-support systems.
- PCI/PCIe compatibility (ŒºBITz is **not** PCI/PCIe and does not aim to be).
- Cache-coherent shared memory fabrics, DMA buses, or hot-plug at arbitrary points (unless explicitly stated in a future profile).
- Long-haul or harsh-environment links (industrial/military).

---

### 0.2.4 Core design principles

1. **One logical model, many physiques**  
   All profiles (Parallel, Minimal) implement the **same logical I/O model**:  
   functions/windows + registers. A driver written for the logical model works across profiles.

2. **Simple, deterministic semantics**  
   - Synchronous reads and writes.  
   - `/READY` can stretch cycles, but there are **no hidden retries** or opaque error-recovery layers.

3. **Scaled but bounded widths**  
   - The Host CPU declares:  
     - `AddressBusWidth ‚àà {8, 16, 32}`  
     - `DataBusWidth ‚àà {8, 16, 32}`  
     
   - **Parallel profile:** connector physically exposes **A[31:0], D[31:0]**; backplane/devices adapt to the subset actually used.

4. **Interrupts that fit retro mental models**  
   - Shared interrupt channels: `/INT_CH[1:0]` and `/NMI_CH.  
   - Optional **Mode-2-style acknowledge** using `/INT_ACK:  
     the device returns an 8-bit vector index and the CPU supplies the vector base (e.g., via an I-register).

5. **Encoding that favors debuggability**  
   - The goal is ‚Äúeasy to probe and reason about‚Äù on hobbyist tools.

6. **Stable, commodity connectors**  
   - Parallel: PCIe x16 edge connector:  
	   - Do **not** reassign standard power/ground pins.  
	   - Use **3.3 V** and optional **5 V** only; **no 12 V** usage in ŒºBITz designs.
	   
6. **Multiple profile per backplane**  
   - A given Dock/backplane usually runs **one profile**: Parallel *or* Minimal.  
   - This reduces ambiguity and BOM complexity.  
   - Cross-profile bridges are built as **carrier cards**, not by mixing profiles on the same backplane.

8. **Descriptors & enumeration**  
   - I¬≤C EEPROMs describe CPU, Banks, Dock, and Tiles (class, capabilities, widths, timing, etc.).  
   - Firmware discovers and configures the system from descriptors instead of hard-coding maps.

9. **Availability & serviceability**  
   - Through-hole-friendly options (especially in Parallel builds).  
   - Simple probing with scope/logic analyser.  
   - Predictable power domains and clear connector conventions to ease repair and hacking.

---

### 0.2.5 Non-goals (v1.0)

v1.0 of ŒºBITz explicitly does **not** aim to support:

- Bus mastering, DMA, or cache coherency on the shared bus.
- Dynamic re-assignment of power/ground on standardized connectors.
- Mixed-profile backplanes (Parallel + Minimal in the same chassis at once).
	- Mixed-profile backplanes are allowed and possible, but no reference implementation provided.
- Safety-critical deployments, cryptographic integrity guarantees, or harsh-environment operation.

These may be revisited in future versions or in separate, higher-complexity standards, but they are **out of scope** for ŒºBITz v1.0.


---

## 0.3 Platform Architecture

### 0.3.1 Subsystem Roles

The ŒºBITz Platform consists of four mandatory subsystems, each with distinct responsibilities:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      ŒºBITz PLATFORM                                         ‚îÇ
‚îÇ                                                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  ŒºBITz Host  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  ŒºBITz Bank  ‚îÇ  ‚îÇ  ŒºBITz Tiles ‚îÇ    ‚îÇ  ŒºBITz   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  (CPU Board) ‚îÇ      ‚îÇ (Memory Sub) ‚îÇ  ‚îÇ   (Devices)  ‚îÇ    ‚îÇ   Dock   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ              ‚îÇ      ‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ    ‚îÇ (I/O Bus)‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Platform  ‚îÇ      ‚îÇ  - Word RAM  ‚îÇ  ‚îÇ  - Video     ‚îÇ    ‚îÇ          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Timing    ‚îÇ      ‚îÇ  - ROM/Flash ‚îÇ  ‚îÇ  - Sound     ‚îÇ    ‚îÇ          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Control   ‚îÇ      ‚îÇ  - Mapping   ‚îÇ  ‚îÇ  - HID       ‚îÇ    ‚îÇ          ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ          ‚îÇ   ‚îÇ
‚îÇ         ‚îÇ                     ‚îÇ                 ‚îÇ            ‚îÇ          ‚îÇ   ‚îÇ
‚îÇ         ‚îÇ                     ‚îÇ                 ‚îÇ            ‚îÇ          ‚îÇ   ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§          ‚îÇ   ‚îÇ
‚îÇ                               ‚îÇ                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                               ‚îÇ                                             ‚îÇ
‚îÇ                    Common Backplane Infrastructure                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 0.3.2 Subsystem Descriptions

### ŒºBITz Host (CPU Board)

**Specification Document:** *ŒºBITz Host Specification v1.0*

**Role:** Implements the complete platform personality, CPU, and system control logic.

**Responsibilities:**
- Execute the target platform‚Äôs CPU instruction set (Z80, 6502, 68000, etc.)
- Generate all bus timing and control signals
- Implement platform-specific chipset logic (interrupt controllers, timers, DMA, etc.)
- Provide CPU Descriptor via I¬≤C EEPROM declaring:
- Platform identity (e.g., ‚ÄúC64‚Äù, ‚ÄúAPPLE2‚Äù, ‚ÄúZX48K‚Äù)
- CPU type and capabilities
- Address bus width (8/16/32 bits)
- Data bus width (8/16/32 bits)
- Interrupt acknowledge mode
- I/O window mapping policy
- Interrupt routing policy
- Implement CPU-side memory interface (address generation, timing)
- Handle CPU-side I/O operations (IN/OUT or memory-mapped I/O)

**Key Outputs:**
- Address bus: `A[AddressBusWidth-1:0]`
- Data bus: `D[DataBusWidth-1:0]` (bidirectional)
- Memory control: `/MREQ`, `R/W_`, `/READY`, `/MEM0_CS`, `/MEM1_CS` handling
- I/O control: `/IORQ`, `R/W_`, `/READY` handling
- Interrupt inputs: `CPU_INT[3:0]`, `CPU_NMI[1:0]`
- Interrupt acknowledge: `/CPU_ACK`
- System control: `/RESET`, `/BUSRQ`, `/BUSACK` (platform-specific)

**Dependencies:**
- Requires ŒºBITz Bank for memory operations
- Requires ŒºBITz Dock for I/O operations
- Must negotiate compatibility during enumeration

---

### ŒºBITz Bank (Memory Subsystem)

**Specification Document:** *ŒºBITz Bank Specification v1.0*

**Role:** Provides word-addressed memory (RAM and ROM/Flash) with configurable mapping.

**Responsibilities:**
- Implement physical memory storage (SRAM, DRAM, Flash, ROM)
- Support declared address and data widths from CPU board
- Provide Bank Descriptor via I¬≤C EEPROM declaring:
- Total memory capacity and type (RAM/ROM/Flash)
- Memory organization (byte/word/longword access)
- Address width support (8/16/32 bits)
- Data width support (8/16/32 bits)
- Decode memory address ranges and chip selects
- Handle memory timing (setup, hold, wait states)
- Support atomic multi-byte operations per declared data width
- Provide memory initialization and testing capabilities
- Behaves as a static memory. If dynamic RAM is used in implementation, the Bank implementation is responsible for its own refresh

**Key Inputs:**
- Memory address: `A[AddressBusWidth-1:0]`
- Memory data: `D[DataBusWidth-1:0]` (write operations)
- Memory control: `/MREQ`, `R/W_` (1=read, 0=write), `/MEM0_CS`, `/MEM1_CS`

**Key Outputs:**
- Memory data: `D[DataBusWidth-1:0]` (read operations)
- `/READY` or ready signaling for slow memory
- Bank status signals (platform-specific)

**Dependencies:**
- Receives addressing and control from ŒºBITz Host
- Must support CPU board‚Äôs declared widths
- Operates independently of ŒºBITz Dock

**Design Constraints:**
- Memory operations complete synchronously with CPU assert wait states
- Read data must be valid before CPU samples (setup time)
- Write data must be held stable during write pulse (hold time)
- Banking is the responsibility of the ŒºBITz Core
- ROM regions must be write-protected in hardware

---

### ŒºBITz Dock (I/O Expansion Bus)

**Specification Document:** *ŒºBITz Dock Specification v1.0*

**Role:** Standardized I/O interconnect supporting multiple physical profiles.

**Responsibilities:**
- Provide backplane infrastructure (power, signals, slots)
- Support 1-4 peripheral device slots plus a possible internal Dock Services virtual slot
- Implement function-based address routing (not geographic)
- Provide Device Descriptors via I¬≤C EEPROM for each peripheral
- Route I/O transactions based on CPU window mapping
- Handle interrupt routing from devices to CPU pins
- Support multiple physical profiles:
- **Parallel Profile**: PCIe x16 connector (signal reuse only)
- **Minimal Profile**: MCU-based bridge with internal serialization
- Implement enumeration and conflict detection
- Provide `/READY` stretching for device wait states
- Manage per-slot chip selects (`/CS[Slot-1:0]`)
- Route per-slot interrupt channels to CPU interrupt pins

**Key Inputs (from CPU):**
- I/O address: `A[AddressBusWidth-1:0]`
- I/O data: `D[DataBusWidth-1:0]` (write operations)
- I/O request: `/IORQ`
- Operation: `R/W_` (1=read, 0=write)
- Interrupt acknowledge: `/CPU_ACK`

**Key Outputs (to CPU):**
- I/O data: `D[DataBusWidth-1:0]` (read operations)
- Ready/wait: `/READY`
- Interrupt requests: `CPU_INT[3:0]`, `CPU_NMI[1:0]`

**Key Signals (per device slot):**
- Slot select: `/CS[n]`
- Forwarded address and data (profile-specific encoding)
- Interrupt channels: `INT_CH[1:0]`, `NMI_CH` (device‚Üíbackplane)
- Interrupt acknowledge: `/INT_ACK` (backplane‚Üídevice)

**Dependencies:**
- Receives I/O operations from ŒºBITz Host
- Must support CPU board‚Äôs declared widths
- Operates independently of ŒºBITz Bank

**Dependencies:**
- Receives I/O operations from ŒºBITz Host
- Must support CPU board‚Äôs declared widths
- Operates independently of ŒºBITz Bank

**Device Support:**
- Video controllers (VIC-II, VDP, etc.)
- Sound synthesizers (SID, YM2149, OPL, etc.)
- Human input devices (keyboard, joystick, mouse)
- Storage interfaces (floppy, IDE, SD card)
- Serial communications (UART, RS-232)
- Parallel ports (printer, GPIO)
- Network interfaces (Ethernet, WiFi)
- Real-time clocks
- Custom/vendor-specific functions

---

## 0.4 System Integration

### 0.4.1 Enumeration and Configuration

All three subsystems participate in a unified enumeration sequence coordinated by the backplane (or CPU board in Minimal profile):

**Phase 1: Descriptor Discovery**
1. Assert `/RESET` to all subsystems
2. Read CPU Descriptor from ŒºBITz Host
3. Read Bank Descriptor from ŒºBITz Bank
4. Read Device Descriptors from ŒºBITz Dock slots

**Phase 2: Compatibility Validation**
1. Validate Bank address/data width ‚â§ CPU declared widths
2. Validate Dock device widths per profile rules:
- Parallel: All widths exposed; devices adapt
1. Verify no I/O window conflicts (duplicate function/instance mappings)
2. Verify all required functions (per CPU WindowMap[]) are present
3. If a transaction targets no mapped window, reads complete with all-ones (`0xFF/0xFFFF/0xFFFFFFFF`) and writes are ignored (profile may short-circuit before issuing a device transaction).

**Phase 3: Resource Assignment**
1. Build I/O routing table: (IOWin, Mask, OpSel) ‚Üí Slot
2. Build interrupt routing table: (Function, Instance, Channel) ‚Üí CPU pin
3. Configure memory banking if required
4. Apply platform-specific initialization

**Phase 4: Operational**
1. Release `/RESET`
2. CPU begins execution
3. Subsystems respond to their assigned address ranges
4. Fault LED remains OFF (or Status LED indicates ready)

**Enumeration Failure:**
- Missing required function ‚Üí FAULT LED solid ON
- Width incompatibility ‚Üí FAULT LED solid ON
- Window conflict ‚Üí FAULT LED solid ON
- Descriptor read error ‚Üí FAULT LED solid ON

### 0.4.2 Bus Width Negotiation

The platform supports flexible bus widths with the following rules:

**Address Bus Width:**
- CPU declares: 8, 16, or 32 bits
- Bank must support: ‚â• CPU width (for full address space access)
- Dock devices (Parallel): Always receive full A[31:0]; internally decode as needed

**Data Bus Width:**
- CPU declares: 8, 16, or 32 bits

**Width compatibility (normative):**

1. Device `DataBusWidth ‚â§ CPU DataBusWidth` ‚Üí PASS;
2. Device `DataBusWidth > CPU DataBusWidth` ‚Üí FAIL;

**Little-Endian Byte Ordering:**
- All multi-byte values use little-endian byte ordering
- `D[7:0]` = least significant byte
- `D[15:8]` = next byte (16-bit systems)
- `D[23:16]`, `D[31:24]` = additional bytes (32-bit systems)

### 0.4.3 Signal Domains

The platform defines three distinct signal domains:

**Memory Domain (CPU ‚ÜîÔ∏é Bank):**
- Memory address bus: `A[AddressBusWidth-1:0]`
- Memory data bus: `D[DataBusWidth-1:0]`
- Memory request: `/MREQ`
- Read/Write: `R/W_n`(1=read, 0=write)
- Wait/Ready: `/READY` 
- Banking signals: Platform-specific

**I/O Domain (CPU ‚ÜîÔ∏é Dock):**
- I/O address bus: `A[AddressBusWidth-1:0]`
- I/O data bus: `D[DataBusWidth-1:0]`
- I/O request: `/IORQ`
- Read/Write: `R/W_` (1=read, 0=write)
- Ready: `/READY`
- Chip selects: `/CS[Slots-1:0]`

**Interrupt Domain (Dock ‚Üí CPU):**
- Maskable interrupts: `CPU_INT[3:0]` ‚Üê routed from `INT_CH[1:0]` per slot
- Non-maskable interrupts: `CPU_NMI[1:0]` ‚Üê routed from `NMI_CH` per slot
- Acknowledge: `/CPU_ACK` ‚Üí routed to `/INT_ACK` per slot
- Active-low, level-based signaling

**Control Domain (Common):**
- System reset: `/RESET`
- Enumeration bus: I¬≤C (SCL, SDA)

---

## 0.5 Logical Contracts

### 0.5.1 Memory Transaction Contract (CPU ‚ÜîÔ∏é Bank)

**CPU Obligations:**
1. Drive valid address on `A[]` before asserting `/MREQ`
2. Hold address stable throughout memory cycle
3. For writes: Drive data on `D[]` before asserting `R/W_`
4. For reads: Sample data from `D[]` after `R/W_` asserted and `/READY` deasserted
5. Respect `/READY` signal; do not complete cycle until `/READY` released
6. Hold `/MREQ` asserted until cycle complete

**Bank Obligations:**
1. Ignore `A[]` and `D[]` when `/MREQ` = 1 (deasserted)
2. Decode address and determine hit/miss within propagation delay
3. For reads: Drive `D[]` with valid data before releasing `/READY`
4. For writes: Latch `D[]` before cycle completes; update storage atomically
5. Assert `/READY` if cycle cannot complete immediately
6. Release `/READY` only when data valid (read) or write committed (write)
7. Drive `D[]` to high-impedance when not selected or on writes

**Timing Guarantees:**
- Address setup time before `/MREQ`: Platform-specific, typically ‚â•10ns
- Data valid before `/READY` release: Platform-specific, typically ‚â•20ns
- Write data hold after `R/W_` release: Platform-specific, typically ‚â•10ns

### 0.5.2 I/O Transaction Contract (CPU ‚ÜîÔ∏é Dock)

**CPU Obligations:**
1. Drive address on `A[]` and assert `/IORQ` to start I/O cycle
2. Drive `R/W_` (1=read, 0=write) at cycle start
3. For writes: Drive data on `D[]` before asserting `/IORQ`
4. For reads: Sample data from `D[]` after `/READY` = 1
5. Hold `/IORQ` asserted until `/READY` = 1
6. Declare its maximum tolerated `/READY` stretch budget (`ReadyMaxuS`) via the CPU Descriptor.
7. Handle timeout faults reported by the platform (e.g., treat timeout-completed reads as invalid and consult Dock status/telemetry).

**Dock Backplane Obligations:**
1. Decode `(A[] & IOMask) == (IOWin & IOMask)` and `OpSel` match
2. Assert exactly one `/CS[n]` to selected slot (one-hot)
3. Forward complete address `A[]` to selected device (no rewriting)
4. Hold CPU-visible `/READY` = 0 from start of cycle until device ready, but **bounded by** `ReadyMaxuS` (Host-declared).
5. For reads: Ensure `D[]` valid from device before releasing `/READY`
6. For writes: Ensure device has latched `D[]` before releasing `/READY`
7. Release `/READY` = 1 to complete cycle
7a. Enforce `ReadyMaxuS`: if the selected device does not complete before the budget expires, the backplane MUST apply timeout completion (reads return all-ones for the active width; writes treated as not committed), MUST release `/READY` to complete the cycle, and MUST latch a timeout fault.
8. If no window match: Return 0xFF/0xFFFF/0xFFFFFFFF for reads; ignore writes
9. Never deassert `/CS[n]` while `/IORQ` = 0

**Device Obligations:**
1. Ignore all signals when `/CS[n]` = 1 (deasserted)
2. When `/CS[n]` = 0 and `/IORQ` = 0: Decode address internally
3. For reads: Drive valid data on `D[]` (active lanes only)
4. For writes: Latch data from `D[]` (active lanes only)
5. Request cycle stretching only as needed and within the Host‚Äôs declared `ReadyMaxuS` budget (the backplane enforces the bound).
6. Apply multi-byte writes atomically per declared data width
7. For Mode-2 interrupt ack: Return 8-bit vector index when `/INT_ACK[k]` asserted

### 0.5.3 Interrupt Contract (Dock ‚Üí CPU)

**Device Obligations:**
1. Assert `INT_CH[k]` or `NMI_CH` when interrupt condition occurs
2. Hold line asserted (level-based) until condition serviced
3. For Mode-2: When `/INT_ACK` asserted during I/O cycle, return 8-bit vector index
4. Return 0xFF if interrupt not claimed or ack received in error
5. Clear interrupt per documented semantics (read-to-clear, write-to-clear, etc.)
6. Never drive interrupt lines when not asserting (open-drain topology)

**Dock Backplane Obligations:**
1. Provide pull-up resistors on all interrupt lines (typically 3.3kŒ© to 3.3V)
2. Route each slot‚Äôs channels to CPU pins per IntRouting table
3. OR multiple device channels to same CPU pin if mapped (wired-OR)
4. For Mode-2 ack: Identify asserting slot from channel state
5. Route `/CPU_ACK` to `/INT_ACK` on asserting slot only
6. If multiple slots assert same channel: Return 0xFF; do not query devices

**CPU Obligations:**
1. Sample `CPU_INT[3:0]` and `CPU_NMI[1:0]` per platform timing
2. For Mode-2: Assert `/CPU_ACK` during I/O cycle
3. Drive `/IORQ` = 0 and `R/W_` = 1 during ack cycle (vector read)
4. Sample 8-bit vector index from `D[7:0]`
5. Use internal vector base register (I register or equivalent) as high byte
6. Jump to handler at address `{VectorBase, VectorIndex}`
7. Service device(s); read status registers to identify source if multiple devices share pin
8. If no IntAckMode (Mode 0x00): Poll device status registers; no ack cycle

---

## 0.6 Power and Reset

### 0.6.1 Power Domains

The platform defines standardized power rails provided by the backplane:

**Mandatory Rails:**
- **+3.3V** (VCC): Primary logic power for all subsystems
- Regulation: ¬±5% (3.135V - 3.465V)
- Ripple: <50mV peak-to-peak
- Load: Per-subsystem budgets defined in component specifications

**Optional Rails:**
- **+5V** (VCC5): For legacy devices and interfaces
- Regulation: ¬±5% (4.75V - 5.25V)
- Load: Platform-specific; must be documented

- **+12V** (VCC12): Reserved; not used in v1.0
    - Parallel profile explicitly forbids repurposing PCIe 12V pins
    - If 12V is required in a Tile, Bank or Host card, implementer is responsible for proper level shifting. Dock will not provide 12V on any slot pin.

**Ground:**
- **GND**: Common ground for all signals and power
- Star-point grounding at backplane recommended
- Separate analog/digital grounds permitted if documented

### 0.6.2 Reset Sequence

**System Reset (`/RESET`):**
1. Active-low, synchronous reset signal
2. Asserted by CPU board or backplane supervisor
3. Minimum pulse width: 10 CPU clock cycles or 1Œºs, whichever is longer
4. All subsystems must initialize to known state:
- CPU: Program counter to reset vector; registers cleared
- Bank: Memory contents preserved (RAM) or defined (ROM); banking to default state
- Dock: Device registers to documented reset defaults; interrupts deasserted

**Power-On Reset:**
1. Hold `/RESET` asserted until all power rails stable (typically 100ms)
2. Execute enumeration sequence (see ¬ß0.4.1)
3. Release `/RESET` only after enumeration success or timeout
4. If enumeration fails: Keep FAULT LED on; do not release `/RESET`

**Warm Reset:**
1. Assert `/RESET` for minimum pulse width
2. Skip enumeration (descriptors already loaded)
3. Reinitialize subsystem state machines
4. Release `/RESET`

---

## 0.7 Compliance and Certification

### 0.7.1 Subsystem Compliance

A **ŒºBITz Host** compliant CPU board must:
- Provide valid CPU Descriptor via I¬≤C EEPROM (address 0x50)
- Declare AddressBusWidth, DataBusWidth, IntAckMode, WindowMap[], IntRouting[]
- Generate all required control signals per memory and I/O contracts
- Declare `ReadyMaxuS` and handle `/READY` stretching within that budget while tolerating platform-enforced timeout completion semantics
- For Mode-2: Implement vector base register and ack cycle

A **ŒºBITz Bank** compliant memory board must:
- Provide valid Bank Descriptor via I¬≤C EEPROM (address 0x51)
- Support declared widths or fail enumeration
- Meet memory timing contracts (setup, hold, access time)
- Implement atomic multi-byte operations
- Preserve RAM contents through reset (or document volatile behavior)

A **ŒºBITz Dock** compliant I/O system must:
- Provide enumeration and descriptor access for all slots
- Implement function-based routing per CPU WindowMap[]
- Implement interrupt routing per CPU IntRouting[]
- Follow profile-specific electrical and timing rules (Parallel/Minimal)
- Assert FAULT LED on enumeration failure
- Virtualize `/READY` during device transactions

### 0.7.2 Platform Compliance

A **complete ŒºBITz Platform** must:
- Include one CPU board (ŒºBITz Host)
- Include one memory board (ŒºBITz Bank)
- Include one I/O backplane (ŒºBITz Dock) with 0-4 device slots
- Include one Device (ŒºBITz Tile)
- Successfully complete enumeration sequence
- Pass integration test suite (defined per component specifications)

### 0.7.3 Interoperability Testing

Implementations should verify:
- Cross-platform device compatibility (same device works on different CPU boards)
- Width negotiation (8/16/32-bit combinations)
- Interrupt routing (all channels, Mode-2 ack)
- Enumeration failure modes (missing devices, conflicts)
- Timing margins (setup/hold violations, ready stretching)

---

## 0.8 Versioning and Evolution

### 0.8.1 Specification Versioning

**Version Format:** `MAJOR.MINOR`
- **MAJOR**: Incompatible changes (pin maps, contracts, descriptor formats)
- **MINOR**: Backward-compatible additions (new optional features, reserved fields)

**Current Version:** 1.0 (Initial release)

### 0.8.2 Compatibility Rules

**Forward Compatibility:**
- v1.x subsystems should work with v1.y subsystems (y > x)
- New descriptors may add fields; parsers must ignore unknown fields
- Reserved values become defined; old implementations treat as invalid

**Backward Compatibility:**
- v1.y subsystems may work with v1.x subsystems (y > x) if no new required features
- Descriptor version field indicates capabilities

**Cross-Major Version:**
- No compatibility guarantees across major versions (1.x vs 2.x)
- Migration guides provided for each major revision

### 0.8.3 Reserved for Future Use

The following areas are reserved for future specification versions:

**Reserved Values:**
- IntAckMode: 0x02-0xFF (currently: 0x00=None, 0x01=Mode-2)
- Function IDs: 0x0A-0x0F (standard), 0x10-0xFD (vendor-specific)
- 
**Reserved Features:**
- Bus mastering and DMA (requires arbitration protocol)
- Cache coherency (requires snoop/coherency protocol)
- Hot-plug (requires slot power control and link training)
- Multi-master I/O (requires arbitration)
- Partial writes/byte enables (requires lane masking)

**Intentionally NOT Reserved:**
- PCI/PCIe compatibility (not a goal)
- High-speed serial protocols >1 Gbps (out of scope)
- Differential memory interfaces (DDR, etc.)

---

## 0.10 Documentation Structure

The complete ŒºBITz Platform specification consists of:

**Core Specifications:**
1. **ŒºBITz Platform Specification v1.0** (this document)
- Overall architecture, philosophy, contracts

1. **ŒºBITz Host Specification v1.0**
    - CPU board requirements, descriptor format, timing
    - Memory interface details
    - I/O interface details
    - Platform-specific implementations (Z80, 6502, 68000, etc.)
2. **ŒºBITz Bank Specification v1.0**
    - Memory board requirements, descriptor format
    - Memory types (SRAM, DRAM, Flash, ROM)
    - Banking and mapping schemes
    - Timing specifications
3. **ŒºBITz Dock Specification v1.0** (provided)
    - Part 0: Overview
    - Part 1: Core logical model (windows, registers, interrupts)
    - Part 2: Parallel profile (PCIe connector, parallel signals)
    - Part 3: Minimal profile (MCU bridge)
    - Part 4: Reference implementation

**Supporting Documents:**
- Device driver templates and examples
- Enumeration flow diagrams
- Timing diagrams and waveforms
- Compliance test procedures
- Design guidelines and best practices
- Known issues and errata

---

## 0.11 Acknowledgments and License

### 0.11.1 Design Philosophy

The ŒºBITz Platform embodies decades of retro computing knowledge and modern engineering practice. It is designed for education, experimentation, and enjoyment‚Äînot for profit or production use.

### 0.11.2 License

This specification is released under **[LICENSE TO BE DETERMINED]**.

**Permitted Uses:**
- Personal and educational projects
- Open-source hardware designs
- Hobbyist community sharing
- Academic research and teaching

**Restrictions:**
- No warranty or liability for any use
- Not for safety-critical applications
- Attribution required for derivative works

### 0.11.3 Contributing

The ŒºBITz Platform specification is a living document. Feedback, corrections, and improvement suggestions are welcome through **[CONTRIBUTION PROCESS TO BE DETERMINED]**.

---

## 0.12 Glossary

**Address Bus Width**: Number of bits in the address bus (8, 16, or 32)

**Atomic Operation**: Multi-byte operation that completes as a single logical transaction

**Backplane**: Physical infrastructure providing power, signals, and slots

**Bank Switching**: Technique to access more memory than address space allows

**Bank (Memory Board)**: ŒºBITz memory subsystem implementing platform word addressable memory

**Chip Select (CS)**: Signal indicating which device should respond to a bus operation

**CPU Board (Host)**: ŒºBITz Host subsystem implementing platform personality

**Data Bus Width**: Number of bits in the data bus (8, 16, or 32)

**Descriptor**: EEPROM-stored metadata describing subsystem capabilities

**Device**: Peripheral card in ŒºBITz Dock slot providing a function

**Dock (Backplane)**: ŒºBITz Dock subsystem implementing platform IO backplane

**Enumeration**: Discovery and configuration process at system startup

**Function**: Logical device type (video, sound, storage, etc.)

**Host (CPU Board)**: ŒºBITz Host subsystem implementing platform personality

**Instance**: Specific occurrence of a function (e.g., UART instance 0)

**Interrupt Acknowledge (ACK)**: CPU signal to service an interrupt request

**Interrupt Channel**: One of 8 per-slot interrupt lines (4 INT + 4 NMI)

**I/O Request (IORQ)**: Signal qualifying an I/O bus transaction

**Little-Endian**: Byte ordering with least significant byte at lowest address

**Memory Request (MREQ)**: Signal qualifying a memory bus transaction

**Mode-2**: Z80-style vectored interrupt with 8-bit vector index

**Open-Drain**: Output driver that can only pull low (requires external pull-up)

**Platform**: Complete system personality (C64, Apple II, etc.)

**Profile**: Physical implementation variant (Parallel, Minimal)

**Ready/Wait**: Flow control signal for slow memory or I/O devices

**Register**: Device-internal storage location accessed via I/O operations

**Slot**: Physical connector position on backplane for one device

**Subsystem**: One of three major platform components (Host, Bank, Dock)

**Tile (Device Board)**: ŒºBITz Tile implementing platform IO Devices

**Vector Base**: High byte of interrupt vector address (CPU I register)

**Vector Index**: Low byte of interrupt vector address (device-supplied)

**Window**: I/O address range mapped to a function (16-byte granularity)

**Word-Addressed Memory**: Memory accessed by CPU address bus (vs.¬†block storage)

---

## Appendix A: Example System Configurations

### A.1 Minimal C64-Style System

**ŒºBITz Host:**
- Platform: ‚ÄúC64‚Äù
- CPU: 6502 @ 1 MHz (or 65C02 @ 2 MHz)
- Address width: 16-bit
- Data width: 8-bit
- IntAckMode: 0x00 (polling)

**ŒºBITz Bank:**
- 64KB SRAM (0x0000-0xFFFF)
- 8KB Character ROM (mapped via banking)
- No banking by default

**ŒºBITz Dock (Minimal Profile):**
- Slot 0: VIC-II compatible video (Function=VIDEO, Instance=0)
- Slot 1: SID compatible sound (Function=SOUND, Instance=0)
- Slot 2: CIA compatible I/O (Function=HID, Instance=0)
- Slot 3: CIA compatible I/O (Function=HID, Instance=1)

**I/O Mapping:**

```
0xD000-0xD3FF: VIC-II (Window 0xD, Mask 0xFC)
0xD400-0xD7FF: SID    (Window 0xD4, Mask 0xFC)
0xDC00-0xDCFF: CIA1   (Window 0xDC, Mask 0xFF)
0xDD00-0xDDFF: CIA2   (Window 0xDD, Mask 0xFF)
```

### A.2 Apple II-Style System

**ŒºBITz Host:**
- Platform: ‚ÄúAPPLE2‚Äù
- CPU: 6502 @ 1 MHz
- Address width: 16-bit
- Data width: 8-bit
- IntAckMode: 0x00 (no hardware interrupts by default)

**ŒºBITz Bank:**
- 64KB SRAM (48KB main + 16KB language card)
- 12KB ROM (Monitor + Integer BASIC)
- Banking: Language card soft switches

**ŒºBITz Dock (Parallel Profile):**
- Slot 0: Video generator (Function=VIDEO, Instance=0)
- Slot 1: Disk II controller (Function=STORAGE, Instance=0)
- Slot 2: Serial card (Function=SERIAL, Instance=0)

**I/O Mapping (soft switches):**

```
0xC000-0xC0FF: Soft switches and I/O
0xC100-0xC7FF: Peripheral ROM space
0xC800-0xCFFF: Expansion ROM
```

### A.3 ZX Spectrum 48K-Style System

**ŒºBITz Host:**
- Platform: ‚ÄúZX48K‚Äù
- CPU: Z80 @ 3.5 MHz
- Address width: 16-bit
- Data width: 8-bit
- IntAckMode: 0x01 (Mode-2)

**ŒºBITz Bank:**
- 48KB SRAM (0x4000-0xFFFF)
- 16KB ROM (0x0000-0x3FFF)
- No banking

**ŒºBITz Dock:**
- Slot 0: ULA video/audio (Function=VIDEO, Instance=0)
- Slot 1: Keyboard interface (Function=HID, Instance=0)
- Slot 2: Kempston joystick (Function=HID, Instance=1)

**I/O Mapping:**

```
0xFE: ULA (read: keyboard, write: border/speaker)
0x1F: Kempston joystick (read only)
```

**Interrupts:**

```
INT_CH0 ‚Üí CPU_INT[0]: Frame interrupt (50/60 Hz)
Vector: 0xFF (IM2 mode with I=0x3F)
```

### A.4 Advanced 32-bit System

**ŒºBITz Host:**
- Platform: ‚ÄúCUSTOM32‚Äù
- CPU: 68000 @ 16 MHz
- Address width: 24-bit (A[23:0])
- Data width: 16-bit (D[15:0])
- IntAckMode: 0x01 (Mode-2, autovector capable)

**ŒºBITz Bank:**
- 16MB SRAM (0x000000-0xFFFFFF)
- 512KB Flash ROM (0x000000-0x07FFFF, bank-switched)
- Memory management unit for banking

**ŒºBITz Dock (Parallel Profile):**
- Slot 0: Graphics controller (Function=VIDEO, Instance=0)
- Slot 1: Sound synthesizer (Function=SOUND, Instance=0)
- Slot 2: SCSI controller (Function=STORAGE, Instance=0)
- Slot 3: Ethernet controller (Function=NETWORK, Instance=0)

**I/O Mapping:**

```
0xFF0000-0xFF0FFF: Graphics (Window 0xFF0, Mask 0xFFF)
0xFF1000-0xFF1FFF: Sound    (Window 0xFF1, Mask 0xFFF)
0xFF2000-0xFF2FFF: SCSI     (Window 0xFF2, Mask 0xFFF)
0xFF3000-0xFF3FFF: Ethernet (Window 0xFF3, Mask 0xFFF)
```

**Interrupts:**

```
INT_CH0 ‚Üí CPU_INT[2]: Graphics VBlank (IPL2, autovector)
INT_CH1 ‚Üí CPU_INT[3]: Network packet (IPL3, vector $70)
NMI_CH0 ‚Üí CPU_NMI[0]: Abort button
```

---

## Appendix B: Design Guidelines

### B.1 CPU Board Design

**Essential Considerations:**
1. Generate clean, monotonic edges on control signals
2. Implement comprehensive address decoding (memory vs.¬†I/O)
3. Provide adequate timing margins (setup/hold)
4. Include reset circuitry with power-on delay
5. Use I¬≤C EEPROM with write-protect (to prevent accidental corruption)
6. Include debug headers (address bus, data bus, control signals)
7. Implement watchdog timer for I/O timeout detection
8. Consider clock stretching during wait states

**Memory Interface Timing:**

```
Clock cycle timeline (example for 4MHz Z80):
T1: Address valid ‚Üí /MREQ asserted
T2: R/W_ asserted ‚Üí Data setup time
T3: Data sampled (read) or held (write)
Tw: /READY sampled; insert wait states if needed
T3': Final data sample or write completion
```

**I/O Interface Timing:**

```
Clock cycle timeline (example for 4MHz Z80):
T1: Address valid ‚Üí /IORQ asserted
T2: R/W_ asserted ‚Üí Data setup time
Tw: Insert wait states while /READY = 0
T3: Data sampled (read) or write completion
```

### B.2 Memory Board Design

**RAM Considerations:**
1. Use fast SRAM (‚â§70ns) for simple designs
2. DRAM requires refresh controller and RAS/CAS generation
3. Provide battery backup for SRAM if required
4. Include write-protect jumpers for ROM-emulation mode
5. Add status LEDs (activity, bank select)

**ROM/Flash Considerations:**
1. Use in-system programmable Flash for development
2. Provide programming interface (separate from platform bus)
3. Add write-protect switch to prevent accidental erasure
4. Consider ROM socket for authentic retro feel

**Banking Schemes:**

```
Simple banking (4 banks of 16KB each):
- Bank select register at fixed I/O address
- Maps selected bank to CPU address window
- Typical for CP/M systems

Page-frame banking:
- Multiple bank select registers
- Each controls one page frame
- Allows complex memory layouts

Shadow RAM:
- ROM and RAM occupy same address range
- Soft switch selects active memory
- Typical for Apple II language card
```

### B.3 Device Design

**Register Layout Best Practices:**
1. Group related registers (status, control, data)
2. Use read-to-clear for status flags
3. Provide reset values for all registers
4. Document all reserved bits (must write 0, read undefined)
5. Align multi-byte registers to natural boundaries
6. Implement FIFOs for streaming data (audio, network)

**Interrupt Handling:**

```
Typical interrupt flow:
1. Device condition occurs ‚Üí assert INT_CH[k]
2. CPU sees CPU_INT[x] (after routing)
3. CPU asserts /CPU_ACK and /IORQ
4. Device returns vector index on D[7:0]
5. CPU forms address: {I_register, vector_index}
6. CPU jumps to interrupt handler
7. Handler reads device status register
8. Handler clears interrupt condition
9. Device deasserts INT_CH[k]
10. Handler returns from interrupt

Polled interrupt flow (IntAckMode=0x00):
1. Device condition occurs ‚Üí assert INT_CH[k]
2. CPU sees CPU_INT[x] (after routing)
3. CPU jumps to handler (no ack cycle)
4. Handler polls all devices on that pin
5. Handler identifies source by reading status
6. Handler services device
7. Device deasserts INT_CH[k]
8. Handler returns from interrupt
```

**Wait State Generation:**

```
Simple wait state (device-side delay):
- Device requires N clock cycles to respond
- Backplane holds /READY=0 for N cycles
- CPU automatically inserts wait states

Dynamic wait state (busy flag):
- Device has variable processing time
- Device sets internal busy flag
- Backplane monitors busy ‚Üí /READY
- CPU waits until device ready
```

### B.4 Backplane Design

**Power Distribution:**
1. Use wide traces or planes for power rails
2. Star-point ground connection to minimize ground loops
3. Bypass capacitors at each slot (100nF + 10¬µF)
4. Ferrite beads for noise isolation between slots
5. Current limiting or fuses per slot (optional)
6. Power sequencing: 3.3V first, then 5V, then /RESET release

**Signal Integrity:**
1. Keep clock traces short and matched
2. Avoid stubs on high-speed signals
3. Terminate open-drain lines (3.3kŒ© pull-up typical)
4. Guard traces between adjacent signal pairs
5. Keep digital and analog grounds separate if mixed-signal devices present

**Enumeration Controller:**

```
Typical I¬≤C addressing:
0x50: CPU Board EEPROM
0x51: Memory Board EEPROM
0x52: Dock Virtual Slot Device EEPROM
0x53: Dock Slot 0 Device EEPROM
0x54: Dock Slot 1 Device EEPROM
0x55: Dock Slot 2 Device EEPROM
0x56: Dock Slot 3 Device EEPROM

EEPROM size: 512 bytes minimum (descriptor size)
Recommended: 1KB or more for future expansion
```

---

## Appendix C: Troubleshooting Guide

### C.1 Enumeration Failures

**FAULT LED Solid On:**

**Symptom**: System does not boot, FAULT LED illuminated

**Possible Causes**:
1. Missing required device (CPU WindowMap[] not satisfied)
2. I/O window conflict (two devices claim same window)
3. Width incompatibility (device cannot support CPU width)
4. I¬≤C communication failure (cannot read descriptor)
5. Corrupted EEPROM descriptor

**Diagnostic Steps**:
1. Verify all required devices are installed
2. Read CPU descriptor: Check WindowMap[] for required functions
3. Read device descriptors: Verify Function/Instance declarations
4. Check for duplicate (IOWin, Mask, OpSel) mappings
5. Use I¬≤C analyzer to monitor descriptor reads
6. Compare descriptor checksums (if implemented)

### C.2 Memory Issues

**Symptom**: System boots but crashes randomly

**Possible Causes**:
1. Insufficient wait states (memory too slow)
2. Address bus contention (improper tri-stating)
3. Setup/hold timing violations
4. Power supply noise or insufficient bypassing
5. Cold solder joints or poor connections

**Diagnostic Steps**:
1. Scope memory address bus: Clean transitions, no ringing
2. Scope memory data bus: Valid data before CPU samples
3. Scope /MREQ, /RD, /WR: Proper sequencing and timing
4. Check /WAIT timing: Asserted early enough
5. Measure power rails under load: Stable voltage, low ripple
6. Run memory test pattern (walking 1s, walking 0s, checkerboard)

**Symptom**: Memory contents corrupted after power cycle

**Possible Causes**:
1. RAM instead of ROM in ROM socket
2. Write-protect not enabled on Flash
3. Battery backup circuit failed (SRAM)
4. Banking registers not initialized properly

### C.3 I/O Issues

**Symptom**: Device not responding to I/O operations

**Possible Causes**:
1. Wrong I/O window mapping in CPU descriptor
2. Device not claiming correct Function/Instance
3. /CS not asserted (routing error)
4. Address decode error in device
5. /IORQ not qualifying cycles properly

**Diagnostic Steps**:
1. Verify WindowMap[] entry matches device descriptor
2. Check I/O address decode logic
3. Scope /IORQ during I/O instruction
4. Scope /CS[n] to device: Should assert during operation
5. Scope A[] and D[] buses at device: Valid values
6. Check /READY timing: Device releasing at proper time

**Symptom**: I/O operations timeout

**Possible Causes**:
1. Device not releasing /READY
2. Missing pull-up on /READY (open-drain implementations)
3. Slow device without proper wait state handling

### C.4 Interrupt Issues

**Symptom**: Interrupts not firing

**Possible Causes**:
1. Interrupt routing not configured in CPU descriptor
2. Wrong IntRouting[] entry (Function/Instance mismatch)
3. Missing pull-up on interrupt line
4. CPU interrupt mask not enabled (software issue)
5. Device not asserting interrupt line

**Diagnostic Steps**:
1. Check IntRouting[] entries in CPU descriptor
2. Verify device IntChannel declaration in descriptor
3. Scope INT_CH[k] at device: Should be low when asserted
4. Scope CPU_INT[x] at CPU: Should be low after routing
5. Check CPU interrupt enable flags (software)
6. Manually ground interrupt line: Does CPU respond?

**Symptom**: Spurious interrupts or interrupt storms

**Possible Causes**:
1. Device not clearing interrupt flag properly
2. Multiple devices sharing same pin without proper ISR polling
3. Noise on interrupt line (insufficient filtering)
4. Interrupt flag cleared before condition serviced (race condition)

**Diagnostic Steps**:
1. Read device status register in ISR: Verify flag set
2. Clear device interrupt flag explicitly
3. Re-read status: Verify flag cleared
4. Check if device immediately reasserts (unserviced condition)
5. Add debouncing or edge detection if needed

**Symptom**: Mode-2 vector not working

**Possible Causes**:
1. CPU IntAckMode not set to 0x01
2. Device not implementing vector register (ADDR=0x00)
3. /INT_ACK not routed to device
4. Backplane returning 0xFF (multiple claimants)

**Diagnostic Steps**:
1. Verify CPU descriptor IntAckMode = 0x01
2. Scope /CPU_ACK during ack cycle
3. Scope /INT_ACK at device: Should assert
4. Scope D[7:0] during ack: Device should drive vector, not 0xFF
5. Check for multiple devices asserting same INT_CH[k]

---

## Appendix D: Reference Measurements

### D.1 Typical Timing Parameters

**Z80 @ 4 MHz (Example):**

```
Clock period (Tcy):        250 ns
Address setup (Tas):       30 ns (before /MREQ‚Üì)
Address hold (Tah):        10 ns (after /MREQ‚Üë)
Data setup (Tds):          50 ns (before sampling)
Data hold (Tdh):           0 ns (after sampling)
/RD, /WR pulse width:      150 ns minimum
/WAIT setup time:          40 ns (before T2 falling edge)
```

**6502 @ 1 MHz (Example):**

```
Clock period (Tcy):        1000 ns
Address setup (Tas):       PHI2‚Üë + 0 ns
Address hold (Tah):        Hold until next PHI2‚Üë
Data setup (Tds):          100 ns (before PHI2‚Üì)
Data hold (Tdh):           10 ns (after PHI2‚Üì)
R/W setup time:            PHI2‚Üë + 0 ns
/READY setup time:         Sampled at PHI1‚Üë
```

**68000 @ 8 MHz (Example):**

```
Clock period (Tcy):        125 ns (S0-S7 states)
Address setup (Tas):       S0: Address valid
Address hold (Tah):        Hold until S7
Data setup (Tds):          30 ns (before S6 falling edge)
Data hold (Tdh):           0 ns (after S6)
/AS, /DS pulse width:      S2-S6 (typically 375 ns)
/DTACK setup time:         30 ns (before S6 falling edge)
```

### D.2 Power Consumption Guidelines

**Typical Current Draw (per subsystem):**

**ŒºBITz Host (CPU Board):**

```
Z80 @ 4 MHz:              ~50 mA @ 3.3V
6502 @ 1 MHz:             ~30 mA @ 3.3V
68000 @ 8 MHz:            ~100 mA @ 3.3V
Support logic (74HC):     ~10 mA @ 3.3V
Total budget:             150-200 mA @ 3.3V
```

**ŒºBITz Bank (Memory):**

```
64KB SRAM (static):       ~20 mA @ 3.3V
1MB SRAM (static):        ~50 mA @ 3.3V
Flash ROM (idle):         ~5 mA @ 3.3V
Flash ROM (programming):  ~20 mA @ 3.3V
Total budget:             50-100 mA @ 3.3V
```

**ŒºBITz Dock Device (typical):**

```
Simple I/O (UART, GPIO):  ~20 mA @ 3.3V
Video controller:         ~100 mA @ 3.3V
Sound synthesizer:        ~50 mA @ 3.3V
Network interface:        ~150 mA @ 3.3V
Storage controller:       ~75 mA @ 3.3V
Total per slot budget:    150-200 mA @ 3.3V
```

**System Total (4-slot maximum):**

```
CPU Board:                200 mA
Memory Board:             100 mA
4√ó Device Boards:         800 mA
Backplane overhead:       100 mA
Total system:             1200 mA @ 3.3V (4 watts)
Recommended PSU:          2A @ 3.3V (6.6 watts) minimum
```

---

## Appendix E: Migration from Other Systems

### E.1 From ISA Bus

**Key Differences:**
- ŒºBITz uses function-based addressing (not geographic/slot addressing)
- No DMA or bus mastering in v1.0
- Simpler interrupt model (2+1 channels per slot vs.¬†ISA IRQ lines)
- Enumeration via I¬≤C (not PnP configuration registers)

**Migration Strategy:**
1. Map ISA I/O addresses to ŒºBITz windows
2. Convert ISA IRQ to IntChannel declarations
3. Replace DMA with programmed I/O or FIFOs

### E.2 From Commodore 64 Expansion Port

**Key Differences:**
- ŒºBITz separates I/O (Dock) from memory (Bank)
- Multiple device slots (vs.¬†single cartridge port)
- Enumeration replaces manual jumper configuration
- Standardized interrupt routing

**Migration Strategy:**
1. Split cart into separate I/O and memory boards if needed
2. Declare Function (e.g., Function=STORAGE for disk interface)
3. Map I/O registers to window (e.g., 0xDE00-0xDEFF)
4. Convert /GAME, /EXROM to banking descriptors
5. Map /IRQ, /NMI to IntChannel declarations

### E.3 From Apple II Slots

**Key Differences:**
- ŒºBITz does not provide ROM space per slot
- Function-based addressing (not slot-based $Cn00 ranges)
- Enumeration replaces slot number self-identification

**Migration Strategy:**
1. Move slot firmware to device Flash or host ROM
2. Map slot I/O (*C*0*n*0‚àíC0nF) to windows
3. Declare device function in descriptor
4. Convert slot interrupts to IntChannel

---

## Appendix F: Frequently Asked Questions


**Q: Why no DMA or bus mastering?**

A: v1.0 focuses on simplicity. DMA requires arbitration, multi-master protocols, and interrupt-driven state machines. Programmed I/O with FIFOs covers most retro use cases. Future versions may add DMA.

**Q: Can I use 12V for motor control or power amplifiers?**

A: Not on the standard connectors. Parallel profile explicitly forbids repurposing PCIe 12V pins. Add separate power connectors for high-voltage peripherals.

**Q: How do I handle multiple devices needing the same interrupt?**

A: Map both devices to the same CPU pin in IntRouting[]. The CPU ISR polls device status registers to identify which device(s) need service. This is standard practice on retro systems.

**Q: Can memory boards provide I/O registers?**

A: Memory boards should only provide RAM/ROM. I/O registers belong on Dock devices. If a memory system configuration requires banking, provide that function via its Host board.

**Q: What if my CPU doesn‚Äôt have an I/O instruction?**

A: Use memory-mapped I/O. The CPU board synthesizes /IORQ by decoding specific address ranges. Example: 6502 maps *D*000‚àíDFFF to I/O; CPU board asserts /IORQ for accesses in that range.

**Q: Can I hot-swap device cards?**

A: Not safely in v1.0. Power down before inserting or removing cards. 

**Q: How do I implement a custom function type?**

A: Use Function IDs 0x10-0xFF (vendor-specific range). Document the register map and I/O protocol. Other builders can reuse your function type by matching the Function ID in their CPU descriptors.

**Q: What‚Äôs the maximum achievable I/O bandwidth?**

A: Depends on profile and CPU speed:
- Parallel @ 4MHz Z80: ~1 MB/s (byte I/O with 4 clocks/byte)
- Minimal: Limited by MCU bridge (typically 1-5 MB/s)

Real-world applications rarely exceed these limits in retro computing contexts.

---

**END OF ŒºBITz PLATFORM SPECIFICATION v1.0**

[ŒºBITz Dock Specification v1.0](%CE%BCBITz%20Dock%20Specification%20v1%200%2029c84f5aa5ee801ebf1adc59ea394003.md)

[ŒºBITz Versatile Tile Classes ‚Äî Overview Specification](%CE%BCBITz%20Versatile%20Tile%20Classes%20%E2%80%94%20Overview%20Specificat%202af84f5aa5ee8039b746f722fb57a73e.md)
