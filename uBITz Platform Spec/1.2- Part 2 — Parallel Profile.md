# Part 2 — Parallel Profile (Parallel Bus)

**Status:** Normative
**Version:** 1.0
**Date:** 2025

**Depends on:** Part 1 (Core)

---

## 2.1 Scope and relationship to Core

This Part defines the **Parallel Profile**: a direct, multi-slot parallel bus
backplane based on a repurposed PCIe x16 connector. It refines—but does not
alter—the Core’s logical model. On any conflict, **Core prevails**.

The Parallel Profile is intended for:

* “Big box” μBITz systems where **board area and connector height** are less
  constrained than SI pampering.
* Builds that prefer **simple glue logic** (CPLDs, small FPGAs) over SERDES:
  backplane logic can often be implemented as a few state machines plus address
  decode.
* High-bandwidth Tiles (video, sound, storage) that benefit from a wide, low-latency
  I/O path and predictable timing.

**Core requirements preserved by this profile (normative):**

* **Logical model:** Functions, windows, registers, interrupts, and enumeration
  are exactly as described in Core. Devices see the same `WindowMap[]` and
  `IntRouting[]` semantics regardless of profile.
* **Addressing:** The backplane selects a slot by `(IOWin, IOMask, OpSel)` on
  `A[AddressBusWidth-1:0]` and forwards the **entire CPU I/O address** to the device unchanged.
* **I/O transaction semantics:** The CPU asserts `/IORQ` as defined in Core.
  The backplane uses `/READY` (device→backplane) to stretch CPU-visible cycles
  while a transaction is in progress. Devices MAY extend `/READY`; the CPU
  implements a timeout policy.
* **Bus widths:** `AddressBusWidth ∈ {8,16,32}`, `DataBusWidth ∈ {8,16,32}` on
  the CPU side. This profile exposes a **fixed 32-bit connector** for both
  `A[31:0]` and `D[31:0]`; backplanes and devices MUST adapt to the CPU
  descriptor widths or fail enumeration.
* **Interrupt topology:** Channels are **per-slot**: `INT_CH[1:0]`, `NMI_CH`,
  and `/INT_ACK` for each slot. Mode-2 ack returns an **8-bit vector** on
  `D[7:0]` and is routed to the asserting slot, as in Core.

The Parallel Profile and Minimal Profile share the same **logical** behavior; the
difference is purely physical (connector, routing, SI).

---

## 2.2 Physical connector and power (summary)

This profile uses a **PCIe x16** edge connector mechanically, but reassigns
pins for a 32-bit I/O bus and per-slot interrupts. 

**Relation to Serial Profile.**  
The PCIe x16 pin map in this section is the **canonical mechanical mapping** for both the Parallel Profile (this Part) and the Serial Profile (Part 3).

The Serial Profile reuses this exact connector and signal placement:

- Pins explicitly named `SER_B2D_*`, `SER_D2B_*`, and `SER_REFCLK_*` in the table are driven as LVDS lanes by Serial-profile Docks and Tiles (see Part 3, §3.2.1).
    
- All other pins (address, data, control, power, ground, GPIO) retain the **same physical location and direction** in both profiles.

---
### Parallel Profile — PCIe x16 Pin Map (uBITz Parallel Bus)

| PIN# | Side (odd/even) | Direction (B/D) | Type  | Name         | Description                                                                                                                  |
| ---- | --------------- | --------------- | ----- | ------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| 1    | odd             | B->D            | POWER | VCC_5V       | Main 5 V rail (slot power).                                                                                                  |
| 1    | even            | D<->B           | IO    | GPIO0        | Optional - Reserved for Dock debug sideband (open-drain, 3.3 V)                                                              |
| 2    | odd             | B->D            | POWER | VCC_5V       | Main 5 V rail (slot power).                                                                                                  |
| 2    | even            | B->D            | POWER | VCC_5V       | Main 5 V rail (slot power).                                                                                                  |
| 3    | odd             | B->D            | POWER | VCC_5V       | Main 5 V rail (slot power).                                                                                                  |
| 3    | even            | B->D            | POWER | VCC_5V       | Main 5 V rail (slot power).                                                                                                  |
| 4    | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 4    | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 5    | odd             | B->D            | IO    | SLOT_SCL     | Enumeration I²C clock (open-drain, backplane master).                                                                        |
| 5    | even            | B->D            | IO    | /RESET       | Global system reset from backplane (active-low).                                                                             |
| 6    | odd             | B↔D             | IO    | SLOT_SDA     | Enumeration I²C data (open-drain, bidirectional).                                                                            |
| 6    | even            | B->D            | IO    | /IORQ        | I/O cycle qualifier from backplane (active-low).                                                                             |
| 7    | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 7    | even            | D<->B           | IO    | GPIO1        | Optional - Reserved for Dock debug sideband (open-drain, 3.3 V)                                                              |
| 8    | odd             | B->D            | POWER | VCC_3V3      | Main 3.3 V rail.                                                                                                             |
| 8    | even            | D<->B           | IO    | GPIO2        | Optional - Reserved for Dock debug sideband (open-drain, 3.3 V)                                                              |
| 9    | odd             | B->D            | IO    | /CS          | Per-slot chip select from backplane (active-low).                                                                            |
| 9    | even            | B->D            | POWER | VCC_3V3      | Main 3.3 V rail.                                                                                                             |
| 10   | odd             | B->D            | POWER | VCC_3V3_STBY | Standby 3.3 V rail (always-on / sleep power).                                                                                |
| 10   | even            | B->D            | POWER | VCC_3V3      | Main 3.3 V rail.                                                                                                             |
| 11   | odd             | B->D            | IO    | /INT_ACK     | Interrupt acknowledge from backplane to device (active-low).                                                                 |
| 11   | even            | B->D            | IO    | R/W_         | Read/Write direction (1=READ, 0=WRITE).                                                                                      |
| 12   | odd             | D<->B           | IO    | GPIO3        | Optional - Reserved for Dock debug sideband (open-drain, 3.3 V)                                                              |
| 12   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 13   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 13   | even            | D<->B           | IO    | GPIO4        | Optional - Reserved for Dock debug sideband (open-drain, 3.3 V)                                                              |
| 14   | odd             | B->D            | IO    | A[0]         | Address bit 0 (LSB).                                                                                                         |
| 14   | even            | D<->B           | IO    | GPIO5        | Optional - Reserved for Dock debug sideband (open-drain, 3.3 V)                                                              |
| 15   | odd             | B->D            | IO    | A[1]         | Address bit 1.                                                                                                               |
| 15   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 16   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 16   | even            | B↔D             | IO    | D[0]         | Data bit 0 (LSB).                                                                                                            |
| 17   | odd             | B->D            | IO    | A[2]         | Address bit 2.                                                                                                               |
| 17   | even            | B↔D             | IO    | D[1]         | Data bit 1.                                                                                                                  |
| 18   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 18   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 19   | odd             | B->D            | IO    | A[3]         | Address bit 3.                                                                                                               |
| 19   | even            | B↔D             | IO    | D[2]         | Data bit 2.                                                                                                                  |
| 20   | odd             | B->D            | IO    | A[4]         | Address bit 4.                                                                                                               |
| 20   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 21   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 21   | even            | B↔D             | IO    | D[3]         | Data bit 3.                                                                                                                  |
| 22   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 22   | even            | B↔D             | IO    | D[4]         | Data bit 4.                                                                                                                  |
| 23   | odd             | B->D            | IO    | A[5]         | Address bit 5.                                                                                                               |
| 23   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 24   | odd             | B->D            | IO    | A[6]         | Address bit 6.                                                                                                               |
| 24   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 25   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 25   | even            | B↔D             | IO    | D[5]         | Data bit 5.                                                                                                                  |
| 26   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 26   | even            | B↔D             | IO    | D[6]         | Data bit 6.                                                                                                                  |
| 27   | odd             | B->D            | IO    | A[7]         | Address bit 7.                                                                                                               |
| 27   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 28   | odd             | B->D            | IO    | A[8]         | Address bit 8.                                                                                                               |
| 28   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 29   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 29   | even            | B↔D             | IO    | D[7]         | Data bit 7.                                                                                                                  |
| 30   | odd             | B->D            | IO    | A[9]         | Address bit 9.                                                                                                               |
| 30   | even            | B↔D             | IO    | D[8]         | Data bit 8.                                                                                                                  |
| 31   | odd             | B->D            | IO    | A[10]        | Address bit 10.                                                                                                              |
| 31   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 32   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 32   | even            | B↔D             | IO    | D[9]         | Data bit 9.                                                                                                                  |
| 33   | odd             | B->D            | IO    | A[11]        | Address bit 11.                                                                                                              |
| 33   | even            | B↔D             | IO    | D[10]        | Data bit 10.                                                                                                                 |
| 34   | odd             | B->D            | IO    | A[12]        | Address bit 12.                                                                                                              |
| 34   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 35   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 35   | even            | B↔D             | IO    | D[11]        | Data bit 11.                                                                                                                 |
| 36   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 36   | even            | B↔D             | IO    | D[12]        | Data bit 12.                                                                                                                 |
| 37   | odd             | B->D            | IO    | A[13]        | Address bit 13.                                                                                                              |
| 37   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 38   | odd             | B->D            | IO    | A[14]        | Address bit 14.                                                                                                              |
| 38   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 39   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 39   | even            | B↔D             | IO    | D[13]        | Data bit 13.                                                                                                                 |
| 40   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 40   | even            | B↔D             | IO    | D[14]        | Data bit 14.                                                                                                                 |
| 41   | odd             | B->D            | IO    | A[15]        | Address bit 15.                                                                                                              |
| 41   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 42   | odd             | B->D            | IO    | A[16]        | Address bit 16.                                                                                                              |
| 42   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 43   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 43   | even            | B↔D             | IO    | D[15]        | Data bit 15.                                                                                                                 |
| 44   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 44   | even            | B↔D             | IO    | D[16]        | Data bit 16.                                                                                                                 |
| 45   | odd             | B->D            | IO    | A[17]        | Address bit 17.                                                                                                              |
| 45   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 46   | odd             | B->D            | IO    | A[18]        | Address bit 18.                                                                                                              |
| 46   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 47   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 47   | even            | B↔D             | IO    | D[17]        | Data bit 17.                                                                                                                 |
| 48   | odd             | B->D            | IO    | A[19]        | Address bit 19.                                                                                                              |
| 48   | even            | B↔D             | IO    | D[18]        | Data bit 18.                                                                                                                 |
| 49   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 49   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 50   | odd             | B->D            | IO    | A[20]        | Address bit 20.                                                                                                              |
| 50   | even            | B↔D             | IO    | D[19]        | Data bit 19.                                                                                                                 |
| 51   | odd             | B->D            | IO    | A[21]        | Address bit 21.                                                                                                              |
| 51   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 52   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 52   | even            | B↔D             | IO    | D[20]        | Data bit 20.                                                                                                                 |
| 53   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 53   | even            | B↔D             | IO    | D[21]        | Data bit 21.                                                                                                                 |
| 54   | odd             | B->D            | IO    | A[22]        | Address bit 22.                                                                                                              |
| 54   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 55   | odd             | B->D            | IO    | A[23]        | Address bit 23.                                                                                                              |
| 55   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 56   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 56   | even            | B↔D             | IO    | D[22]        | Data bit 22.                                                                                                                 |
| 57   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 57   | even            | B↔D             | IO    | D[23]        | Data bit 23.                                                                                                                 |
| 58   | odd             | B->D            | IO    | A[24]        | Address bit 24.                                                                                                              |
| 58   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 59   | odd             | B->D            | IO    | A[25]        | Address bit 25.                                                                                                              |
| 59   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 60   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 60   | even            | B↔D             | IO    | D[24]        | Data bit 24.                                                                                                                 |
| 61   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 61   | even            | B↔D             | IO    | D[25]        | Data bit 25.                                                                                                                 |
| 62   | odd             | B->D            | IO    | A[26]        | Address bit 26.                                                                                                              |
| 62   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 63   | odd             | B->D            | IO    | A[27]        | Address bit 27.                                                                                                              |
| 63   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 64   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 64   | even            | B↔D             | IO    | D[26]        | Data bit 26.                                                                                                                 |
| 65   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 65   | even            | B↔D             | IO    | D[27]        | Data bit 27.                                                                                                                 |
| 66   | odd             | B->D            | IO    | A[28]        | Address bit 28.                                                                                                              |
| 66   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 67   | odd             | B->D            | IO    | A[29]        | Address bit 29.                                                                                                              |
| 67   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 68   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 68   | even            | B↔D             | IO    | D[28]        | Data bit 28.                                                                                                                 |
| 69   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 69   | even            | B↔D             | IO    | D[29]        | Data bit 29.                                                                                                                 |
| 70   | odd             | B->D            | IO    | A[30]        | Address bit 30.                                                                                                              |
| 70   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 71   | odd             | B->D            | IO    | A[31]        | Address bit 31 (MSB).                                                                                                        |
| 71   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 72   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 72   | even            | B↔D             | IO    | D[30]        | Data bit 30.                                                                                                                 |
| 73   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 73   | even            | B↔D             | IO    | D[31]        | Data bit 31 (MSB).                                                                                                           |
| 74   | odd             | B->D            | IO    | SER_B2D_P    | Serial Link Differential Pair +<br>Backplane to Device<br>* Unconnected in Parallel only Dock Implementation                 |
| 74   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 75   | odd             | B->D            | IO    | SER_B2D_N    | Serial Link Differential Pair -<br>Backplane to Device<br>* Unconnected in Parallel only Dock Implementation                 |
| 75   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 76   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 76   | even            | D->B            | IO    | /READY       | Device wait-state indication to backplane (active-low).                                                                      |
| 77   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 77   | even            | D->B            | IO    | /INT_CH0     | Maskable interrupt channel 0 from device.                                                                                    |
| 78   | odd             | D->B            | IO    | SER_D2B_P    | Serial Link Differential Pair D+<br>Device to Backplane<br>* Unconnected in Parallel only Dock Implementation                |
| 78   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 79   | odd             | D->B            | IO    | SER_D2B_N    | Serial Link Differential Pair D-<br>Device to Backplane<br>* Unconnected in Parallel only Dock Implementation                |
| 79   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 80   | odd             | B->D            | GND   | GND          | Ground.                                                                                                                      |
| 80   | even            | D->B            | IO    | /INT_CH1     | Maskable interrupt channel 1 from device.                                                                                    |
| 81   | odd             | B->D            | IO    | SER_REFCLK_P | Serial Link Differential Pair Optional Ref Clk+<br>Backplane to Device<br>* Unconnected in Parallel only Dock Implementation |
| 81   | even            | D->B            | IO    | /NMI_CH      | Non-maskable interrupt channel from device.                                                                                  |
| 82   | odd             | B->D            | IO    | SER_REFCLK_N | Serial Link Differential Pair Optional Ref Clk-<br>Backplane to Device<br>* Unconnected in Parallel only Dock Implementation |
| 82   | even            | B->D            | GND   | GND          | Ground.                                                                                                                      |

---

**Serial-profile reuse of connector pins (normative)**  
The PCIe x16 pin map in this section is **shared by both the Parallel and Serial Profiles**. The following pins are reserved for the Serial Profile’s LVDS link as defined in Part 3 (Serial):

- `SER_B2D_P`, `SER_B2D_N` — backplane→device LVDS data pair    
- `SER_D2B_P`, `SER_D2B_N` — device→backplane LVDS data pair    
- `SER_REFCLK_P`, `SER_REFCLK_N` — optional backplane→device LVDS reference clock    

A **Parallel-only Dock implementation** MUST leave these pins unconnected at the backplane and MUST NOT drive them. A Dock that supports the Serial Profile MAY populate LVDS PHYs on these pins while still supporting Parallel-profile Tiles, provided:

- The Dock never drives `SER_*` for slots whose Device Descriptor does not claim the Serial Profile, and    
- Parallel Tiles are specified to tolerate the presence of powered-up but idle LVDS receivers on the backplane side only.

---
### 2.2.1 Rails

  #### Power rails overview (normative)

The Parallel Profile reuses the PCIe x16 mechanical connector but simplifies and normalizes the power rails for hobbyist-friendly designs:

* **3.3 V main (`VCC_3V3`)**
  This is the primary logic and local-regulator supply for all Tiles. Every compliant Dock MUST provide `VCC_3V3` to each slot, and every compliant Tile MUST be able to operate solely from this rail (plus ground).

* **3.3 V standby (`VCC_3V3_STBY`)**
  This rail is intended for always-on or low-power management domains (e.g., RTC, soft-power controller, Dock management MCU). When present, it remains powered in system “soft off” states. Tiles that do not need standby power simply leave this pin unconnected.

* **5 V auxiliary (`VCC_5V`)**
  Pins formerly used as 12 V in PCIe are repurposed as a **5 V auxiliary rail**. Docks MUST provide 5 V to these pins; Tiles MUST use it for higher-power local converters (e.g., analog audio, backlight, small motors).

* **No 12 V rail**
  The Parallel Profile v1.x does **not** define a 12 V rail on the connector. Any higher-voltage requirements must be satisfied by on-Tile conversion from 3.3 V or optional 5 V.

For each implemented rail, the Dock specification MUST state:

* The **per-slot** current budget and the maximum total current across all populated slots.
* Any sequencing constraints between `VCC_3V3`, `VCC_3V3_STBY`, and `VCC_5V` (for example: “3.3 V stable before 5 V is enabled”).

Tiles MUST respect these limits and design their inrush and bulk capacitance so that worst-case hot-seat insertion into an unpowered backplane does not exceed connector ratings. Full live hot-plug is not required or guaranteed by the profile.

---

#### Relation to Core logical signal set

The PCIe x16 pin map in this section is a **physical instantiation** of the Core logical signal set defined in Part 1 (Core Logical Specification). In particular:

* `/IORQ` on the connector corresponds directly to the Core **I/O cycle qualifier** signal used to delimit I/O transactions.
* `R/W_` corresponds to the Core **read/write direction** signal (`1=READ`, `0=WRITE`), used by both Dock and Tiles to distinguish read vs write cycles.
* `A[31:0]` corresponds to the Core **I/O address bus**, with the effective width given by `AddressBusWidth` in the CPU Descriptor.
* `D[31:0]` corresponds to the Core **I/O data bus**, with the effective width given by `DataBusWidth` in the CPU Descriptor. On the Parallel Profile this is exposed as a true 32-bit, bidirectional parallel bus.
* `/READY` is the Core **wait-state / ready** signal, aggregated on the Dock and sourced by the selected Tile to stretch I/O cycles.
* `/CS` is the per-slot **chip-select** derived from the Core `WindowMap[]` decode of `(IOWin, IOMask, OpSel)` on `A[7:0]`. Only the selected slot’s `/CS` is asserted for a given I/O cycle.
* `/INT_CH0`, `/INT_CH1`, and `/NMI_CH` are the per-slot **interrupt channels** defined by Core, feeding into the Core `IntRouting[]` matrix and then on to `/CPU_INT[x]` and `/CPU_NMI[y]` at the Host.
* `/INT_ACK` and the CPU-side `/CPU_ACK` together implement the Core **vectored acknowledge** mechanism when `IntAckMode = 0x01` (Mode-2 style).
* `SLOT_SCL` and `SLOT_SDA` carry the Core **enumeration/control bus** (I²C in the reference design), used to read each Tile’s Device Descriptor and to populate `WindowMap[]` and `IntRouting[]`.

As a result, a Parallel-profile Dock or Tile designer can treat the signal table in §2.2 as a **direct physical mapping** of the logical interface described in Part 1:

* If a signal appears in the Core logical model, it has a unique, named location in the PCIe x16 table.
* If a PCIe pin is marked `NC` in the table, it is **outside** the μBITz standard for v1.x and MUST NOT be driven or interpreted by generic Dock/Tile designs.

This guarantees that any correctly implemented Parallel Dock + Tiles pair is logically interchangeable with other μBITz profiles (Minimal, Serial) as long as the Core contracts (enumeration, windows, interrupts) are respected.


### 2.2.2 Bus exposure

**Parallel bus exposure (backplane side):**

* `A[31:0]` – address bus, driven by the CPU card / host interface.
* `D[31:0]` – data bus, bidirectional, little-endian byte lanes.
* `/IORQ` – active-low I/O cycle qualifier from the CPU.
* `R/W_` – read/write select (`1=READ`, `0=WRITE`), active-low write.
* `/READY` – active-low wait-state signal from devices via the backplane to CPU.
* `/RESET` – synchronous reset, backplane→devices and backplane→CPU (per Core).

**Per-slot interrupt and ack (backplane side):**

* `/INT_CH[1:0]` – per-slot maskable interrupt request lines, device→backplane.
* `/NMI_CH` – per-slot non-maskable interrupt request line, device→backplane.
* `/INT_ACK` – per-slot active-low interrupt acknowledge from backplane to
  device (during Mode-2 cycles or profile-defined ack phases).

**CPU-facing interrupt signals:**

* `/CPU_INT[3:0]` – maskable interrupt outputs from backplane to CPU.
* `/CPU_NMI[1:0]` – non-maskable interrupt outputs from backplane to CPU.
* `/CPU_ACK` – active-low interrupt acknowledge from CPU to backplane.

**Enumeration bus:**

* I²C or another platform-defined control bus, as described in Part 1 and the
  Host/Backplane specs. This profile does not constrain exact pins, only that
  enumeration is available on every slot.

> Note: The **connector** is always wired for `A[31:0]`/`D[31:0]`. If the CPU
> descriptor declares narrower widths (e.g. 8- or 16-bit), higher-order lanes
> MUST be treated as **unused** and MUST NOT carry additional signals.

### 2.2.3 Optional GPIO/DBG sideband (GPIO0–GPIO5)

The connector reserves six sideband pins `GPIO0–GPIO5` for platform-specific and debug use. For Parallel Profile v1.x they are treated as **out-of-band** by the μBITz standard:

* A compliant Dock or Tile **MUST NOT** depend on any particular function on `GPIO0–GPIO5` for:
  * basic power-up,
  * enumeration, or
  * normal I/O operation and interrupt delivery.

* Production Tiles **MUST** operate correctly with all of `GPIO0–GPIO5` left unconnected.

**Electrical rules (normative)**

* `GPIO0–GPIO5` are single-ended, **3.3 V open-drain** lines, multi-drop between Dock and Tile.
* Docks that use these pins **SHOULD** provide appropriate pull-ups so that each line has a defined idle level.
* Any Tile or Dock that drives these pins **MUST** only sink current (open-drain behavior); no device may drive them push-pull.

**Allowed uses (informative)**

Examples of valid, non-standardized uses include:

* Dock implementations routing `GPIOx` to a management MCU to provide:
  * a simple “monitor” interface (peek at enumeration state, reset a Tile or the Host, twiddle bits), or
  * a firmware-upload or debug console for Tiles.
* Tiles exposing `GPIOx` as:
  * configuration straps or mode selects,
  * debug/test pads, or
  * general-purpose inputs to an on-Tile MCU or FPGA.

Any such use **MUST** be documented in the corresponding Dock or Tile implementation notes, but is never required for μBITz conformance.

---

## 2.3 Signal mapping to Core logical set

The Parallel Profile implements the Core’s logical signal set directly as
parallel, single-ended pins (no framing or serialization).

**CPU↔Backplane (C⇄B / C→B / B→C):**

* `/IORQ` (C→B) – CPU asserts low to qualify I/O cycles.
* `R/W_` (C→B) – CPU read/write direction.
* `A[AddressBusWidth-1:0]` (C→B) – CPU I/O address.
* `D[DataBusWidth-1:0]` (C⇄B) – bidirectional data bus.
* `/READY` (B→C) – backplane stretches CPU cycles while low.
* `/RESET` (B→C) – backplane/host reset distribution.
* `/CPU_INT[3:0]` (B→C) – routed maskable interrupt lines to CPU.
* `/CPU_NMI[1:0]` (B→C) – routed NMI lines to CPU.
* `/CPU_ACK` (C→B) – CPU interrupt acknowledge (Mode-2-style when enabled).

**Backplane↔Device (B⇄D / B→D / D→B):**

* `/CS[Slot#-1:0]` (B→D) – per-slot device select; one-hot during normal I/O.
* `R/W_` (B→D) – forwarded read/write direction from CPU.
* `A[AddressBusWidth-1:0]` (B→D) – forwarded address, unchanged.
* `D[DataBusWidth-1:0]` (B⇄D) – data bus as seen by devices.
* `/READY` (D→B) – device wait-state indication to backplane.
* `/INT_CH[1:0]` (D→B) – per-slot maskable interrupt channels.
* `/NMI_CH` (D→B) – per-slot NMI channel.
* `/INT_ACK` (B→D) – per-slot interrupt acknowledge during Mode-2.

The backplane MAY implement additional debugging or sideband signals, but they
MUST NOT alter the logical semantics above.

### 2.3.1 Bus ownership and tri-stating (normative)

To avoid bus contention:

* `A[]`, `/IORQ`, `R/W_`, `/RESET`, `/CPU_INT[]`, `/CPU_NMI[]`, `/CPU_ACK`,
  and `/CS[]` are always **driven by exactly one source** (CPU or backplane),
  and devices MUST treat them as **inputs** only.
* `D[]` is **shared**:

  * On **WRITE** cycles (`R/W_ = 0`):

    * The CPU/backplane side drives `D[DataBusWidth-1:0]` for the entire period
      where `/IORQ=0` and `/READY=0`.
    * Devices MUST treat `D[]` as input-only and MUST NOT drive it.
  * On **READ** cycles (`R/W_ = 1`):

    * The CPU/backplane MUST tri-state its drivers on `D[]` before asserting
      `/IORQ`.
    * Only the selected slot (its `/CS` asserted) MAY drive `D[]`, and only while
      `/IORQ=0` and `/READY=0`.
* When no I/O transaction is active (`/IORQ=1`), both CPU/backplane and devices
  MUST tri-state `D[]`.

For `/READY`:

* CPU sees a **single** `/READY` line.
* Only the addressed slot MAY actively drive its `(D→B)` `/READY` contribution
  (low to stretch the cycle). All other slots MUST present a high-Z / idle
  level to the backplane’s `/READY` aggregator.

---

## 2.4 Transaction semantics and timing

The Parallel Profile exposes a **single-cycle, synchronous parallel bus**. The
CPU owns all bus timing (as per the platform’s CPU board); the backplane and
devices MUST conform to the CPU board’s published timing diagrams.

**Normative properties:**

* **Cycle qualification:**

  * `/IORQ=0` and a valid `A[]`/`R/W_` define a single I/O transaction.
  * Non-I/O cycles (`/IORQ=1`) MUST be ignored by the Dock backplane.
* **Slot selection:**

  * The backplane decodes `(IOWin, IOMask, OpSel)` from `A[7:0]` as described
    in Core and asserts **exactly one** `/CS[slot]` low during the data phase
    of a mapped I/O cycle (or no `/CS` for unmapped cycles).
  * The full address is forwarded to the selected slot.
* **/READY handling:**

  * During an I/O cycle, the backplane drives CPU-visible `/READY` as the
    **logical AND** of slot-local `/READY` responses and any internal gating
    (but only the selected slot MUST actively drive its contribution).
  * Devices MAY hold `/READY` low to stretch the cycle; the CPU board defines
    the maximum allowed stretch and timeout behavior.
* **Atomic multi-byte operations:**

  * When the CPU board issues 16- or 32-bit I/O operations, devices MUST treat
    them as atomic, consistent with Core rules. The backplane MUST not break or
    reorder the byte lanes.
* **Unmapped windows:**

  * If no `WindowMap` entry matches an I/O cycle, the backplane MUST NOT assert
    any `/CS`. Reads return all-ones (0xFF per byte) and writes are ignored,
    following platform/Core policy.

Timing diagrams and absolute setup/hold requirements are defined by the CPU
board and backplane implementation; this Part only constrains **relative**
semantics (which signal means what, and how they interact).

### 2.4.1 Example WRITE cycle (informative)

A typical 8- or 16-bit CPU write on a Parallel backplane proceeds as:

1. CPU places `ADDR` on `A[]`, data on `D[]`, and `R/W_ = 0`.
2. CPU asserts `/IORQ=0`.
3. Backplane:

   * Decodes `(IOWin, IOMask, OpSel)` from `A[7:0]`.
   * Asserts `/CS[slot]` to the selected slot (if any).
4. Device in that slot:

   * Sees `/CS=0`, `R/W_ = 0`, and `A[]` stable.
   * If ready immediately, leaves `/READY` high.
   * If not ready, asserts `/READY=0` until internal state is ready to accept
     the write.
5. When `/READY` is high again at the CPU:

   * CPU deasserts `/IORQ` and proceeds to the next cycle.
   * Device latches data per its own internal timing (within the Core rules).

The CPU board MUST guarantee that `A[]` and `D[]` are valid and stable for the
entire window in which the device samples them (platform-specific).

### 2.4.2 Example READ cycle (informative)

A typical read on a Parallel backplane:

1. CPU places `ADDR` on `A[]`, sets `R/W_ = 1`, and tri-states its `D[]`
   drivers.
2. CPU asserts `/IORQ=0`.
3. Backplane:

   * Decodes `(IOWin, IOMask, OpSel)` from `A[7:0]`.
   * Asserts `/CS[slot]` to the selected slot (if any).
4. Device in that slot:

   * Sees `/CS=0`, `R/W_ = 1`, and `A[]` stable.
   * Drives `D[]` with the requested data when ready.
   * Holds `/READY=0` until its output data is stable.
5. When the device is ready, it releases `/READY` to 1 while still driving
   valid data on `D[]`.
6. CPU samples `D[]`, then deasserts `/IORQ`.

Devices MUST NOT drive `D[]` outside the window where `/CS=0` and `R/W_=1` and
`/IORQ=0`.

---

## 2.5 Interrupt handling

Interrupt semantics follow Core and the Dock specification; this section
summarizes how they appear on a parallel bus.

### 2.5.1 Per-slot lines and routing

**Per-slot interrupt wiring (device→backplane):**

* Each slot exposes:

  * `INT_CH[1:0]` – up to 2 maskable interrupt channels.
  * `NMI_CH` – up to 1 non-maskable interrupt channel.
* Lines are level-sensitive as per Core. Devices MUST tri-state/idle them
  appropriately when unused.

**Backplane routing (backplane→CPU):**

* The backplane consults `IntRouting[]` (from the CPU descriptor) and the
  current slot population to map `(Function, Instance, Channel)` to
  `/CPU_INT[x]` or `/CPU_NMI[y]`.
* Only one interrupt may be active at the CPU at a time, per Core’s
  serialization rules. Additional requests remain asserted at the slot but are
  blocked at the backplane until the active source clears.
  (Slots themselves are free to have multiple pending causes in their
  **status registers**; Core only serializes what is presented to the CPU pins.)

### 2.5.2 Mode-2 acknowledge over Parallel

When `IntAckMode = 0x01` (Mode-2-style) in the CPU descriptor, ack cycles are
mapped as follows:

1. The CPU performs a Mode-2 acknowledge cycle, asserting `/CPU_ACK` and
   performing a vector read per its own bus protocol.
2. The backplane:

   * Determines the **active slot/channel** from `INT_CH[1:0]` and `IntRouting`.
   * Routes `/INT_ACK` to that slot (and only that slot) for the duration of
     the acknowledge.
3. The device:

   * During `/INT_ACK` assertion, treats a read at its designated vector
     endpoint (typically `ADDR=0x00` within its window) as a **Vector Register**
     read and returns an 8-bit vector index on `D[7:0]`.
   * Outside of ack cycles, `ADDR=0x00` is a normal device register.
4. The backplane forwards this 8-bit vector value directly on the CPU data bus
   during the acknowledge cycle.

**Multiple claimants:**

* If more than one slot claims the same channel when the CPU acknowledges,
  the backplane MUST present `0xFF` to the CPU and MUST NOT assert `/INT_ACK`
  to any single slot.

**Clearing interrupts:**

* `irq_ack`-equivalent behavior in the Parallel Profile is embodied by
  `/INT_ACK` and `/CPU_ACK`. Devices MUST NOT clear interrupts solely on
  `/INT_ACK`; instead they clear when the device-specific clear sequence
  completes (per Core’s interrupt clear semantics).

### 2.5.3 IntAckMode = None (polling)

When `IntAckMode = 0x00` (no special ack cycle) in the CPU descriptor:

* The CPU MUST NOT use `/CPU_ACK` for normal interrupt processing.
* The backplane MUST ignore `/CPU_ACK` and MUST NOT assert `/INT_ACK` in
  response to CPU behavior.
* Devices MUST treat `/INT_ACK` as inactive in this mode and rely on their
  documented register-based status/clear mechanism.
* `IntRouting[]` is still used to present **which channel** reaches which
  `/CPU_INT[]` or `/CPU_NMI[]` pin, but interrupt source identification is done
  in software (polling or status register reads).

This ensures the same physical backplane can support both **polling-only**
CPUs and CPUs with true Mode-2-style vectored ack.

---

## 2.6 Widths and slot count

**Connector and backplane:**

* The Parallel Profile connector always exposes **32 address bits** and
  **32 data bits**.
* Slot count is 1–4; implementations MAY reserve additional positions for
  internal services (e.g. an internal Dock Tile or management MCU) that are
  not exposed as user slots.

**CPU descriptor interaction:**

* `AddressBusWidth` and `DataBusWidth` in the CPU descriptor declare how many
  of the `A[]` and `D[]` lanes are valid.
* Backplanes MUST:

  * Connect only the lower `AddressBusWidth` and `DataBusWidth` lanes to the
    CPU board.
  * Treat unused lanes as reserved; they MUST NOT carry unrelated signals.
* Devices MUST:

  * Respect the announced widths; accesses beyond the declared `DataBusWidth`
    or `AddressBusWidth` are undefined.
  * Ignore the state of unused high-order lanes; they may be left floating or
    tied off internally by the backplane, but MUST NOT be interpreted as
    additional address bits or sideband flags.

---

## 2.7 Compliance checklist — Device (Parallel)

A conformant Parallel-profile **device** MUST:

* Connect to `A[AddressBusWidth-1:0]`, `D[DataBusWidth-1:0]`, `/CS`, `R/W_`,
  `/READY`, `/RESET`, `INT_CH[1:0]`, `NMI_CH`, and `/INT_ACK` as specified.
* Implement register maps, windowing, and OpSel behavior as defined in Core and
  reflected in the CPU’s `WindowMap[]`.
* Implement interrupt behavior per Core:

  * Assert `INT_CH[k]`/`NMI_CH` based on internal status.
  * Provide an 8-bit Vector Register at the designated endpoint for Mode-2 and
    drive the vector index on `D[7:0]` while `/INT_ACK` is active.
  * Clear interrupts only after the documented clear sequence; not merely on
    `/INT_ACK`.
* Observe the platform’s electrical limits (drive strength, timing) on the
  shared data and control buses.
* Participate in enumeration on the platform’s enumeration bus with a valid
  Device Descriptor (per Core), including:

  * Correct Function IDs and Instances.
  * Correct declaration of supported interrupt channels.

Devices MAY:

* Leave unused interrupt channels unconnected.
* Implement additional, device-specific sideband signals via reserved pins,
  provided they do not conflict with the required logical set.
* Share a physical PCB design across profiles (Serial, Parallel, Minimal) by
  placing profile-specific front-ends in different BOM variants, so long as the
  Core behavior and device descriptors remain consistent.

---

## 2.8 Compliance checklist — Backplane (Parallel)

A conformant Parallel-profile **backplane** MUST:

* Expose `A[31:0]`, `D[31:0]`, `/IORQ`, `R/W_`, `/READY`, `/RESET`,
  `/INT_CH[1:0]`, `/NMI_CH`, `/INT_ACK`, `/CPU_INT[3:0]`, `/CPU_NMI[1:0]`,
  and `/CPU_ACK` per this Part and Core.
* Implement Core decode:

  * Decode `(IOWin, IOMask, OpSel)` from `A[7:0]`.
  * Assert exactly one `/CS[slot]` during mapped I/O cycles.
  * Forward the full CPU address and appropriate control lines to the selected
    slot.
* Implement `/READY` handling:

  * Reflect device `/READY` to the CPU, enforcing that only the selected slot
    contributes to the aggregated `/READY`.
  * Provide any platform-required watchdog or timeout behavior (e.g. failing
    a stuck-low `/READY`).
* Implement interrupt routing as per `IntRouting[]`:

  * Serialize multiple pending interrupts so only one is presented to the CPU.
  * Maintain a record of the **active source** (slot + channel) for ack routing.
  * Route `/CPU_ACK` to the correct slot via `/INT_ACK` (Mode-2).
  * Provide the `0xFF` fallback vector when multiple claimants or no claimant
    exist for a Mode-2 ack.
* Maintain electrical integrity:

  * Provide appropriate terminations, pull-ups, and filtering for interrupt and
    control lines.
  * Ensure trace lengths, loading, and connector selection meet the timing and
    SI requirements for the intended clock rate.

Backplanes MAY:

* Support fewer than 4 slots, but MUST advertise this accurately via
  descriptors.
* Provide per-slot power gating, hot-plug detection, or other conveniences
  provided they do not alter the logical contract.
* Integrate a “Dock services” Tile on an internal slot (LEDs, debug UART,
  fan control, etc.) that is not mechanically exposed.

---

## 2.9 Timing (informative)

Parallel-profile timing is dominated by the CPU’s I/O bus timing and device
response times. There is no serial pipeline; the backplane adds only routing
and buffering delay.

Builders are encouraged to:

* Target backplane/controller clocks in the **25–50 MHz** range when possible
  for mainstream hobbyist PCBs; slower clocks are acceptable for simpler
  layouts.
* Keep trace lengths and loading within typical PCIe x16 mechanical
  recommendations (solid reference planes, controlled impedance) even though
  the signals are not PCIe protocol signals.
* Clearly specify in Host/Backplane documentation:

  * Maximum supported `AddressBusWidth` and `DataBusWidth`.
  * Maximum I/O clock rate.
  * Any additional skew or propagation constraints between `A[]`, `D[]`,
    `/IORQ`, and `/READY`.

Parallel-profile devices that internally run at much higher clocks (e.g., video
Tiles) SHOULD use internal FIFOs or buffering to present a **stable, slow**
register interface to the CPU, rather than exposing deep timing coupling
between real-time pipelines and I/O access timing.

---

## 2.10 Reserved values & future-proofing

* Higher `DataBusWidth` / `AddressBusWidth` values (>32) are reserved for
  future revisions.
* Additional interrupt channels per slot are reserved; v1.x mandates at most
  `INT_CH[1:0]` and one `NMI_CH`.
* Additional CPU interrupt pins (`/CPU_INT[>3]`, `/CPU_NMI[>1]`) are reserved.

Future revisions MAY:

* Extend the number of interrupts, bus widths, or slots.
* Introduce profile-specific sideband signals.
* Define “wide Parallel” connectors mechanically distinct from PCIe x16 while
  maintaining the same logical contract.

All such extensions MUST remain backward compatible with correctly implemented
v1.x devices and backplanes.

---
## Appendix C — Conformance Matrix (informative)

### C.1 Device (Parallel Profile)

| ID   | Requirement (summary)                                                                                                                                                        | Spec §               | How to verify                                                                                                                                                                      |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| D-1  | Powers all mandatory logic (enumeration + register bank) from **VCC_3V3**; may use **VCC_3V3_STBY** and optional **VCC_5V**, but must not *require* 5 V for basic operation. | 2.2, 2.7             | Power a slot with 3.3 V (and 3.3 V standby if used), leave 5 V off. Run Host self-test that enumerates the Tile and does basic register reads; confirm it works without 5 V.       |
| D-2  | Uses only the rails and pins defined in the Parallel pin map; all pins marked **NC** in §2.2 remain unbonded/undriven on the Tile.                                           | 2.2, 2.7             | Schematic/layout review: NC pads not routed. Continuity test NC pins on a bare board or assembled Tile; confirm open-circuit to all nets and supplies.                             |
| D-3  | Connects to `A[AddressBusWidth-1:0]` and ignores higher-order address pins; behavior is defined only up to declared `AddressBusWidth`.                                       | 2.3, 2.6, 2.7        | With test firmware, sweep addresses where only high bits differ (e.g. `0x0000` vs `0x8000` for 15-bit width). Use LA to confirm Tile only responds within the defined range.       |
| D-4  | Connects to `D[DataBusWidth-1:0]` and **never** drives higher-order data pins; high lanes must remain idle/high-Z from the device.                                           | 2.3, 2.2.1, 2.6, 2.7 | On a Host with 32-bit bus, perform READ cycles while monitoring all `D[31:0]` with an LA. Confirm only low `DataBusWidth` bits toggle; upper bits stay at pull level.              |
| D-5  | Obeys bus ownership: drives `D[]` only on READ cycles while `R/W_ = 1`, `/IORQ = 0` and its `/CS = 0`; never drives `D[]` on WRITE cycles.                                   | 2.2.1, 2.4, 2.7      | Connect Tile and a “bus sniffer” card or LA. Run Host test that randomly mixes reads and writes. Check that Tile’s output-enable on D matches only the legal READ windows.         |
| D-6  | Drives `/READY` only when selected (`/CS = 0`); must not pull `/READY` low when not addressed.                                                                               | 2.3.1, 2.4, 2.7      | Install two Tiles; have firmware repeatedly access only Tile A. With LA on `/CS`, `/READY`, confirm only A’s accesses cause wait-states. Tile B should never affect `/READY`.      |
| D-7  | Implements Core register map semantics under `WindowMap[]` and `OpSel`; responds only in its configured windows and ignores unmapped addresses.                              | 2.1, 2.4, 2.7        | After enumeration, have Host self-test program Tile windows and probe within/outside these ranges. Verify via LA that device only asserts `/READY` and drives `D[]` in-range.      |
| D-8  | Treats multi-byte (16/32-bit) I/O operations as **atomic**, with little-endian byte ordering on `D[]`.                                                                       | 2.4, 2.6, 2.7        | Use firmware to write 16/32-bit patterns (e.g. `0x1234`, `0x89ABCDEF`) and immediately read back. LA should show low byte on `D[7:0]`, contiguous bytes on higher lanes.           |
| D-9  | Exposes per-slot interrupt lines `INT_CH[1:0]` and `NMI_CH` with electrical behavior per Core (open-drain/level as required by platform).                                    | 2.2, 2.5, 2.7        | With scope/LA and known pull-ups on Dock, toggle device interrupt bits in firmware. Verify correct idle level, active level, and that lines can be wire-OR’d safely.               |
| D-10 | If vectored interrupts (`IntAckMode = 0x01`) are supported, provides an 8-bit **Vector Register** and returns the vector on `D[7:0]` while `/INT_ACK` is asserted.           | 2.5.2, 2.7           | Configure CPU descriptor for Mode-2. Trigger device INT, then have Host issue an ack cycle. Capture `/INT_ACK`, `A[]`, `D[7:0]` with LA; confirm expected vector byte is observed. |
| D-11 | When `IntAckMode = 0x00` (polling mode), ignores `/INT_ACK` and does not change any internal state in response to it.                                                        | 2.5.3, 2.7           | Configure Host for polling mode and still pulse `/CPU_ACK`. Verify via device status registers and LA that `/INT_CHx` behavior is unchanged by the ack pulse.                      |
| D-12 | Participates in enumeration via `SLOT_SCL`/`SLOT_SDA` and exposes a valid Device Descriptor (Function IDs, widths, interrupts, etc.).                                        | 2.2, 2.6, 2.7        | Use a simple I²C dump tool on the Host side. Read the Tile’s descriptor and check fields match the hardware (bus widths, IRQ channels, function type).                             |
| D-13 | Meets platform timing for setup/hold relative to `/IORQ`, `R/W_`, `A[]`, `D[]`, and `/READY` at the target bus frequency.                                                    | 2.4, 2.9, 2.7        | With scope/LA at max rated bus clock, run stress test (random read/write patterns). Measure setup/hold on signals at the slot; confirm margins meet Host timing diagrams.          |

---

### C.2 Backplane (Parallel Profile)

| ID   | Requirement (summary)                                                                                                                                                           | Spec §          | How to verify                                                                                                                                                                             |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| B-1  | Provides **VCC_3V3** to every slot; may provide **VCC_3V3_STBY** and optional **VCC_5V**. Respects documented per-slot and total current limits.                                | 2.2, 2.8, 2.9   | Connect programmable loads or Tiles with known consumption. Measure slot voltages and currents under worst-case population; confirm they remain within spec and no rail droop or reset.   |
| B-2  | Implements the Parallel pin map exactly; all pins marked **NC** in §2.2 are unconnected.                                                                                        | 2.2, 2.8        | Schematic/layout review of the backplane connector. Use continuity tests from connector fingers to the PCB; NC pads should not connect to any net, plane, or test point.                  |
| B-3  | Exposes `A[31:0]`, `D[31:0]`, `/IORQ`, `R/W_`, `/READY`, `/RESET`, `/CS[slot]`, `INT_CH[1:0]`, `NMI_CH`, `/INT_ACK`, `/CPU_INT[3:0]`, `/CPU_NMI[1:0]`, `/CPU_ACK` as specified. | 2.2, 2.3, 2.8   | With no Tiles or with a passive “breakout” Tile, probe slot pins while Host exercises basic cycles. Confirm presence, direction, and idle levels for all required signals.                |
| B-4  | Decodes `(IOWin, IOMask, OpSel)` from `A[7:0]` and asserts **exactly one** `/CS[slot]` (or none) for each mapped I/O cycle.                                                     | 2.1, 2.4, 2.8   | Plug in multiple Tiles or LED test cards. Run firmware that sweeps addresses. With LA, check that at most one `/CS[x]` is low for any `/IORQ` and that unmapped ranges assert none.       |
| B-5  | Forwards the **full CPU address** and `R/W_` to the selected slot unchanged.                                                                                                    | 2.1, 2.3, 2.4   | Use a Tile that can latch and expose the last address seen (e.g., via debug register). Compare CPU address vs. Tile’s latched value for a variety of accesses; they should match exactly. |
| B-6  | Aggregates `/READY` so only the **selected** slot can stretch the CPU cycle; non-selected Tiles must not affect CPU-visible `/READY`.                                           | 2.2.1, 2.4, 2.8 | Install two Tiles; have Tile A hold `/READY` low for a programmable time on access. Use LA to confirm CPU `/READY` tracks only Tile A accesses and is unaffected by Tile B behavior.      |
| B-7  | For unmapped windows, does not assert any `/CS`; CPU reads return all-ones (`0xFF`, `0xFFFF`, or `0xFFFFFFFF` depending on data width).                                         | 2.4, 2.6, 2.8   | With at least one Tile present, perform reads to clearly unmapped addresses. Confirm via LA that no `/CS` toggles and Host firmware sees all-ones patterns.                               |
| B-8  | Preserves atomicity of 16/32-bit I/O operations; must not reorder byte lanes or split wide accesses into visible partial writes to the Tile.                                    | 2.4, 2.6, 2.8   | Attach a Tile that exposes internal per-byte write strobes. Using firmware, do 16/32-bit writes while watching strobes with LA; confirm all bytes commit together, never partially.       |
| B-9  | Routes per-slot `INT_CH[1:0]` and `NMI_CH` to `/CPU_INT[3:0]` and `/CPU_NMI[1:0]` according to `IntRouting[]` from the CPU descriptor.                                          | 2.1, 2.5, 2.8   | Program routing tables; for each channel on each slot, assert interrupts in firmware and monitor CPU interrupt pins with LA. Confirm mapping matches routing configuration.               |
| B-10 | Serializes interrupts at the CPU: only one source is actively presented at a time; additional requests stay pending at Tiles until the active one is cleared.                   | 2.5.1, 2.8      | Make two Tiles assert different interrupt channels simultaneously. Observe CPU interrupts and device status: CPU should service them one-by-one while both remain asserted at the slots.  |
| B-11 | In Mode-2 (`IntAckMode = 0x01`), tracks the active source (slot + channel) and routes `/CPU_ACK` to that slot via `/INT_ACK` only.                                              | 2.5.2, 2.8      | With LA on `/CPU_ACK`, `/INT_ACK[x]` lines, trigger an interrupt, then ack. Verify only the slot that asserted the interrupt sees `/INT_ACK` during the ack cycle.                        |
| B-12 | In Mode-2, issues a vector read and forwards the 8-bit vector byte from the Tile on `D[7:0]` during the ack cycle.                                                              | 2.5.2, 2.8      | Use a Tile with known vector. On ack, capture `A[]`, `/CS`, `D[7:0]` with LA. Confirm the backplane holds `/CS` and the CPU sees the Tile’s vector byte at the correct cycle.             |
| B-13 | If multiple claimants or no claimant exist for a given ack, returns `0xFF` as vector and does not assert `/INT_ACK` to any single slot.                                         | 2.5.2, 2.8      | Configure two Tiles to assert the same channel. Trigger ack. LA should show CPU reading `0xFF` on `D[7:0]` while no `/INT_ACK[x]` line is pulsed to any specific slot.                    |
| B-14 | When `IntAckMode = 0x00` (polling mode), ignores `/CPU_ACK` and never asserts `/INT_ACK` in response.                                                                           | 2.5.3, 2.8      | Set CPU descriptor to polling mode and deliberately toggle `/CPU_ACK`. Use LA to confirm `/INT_ACK` lines remain idle for all slots.                                                      |
| B-15 | Maintains signal integrity suitable for the target bus frequency (grounding, return paths, controlled impedance and fanout).                                                    | 2.2, 2.9, 2.10  | SI review (field solver or vendor guidelines), then run at or above target MHz with several worst-case Tiles installed; check for error-free operation and absence of visible ringing.    |

---

### C.3 Interop Test Checklist (informative)

This section provides a **practical bring-up script** for a Parallel-profile Dock + Tile combination, similar in spirit to the Serial Profile Interop checklist. It assumes:

* A Host board with basic μBITz firmware,
* At least one “simple” Tile (e.g., a register-mapped debug Tile),
* A logic analyzer on the Parallel bus, and optionally a scope on power rails.

#### C.3.1 Power-on & reset

1. **Rails in-spec**

   * Power the Dock with no Tiles installed. Measure `VCC_3V3`, `VCC_3V3_STBY` (if present), and `VCC_5V` (if present) at one slot.
   * Confirm voltages match the Dock documentation and remain within tolerance under a light dummy load.

2. **Tile insertion**

   * Insert a single Tile. Power-on the system. Verify inrush does not cause visible droop or resets on other logic (scope on 3.3 V rail).

3. **Reset propagation**

   * Trigger a system reset from the Host (hardware or software).
   * Check `/RESET` at the slot: it should assert low, then deassert cleanly with defined slew; Tile should re-enumerate correctly afterwards.

---

#### C.3.2 Basic I/O cycles

1. **Idle bus sanity**

   * With no firmware accessing the Tile, observe `A[]`, `D[]`, `/IORQ`, `R/W_`, `/READY`. They should remain static/idle (no spurious activity).

2. **WRITE8/16/32**

   * Run a Host self-test that writes known patterns (e.g. `0x55`, `0xAA`, `0x1234`, `0x89ABCDEF`) into a few Tile registers.
   * On LA, confirm:

     * `A[]` is stable before `/IORQ` fall and during the write,
     * `R/W_ = 0`,
     * `D[]` holds the expected data while `/IORQ = 0` and `/READY = 0`.
   * Read back from the Tile and verify values match.

3. **READ8/16/32**

   * Run a Host test that reads the same registers.
   * On LA, confirm:

     * Host tri-states `D[]` before `/IORQ` goes low and `R/W_ = 1`,
     * Tile drives `D[]` only while `/CS = 0` and `/IORQ = 0`,
     * Readback values match previously written data.

4. **Unmapped window**

   * Access an address range with no Tile mapped.
   * Confirm: no `/CS` asserts, `/READY` stays high (no stretch), CPU returns all-ones.

---

#### C.3.3 Contention & bus ownership

1. **Dual-Tile selection**

   * Install two Tiles in different slots. Configure their windows so they do **not** overlap.
   * Sweep addresses over both mappings; on LA, check only one `/CS[x]` is ever active for a given `/IORQ`.

2. **Overlap detection (negative test)**

   * Temporarily program overlapping windows in firmware (or misconfigure intentionally, on a lab setup).
   * Observe that both `/CS` lines may assert; note this as a misconfiguration. The spec does not require hardware to prevent such overlap, but your compliance tests should detect it and prevent shipping that config.

3. **D-bus tri-state**

   * With two Tiles installed, run randomized read/write test.
   * Use LA to verify there are no instances where more than one Tile drives `D[]` simultaneously during valid read windows (would show as “mushed” waveforms or illegal bus levels).

---

#### C.3.4 Interrupts

1. **Level assert / clear**

   * Configure `INT_CH0` on a Tile to assert when a particular status bit is set.
   * Trigger the condition in firmware; monitor `INT_CH0` at the slot and `/CPU_INT[x]` at the Host.
   * Clear the condition via the Tile’s documented register write; confirm both lines return to idle.

2. **Vectored Mode-2 path**

   * Configure CPU descriptor with `IntAckMode = 0x01`.
   * Trigger Tile interrupt, then issue an interrupt acknowledge cycle.
   * On LA, check:

     * CPU asserts `/CPU_ACK`,
     * Dock routes `/INT_ACK` only to the active slot,
     * `D[7:0]` during the ack contains the Tile’s configured vector.

3. **Multiple pending sources**

   * Configure two Tiles (or two channels on one Tile) to assert different interrupts at the same time.
   * Ensure that:

     * CPU sees one interrupt first, services it, then sees the second,
     * During each ack, `/INT_ACK` is routed to the correct slot and the correct vector appears on `D[7:0]`.

4. **Polling mode**

   * Switch CPU descriptor to `IntAckMode = 0x00`.
   * Assert interrupts on a Tile and confirm:

     * `/CPU_ACK` pulses (if any) do not cause `/INT_ACK` on any slot,
     * Device interrupts are cleared only via register accesses, not by ack pulses.

---

#### C.3.5 Corner cases & robustness

1. **Slow Tile (`/READY` stretching)**

   * Configure a Tile (or test firmware on a Versatile Tile) to deliberately hold `/READY` low for a programmable number of cycles on access.
   * Confirm Host correctly inserts wait states and does not time out prematurely at the nominal setting.

2. **Stuck-low `/READY`**

   * Force a Tile into a “hung” state where `/READY` never deasserts (for test purposes).
   * Verify Host/Dock timeout behavior: CPU should recover (e.g., reset or abort), and the backplane should not be damaged by prolonged wait-state conditions.

3. **Reset during active I/O**

   * While the Host repeatedly accesses the Tile, assert `/RESET`.
   * Check that bus lines return to their idle state, `D[]` is tri-stated by Tiles, and after reset the system cleanly re-enumerates the Tile.

4. **Max populate & SI sanity**

   * Populate all available slots with Tiles of varying load.
   * Run a worst-case firmware pattern (back-to-back max-width reads/writes).
   * With LA/scope, verify: clean transitions on `A[]`, `D[]`, `/IORQ`, `/READY`, no obvious ringing or cross-talk at the target clock rate.

