	# Part 2 — Parallel Profile (Parallel Bus)

**Status:** Normative
**Version:** 1.0
**Date:** 2025

**Depends on:** Part 1 (Core)

---

## 2.1 Scope and relationship to Core

This Part defines the **Parallel Profile**: a direct, multi-slot parallel bus
backplane based on a repurposed PCIe x16 connector. It refines—but does not
alter—the Core’s logical model. On any conflict, **Core prevails**.

The Parallel Profile is intended for:

* “Big box” μBITz systems where **board area and connector height** are less
  constrained than SI pampering.
* Builds that prefer **simple glue logic** (CPLDs, small FPGAs) over SERDES:
  backplane logic can often be implemented as a few state machines plus address
  decode.
* High-bandwidth Tiles (video, sound, storage) that benefit from a wide, low-latency
  I/O path and predictable timing.

**Core requirements preserved by this profile (normative):**

* **Logical model:** Functions, windows, registers, interrupts, and enumeration
  are exactly as described in Core. Devices see the same `WindowMap[]` and
  `IntRouting[]` semantics regardless of profile.
* **Addressing:** The backplane selects a slot by `(IOWin, IOMask, OpSel)` on
  `A[AddressBusWidth-1:0]` and forwards the **entire CPU I/O address** to the device unchanged.
* **I/O transaction semantics:** The CPU asserts `/IORQ` as defined in Core.
  The backplane uses slot-local `/READY` (device→backplane) plus internal gating to drive CPU-visible `/READY` while a transaction is in progress. Devices MAY extend slot-local `/READY`, but the backplane MUST enforce the Host-declared `ReadyMaxuS` budget and apply timeout completion if exceeded.
* **Bus widths:** `AddressBusWidth ∈ {8,16,32}`, `DataBusWidth ∈ {8,16,32}` on
  the CPU side. This profile exposes a **fixed 32-bit connector** for both
  `A[31:0]` and `D[31:0]`; backplanes and devices MUST adapt to the CPU
  descriptor widths or fail enumeration.
* **Interrupt topology:** Channels are **per-slot**: `INT_CH[1:0]`, `NMI_CH`,
  and `/INT_ACK` for each slot. Mode-2 ack returns an **8-bit vector** on
  `D[7:0]` and is routed to the asserting slot, as in Core.

The Parallel Profile and Minimal Profile share the same **logical** behavior; the
difference is purely physical (connector, routing, SI).

---

## 2.2 Physical connector and power (summary)

This profile uses a **PCIe x16** edge connector mechanically, but reassigns
pins for a 32-bit I/O bus and per-slot interrupts. 

---
### Parallel Profile — PCIe x16 Pin Map (uBITz Parallel Bus)


| PIN# | Side (A/B) | Direction (B/D) | Type  | Name          | Description                                                                                                            |
| ---- | ---------- | --------------- | ----- | ------------- | ---------------------------------------------------------------------------------------------------------------------- |
| 1    | B          | B->D            | POWER | +5V_MAIN      | Main 5 V rail (slot power).                                                                                            |
| 1    | A          | D→B             | SENSE | /DRV5V        | Strap low only if the card may **drive 5V outputs** onto any shared bus/control line. Dock pull-up in AON.             |
| 2    | B          | B->D            | POWER | +5V_MAIN      | Main 5 V rail (slot power).                                                                                            |
| 2    | A          | B->D            | POWER | +5V_MAIN      | Main 5 V rail (slot power).                                                                                            |
| 3    | B          | B->D            | POWER | +5V_MAIN      | Main 5 V rail (slot power).                                                                                            |
| 3    | A          | B->D            | POWER | +5V_MAIN      | Main 5 V rail (slot power).                                                                                            |
| 4    | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 4    | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 5    | B          | B->D            | IO    | SLOT_SCL      | Enumeration I²C clock (open-drain, backplane master).                                                                  |
| 5    | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 6    | B          | B↔D             | IO    | SLOT_SDA      | Enumeration I²C data (open-drain, bidirectional).                                                                      |
| 6    | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 7    | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 7    | A          | B->D            | IO    | CLK_HOST      | Reference clock from Host (passed through Dock to Tiles).                                                              |
| 8    | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 8    | A          | B->D            | IO    | CLK_DOCK0     | Reference clock 0 from Dock.                                                                                           |
| 9    | B          | B->D            | POWER | +3V3_MAIN     | Main 3.3 V rail.                                                                                                       |
| 9    | A          | B->D            | POWER | +3V3_MAIN     | Main 3.3 V rail.                                                                                                       |
| 10   | B          | B->D            | POWER | +3V3_MAIN     | Main 3.3 V rail.                                                                                                       |
| 10   | A          | B->D            | POWER | +3V3_MAIN     | Main 3.3 V rail.                                                                                                       |
| 11   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 11   | A          | D->B            | SENSE | /SENS3V       | Strap low only if the card is **3.3V-only / not 5V-tolerant**. Dock pull-up in AON.                                    |
| 12   | B          | B->D            | IO    | CLK_DOCK1     | Reference clock 1 from Dock.                                                                                           |
| 12   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 13   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 13   | A          | B->D            | IO    | CLK_DOCK2     | Reference clock 2 from Dock.                                                                                           |
| 14   | B          | B->D            | IO    | A0            | Address bit 0 (LSB).                                                                                                   |
| 14   | A          | B->D            | IO    | CLK_DOCK3     | Reference clock 3 from Dock.                                                                                           |
| 15   | B          | B->D            | IO    | A1            | Address bit 1.                                                                                                         |
| 15   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 16   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 16   | A          | B↔D             | IO    | D31           | Data bit 31 (MSB).                                                                                                     |
| 17   | B          | B->D            | IO    | A2            | Address bit 2.                                                                                                         |
| 17   | A          | B↔D             | IO    | D30           | Data bit 30.                                                                                                           |
| 18   | B          | B->D            | IO    | A3            | Address bit 3.                                                                                                         |
| 18   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 19   | B          | B->D            | IO    | A4            | Address bit 4.                                                                                                         |
| 19   | A          | B↔D             | IO    | D29           | Data bit 29.                                                                                                           |
| 20   | B          | B->D            | IO    | A5            | Address bit 5.                                                                                                         |
| 20   | A          | B↔D             | IO    | D28           | Data bit 28.                                                                                                           |
| 21   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 21   | A          | B↔D             | IO    | D27           | Data bit 27.                                                                                                           |
| 22   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 22   | A          | B↔D             | IO    | D26           | Data bit 26.                                                                                                           |
| 23   | B          | B->D            | IO    | A6            | Address bit 6.                                                                                                         |
| 23   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 24   | B          | B->D            | IO    | A7            | Address bit 7.                                                                                                         |
| 24   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 25   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 25   | A          | B↔D             | IO    | D25           | Data bit 25.                                                                                                           |
| 26   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 26   | A          | B↔D             | IO    | D24           | Data bit 24.                                                                                                           |
| 27   | B          | B->D            | IO    | A8            | Address bit 8.                                                                                                         |
| 27   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 28   | B          | B->D            | IO    | A9            | Address bit 9.                                                                                                         |
| 28   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 29   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 29   | A          | B↔D             | IO    | D23           | Data bit 23.                                                                                                           |
| 30   | B          | B->D            | IO    | A10           | Address bit 10.                                                                                                        |
| 30   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 31   | B          | B->D            | IO    | A11           | Address bit 11.                                                                                                        |
| 31   | A          | B↔D             | IO    | D22           | Data bit 22.                                                                                                           |
| 32   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 32   | A          | B↔D             | IO    | D21           | Data bit 21.                                                                                                           |
| 33   | B          | B->D            | IO    | A12           | Address bit 12.                                                                                                        |
| 33   | A          | B↔D             | IO    | D20           | Data bit 20.                                                                                                           |
| 34   | B          | B->D            | IO    | A13           | Address bit 13.                                                                                                        |
| 34   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 35   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 35   | A          | B↔D             | IO    | D19           | Data bit 19.                                                                                                           |
| 36   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 36   | A          | B↔D             | IO    | D18           | Data bit 18.                                                                                                           |
| 37   | B          | B->D            | IO    | A14           | Address bit 14.                                                                                                        |
| 37   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 38   | B          | B->D            | IO    | A15           | Address bit 15.                                                                                                        |
| 38   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 39   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 39   | A          | B↔D             | IO    | D17           | Data bit 17.                                                                                                           |
| 40   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 40   | A          | B↔D             | IO    | D16           | Data bit 16.                                                                                                           |
| 41   | B          | B->D            | IO    | A16           | Address bit 16.                                                                                                        |
| 41   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 42   | B          | B->D            | IO    | A17           | Address bit 17.                                                                                                        |
| 42   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 43   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 43   | A          | B↔D             | IO    | D15           | Data bit 15.                                                                                                           |
| 44   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 44   | A          | B↔D             | IO    | D14           | Data bit 14.                                                                                                           |
| 45   | B          | B->D            | IO    | A18           | Address bit 18.                                                                                                        |
| 45   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 46   | B          | B->D            | IO    | A19           | Address bit 19.                                                                                                        |
| 46   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 47   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 47   | A          | B↔D             | IO    | D13           | Data bit 13.                                                                                                           |
| 48   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 48   | A          | B↔D             | IO    | D12           | Data bit 12.                                                                                                           |
| 49   | B          | B->D            | IO    | A20           | Address bit 20.                                                                                                        |
| 49   | A          | B↔D             | IO    | D11           | Data bit 11.                                                                                                           |
| 50   | B          | B->D            | IO    | A21           | Address bit 21.                                                                                                        |
| 50   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 51   | B          | B->D            | IO    | A22           | Address bit 22.                                                                                                        |
| 51   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 52   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 52   | A          | B↔D             | IO    | D10           | Data bit 10.                                                                                                           |
| 53   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 53   | A          | B↔D             | IO    | D9            | Data bit 9.                                                                                                            |
| 54   | B          | B->D            | IO    | A23           | Address bit 23.                                                                                                        |
| 54   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 55   | B          | B->D            | IO    | A24           | Address bit 24.                                                                                                        |
| 55   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 56   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 56   | A          | B↔D             | IO    | D8            | Data bit 8.                                                                                                            |
| 57   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 57   | A          | B↔D             | IO    | D7            | Data bit 7.                                                                                                            |
| 58   | B          | B->D            | IO    | A25           | Address bit 25.                                                                                                        |
| 58   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 59   | B          | B->D            | IO    | A26           | Address bit 26.                                                                                                        |
| 59   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 60   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 60   | A          | B↔D             | IO    | D6            | Data bit 6.                                                                                                            |
| 61   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 61   | A          | B↔D             | IO    | D5            | Data bit 5.                                                                                                            |
| 62   | B          | B->D            | IO    | A27           | Address bit 27.                                                                                                        |
| 62   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 63   | B          | B->D            | IO    | A28           | Address bit 28.                                                                                                        |
| 63   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 64   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 64   | A          | B↔D             | IO    | D4            | Data bit 4.                                                                                                            |
| 65   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 65   | A          | B↔D             | IO    | D3            | Data bit 3.                                                                                                            |
| 66   | B          | B->D            | IO    | A29           | Address bit 29.                                                                                                        |
| 66   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 67   | B          | B->D            | IO    | A30           | Address bit 30.                                                                                                        |
| 67   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 68   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 68   | A          | B↔D             | IO    | D2            | Data bit 2.                                                                                                            |
| 69   | B          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 69   | A          | B↔D             | IO    | D1            | Data bit 1.                                                                                                            |
| 70   | B          | B->D            | IO    | A31           | Address bit 31 (MSB).                                                                                                  |
| 70   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 71   | B          | D→B             | IO    | /DMA_REQ      | Bus-master request from device (active-low). (Reserved/ignored in v1 unless enabled later.) LEAVE NC UNTIL IMPLEMENTED |
| 71   | A          | B->D            | GND   | GND           | Ground.                                                                                                                |
| 72   | B          | B→D             | IO    | GND<br>       | Ground                                                                                                                 |
| 72   | A          | B↔D             | IO    | D0            | Data bit 0 (LSB).                                                                                                      |
| 73   | B          | B->D            | IO    | /DMA_GNT<br>  | Bus-master grant to device (active-low). _(Reserved/ignored in v1 unless enabled later.)_. LEAVE NC UNTIL IMPLEMENTED  |
| 73   | A          | B->D            | IO    | /READY<br>    | Device wait-state indication to backplane (active-low).<br>                                                            |
| 74   | B          | B->D            | IO    | /CPU_ACK      | Host → backplane acknowledge for vectored interrupt/IntAck-mode style cycles (active-low).                             |
| 74   | A          | D->B            | IO    | /RESET        | Global system reset from backplane (active-low).<br>                                                                   |
| 75   | B          | B->D            | IO    | /CPU_INT0<br> | Backplane → Host interrupt input 0.<br>                                                                                |
| 75   | A          | B->D            | IO    | R/W_          | Read/Write direction (1=READ, 0=WRITE).                                                                                |
| 76   | B          | B->D            | IO    | /CPU_INT1     | Backplane → Host interrupt input 1.                                                                                    |
| 76   | A          | B->D            | IO    | /MEM0_CS      | Bit 0 of memory region select.<br>Backplane → Host interrupt input 0.                                                  |
| 77   | B          | B->D            | IO    | /CPU_INT2     | Backplane → Host interrupt input 2.                                                                                    |
| 77   | A          | B->D            | IO    | /MEM1_CS      | Bit 1 of memory region select.                                                                                         |
| 78   | B          | B->D            | IO    | /CPU_INT3     | Backplane → Host interrupt input 3.                                                                                    |
| 78   | A          | D->B            | IO    | /CS           | Per-slot chip select from backplane (active-low).                                                                      |
| 79   | B          | D->B            | IO    | /CPU_NMI0     | Backplane → Host NMI input 0                                                                                           |
| 79   | A          | B->D            | IO    | /INT_ACK      | Interrupt acknowledge from backplane to device (active-low).                                                           |
| 80   | B          | B->D            | IO    | /CPU_NMI1     | Backplane → Host NMI input 1.                                                                                          |
| 80   | A          | D->B            | IO    | /NMI_CH       | Non-maskable interrupt channel from device.                                                                            |
| 81   | B          | D->B            | IO    | /MREQ         | Memory request qualifier (active-low).<br>Maskable interrupt channel 0 from device.                                    |
| 81   | A          | B->D            | IO    | /INT_CH0      | Maskable interrupt channel 0 from device.                                                                              |
| 82   | B          | D->B            | IO    | /IORQ         | I/O cycle qualifier from backplane (active-low).                                                                       |
| 82   | A          | B->D            | IO    | /INT_CH1      | Maskable interrupt channel 1 from device.                                                                              |


---
### 2.2.1 Rails

  #### Power rails overview (normative)

The Parallel Profile reuses the PCIe x16 mechanical connector but simplifies and normalizes the power rails for hobbyist-friendly designs:

* **3.3 V main (`VCC_3V3`)**
  This is the primary logic and local-regulator supply for all Tiles. Every compliant Dock MUST provide `VCC_3V3` to each slot, and every compliant Tile MUST be able to operate solely from this rail (plus ground).

* **5 V auxiliary (`VCC_5V`)**
  Pins formerly used as 12 V in PCIe are repurposed as a **5 V auxiliary rail**. Docks MUST provide 5 V to these pins; Tiles MUST use it for higher-power local converters (e.g., analog audio, backlight, small motors).

* **No 12 V rail**
  The Parallel Profile v1.x does **not** define a 12 V rail on the connector. Any higher-voltage requirements must be satisfied by on-Tile conversion from 3.3 V or optional 5 V.

For each implemented rail, the Dock specification MUST state:

* The **per-slot** current budget and the maximum total current across all populated slots.
* Any sequencing constraints between `VCC_3V3`, and `VCC_5V` (for example: “3.3 V stable before 5 V is enabled”).

Tiles MUST respect these limits and design their inrush and bulk capacitance so that worst-case hot-seat insertion into an unpowered backplane does not exceed connector ratings. Full live hot-plug is not required or guaranteed by the profile.

---

### 2.2.1.1 Voltage Compatibility Sense Pins (Normative)

To support both **5 V logic** and **3.3 V logic** systems without jumpers or configuration, each slot provides two **strap-style sense pins** that are evaluated by the Dock/backplane **before enabling slot power rails**.

These pins are **not power pins** and MUST NOT be used to source power to devices.

### Voltage Compatibility Sense Pins (Normative)

Pin allocation (see §2.2 Pin Map):
- Pin 1 (B side): /DRV5V
- Pin 82 (B side): /SENS3V

To support both **5 V logic** and **3.3 V logic** systems...
#### Signals and Electrical Requirements

Per slot:

- **/DRV5V** (SENSE, D→B): declares whether the device may drive **5 V logic levels** onto any shared bus/control signal.
- **/SENS3V** (SENSE, D→B): declares whether the device is **3.3 V-only** (i.e., **not 5 V tolerant** on its inputs).

Electrical rules:

- The Dock/backplane MUST provide a **weak pull-up** (typ. **10 kΩ**) to an **always-on 3.3 V domain** for each sense pin.
- Devices MUST implement these pins using **passive strapping** only:
  - **Assert (logic 0):** tie to **GND**
  - **Deassert (logic 1):** leave **NC/floating**
- Devices MUST NOT connect these pins to any VCC rail.
- Because slots are unpowered during detection, compliance MUST NOT rely on device power being present.

Semantics (active-low):

- **`/DRV5V` = 0:** device **may drive 5 V** on at least one shared bus/control signal in any operating mode
- **`/DRV5V` = 1:** device will **not** drive 5 V (outputs are 3.3 V or open-drain only)
- **`/SENS3V` = 0:** device is **3.3 V-only** (inputs are not 5 V tolerant)
- **`/SENS3V` = 1:** device inputs are **5 V tolerant**

The Dock/backplane MUST:
1. Evaluate `/DRV5V` and `/SENS3V` from all slots during **power-on sequence** 
   (before enabling VCC_3V3_MAIN / VCC_5V_MAIN)
2. Re-evaluate if implementing **hot-plug detection** (out of scope for v1.0)
3. Keep slot power disabled when `COMPATIBLE = 0`

#### Recommended Strapping by Device Class

| Device class | /DRV5V | /SENS3V | Meaning |
|---|---:|---:|---|
| **Pure 5 V device** (drives 5 V, tolerates 5 V) | 0 | 1 | May drive 5 V; safe in 5 V systems only |
| **Pure 3.3 V device** (drives 3.3 V, not 5 V tolerant) | 1 | 0 | 3.3-only; must not be used with any 5 V drivers |
| **Universal device** (drives 3.3 V, 5 V tolerant inputs) | 1 | 1 | Safe in 3.3 V, 5 V, and mixed systems |
| **Empty / not installed** | 1 | 1 | Treated as universal by default |

Note: With Dock pull-ups, an unpopulated slot reads **(1,1)** and is therefore safe to ignore without an explicit occupancy pin.

#### Truth Table

| Any 5V Driver? | Any 3.3V-only? | COMPATIBLE | Result |
|:---:|:---:|:---:|---|
| 0 | 0 | ✓ | All devices are universal (3.3V drive, 5V tolerant) |
| 0 | 1 | ✓ | Pure 3.3V system (no 5V drivers present) |
| 1 | 0 | ✓ | Pure 5V system (all devices are 5V tolerant) |
| 1 | 1 | ✗ | **FAULT**: 5V driver would damage 3.3V-only device |

The Dock MUST keep slot power disabled for the FAULT case.

#### Compatibility Rule (Normative)

Define:

- `DRV5V_ANY = OR_n( NOT /DRV5V[n] )`  (true if any slot may drive 5 V)
- `SENS3V_ANY = OR_n( NOT /SENS3V[n] )` (true if any slot is 3.3-only)

Then:

- `COMPATIBLE = NOT( DRV5V_ANY AND SENS3V_ANY )`

In plain English:

- If **any** device may drive **5 V**, then **no** device may be **3.3-only**.
- Otherwise the system is compatible.

The Dock/backplane MUST gate slot power enable such that **main slot rails remain disabled** when `COMPATIBLE = 0`.

#### Optional: Backplane-Control Signal Drive Level

To ensure robust logic-high thresholds for 5 V CMOS devices, the Dock/backplane MAY level-shift and drive **backplane-originated control outputs** at:

- **5 V levels** when `DRV5V_ANY = 1` and `SENS3V_ANY = 0` (i.e., “5 V bus allowed”)
- **3.3 V levels** when `DRV5V_ANY = 0` (i.e., “3.3 V bus only”)

This applies to control outputs such as `/CS`, `/RESET`, `/INT_ACK`, etc.

Address/data bus voltage remains **emergent** from installed devices and is not required to be driven by the Dock.

#### Optional: Backplane-Control Signal Drive Level

To ensure robust logic-high thresholds for 5 V CMOS devices, the Dock/backplane MAY 
adapt backplane-originated control outputs (e.g., /CS, /RESET, /INT_ACK) to match 
the system voltage:

**Recommended implementation:**
- Drive control outputs as **open-drain** with selectable pull-up voltage:
  - Pull up to **VCC_5V_MAIN** when `DRV5V_ANY = 1` and `SENS3V_ANY = 0`
  - Pull up to **VCC_3V3_MAIN** when `DRV5V_ANY = 0`
  
**Alternative implementation:**
- Use **active level-shifters** if faster edge rates are required.

**Not applicable to:**
- Address/data bus (driven push-pull by devices, not Dock)
- Open-drain interrupt lines (pulled up per Core spec requirements)

The Dock MUST guarantee stable pull-up voltage selection BEFORE releasing slot 
power enables.

#### Trust Model (Builder Responsibility)

This mechanism relies on correct device strapping. Incorrect strapping can produce unsafe combinations that hardware cannot detect. Device designers are responsible for validating:
- actual output high levels under load
- actual 5 V tolerance of inputs when claimed


---

#### Relation to Core logical signal set

The PCIe x16 pin map in this section is a **physical instantiation** of the Core logical signal set defined in Part 1 (Core Logical Specification). In particular:

* `/IORQ` on the connector corresponds directly to the Core **I/O cycle qualifier** signal used to delimit I/O transactions.
* `R/W_` corresponds to the Core **read/write direction** signal (`1=READ`, `0=WRITE`), used by both Dock and Tiles to distinguish read vs write cycles.
* `A[31:0]` corresponds to the Core **I/O address bus**, with the effective width given by `AddressBusWidth` in the CPU Descriptor.
* `D[31:0]` corresponds to the Core **I/O data bus**, with the effective width given by `DataBusWidth` in the CPU Descriptor. On the Parallel Profile this is exposed as a true 32-bit, bidirectional parallel bus.
* `/READY` is the Core **wait-state / ready** signal, aggregated on the Dock and sourced by the selected Tile to stretch I/O cycles.
* `/CS` is the per-slot **chip-select** derived from the Core `WindowMap[]` decode of `(IOWin, IOMask, OpSel)` on `A[7:0]`. Only the selected slot’s `/CS` is asserted for a given I/O cycle.
* `/INT_CH0`, `/INT_CH1`, and `/NMI_CH` are the per-slot **interrupt channels** defined by Core, feeding into the Core `IntRouting[]` matrix and then on to `/CPU_INT[x]` and `/CPU_NMI[y]` at the Host.
* `/INT_ACK` and the CPU-side `/CPU_ACK` together implement the Core **vectored acknowledge** mechanism when `IntAckMode = 0x01` (Mode-2 style).
* `SLOT_SCL` and `SLOT_SDA` carry the Core **enumeration/control bus** (I²C in the reference design), used to read each Tile’s Device Descriptor and to populate `WindowMap[]` and `IntRouting[]`.

As a result, a Parallel-profile Dock or Tile designer can treat the signal table in §2.2 as a **direct physical mapping** of the logical interface described in Part 1:

* If a signal appears in the Core logical model, it has a unique, named location in the PCIe x16 table.
* If a PCIe pin is marked `NC` in the table, it is **outside** the μBITz standard for v1.x and MUST NOT be driven or interpreted by generic Dock/Tile designs.

This guarantees that any correctly implemented Parallel Dock + Tiles pair is logically interchangeable with other μBITz profiles (Minimal) as long as the Core contracts (enumeration, windows, interrupts) are respected.


### 2.2.2 Bus exposure

**Parallel bus exposure (backplane side):**

* `A[31:0]` – address bus, driven by the CPU card / host interface.
* `D[31:0]` – data bus, bidirectional, little-endian byte lanes.
* `/IORQ` – active-low I/O cycle qualifier from the CPU.
* `R/W_` – read/write select (`1=READ`, `0=WRITE`), active-low write.
* `/READY` – active-low wait-state signal from devices via the backplane to CPU.
* `/RESET` – synchronous reset, backplane→devices and backplane→CPU (per Core).

**Per-slot interrupt and ack (backplane side):**

* `/INT_CH[1:0]` – per-slot maskable interrupt request lines, device→backplane.
* `/NMI_CH` – per-slot non-maskable interrupt request line, device→backplane.
* `/INT_ACK` – per-slot active-low interrupt acknowledge from backplane to
  device (during Mode-2 cycles or profile-defined ack phases).

**CPU-facing interrupt signals:**

* `/CPU_INT[3:0]` – maskable interrupt outputs from backplane to CPU.
* `/CPU_NMI[1:0]` – non-maskable interrupt outputs from backplane to CPU.
* `/CPU_ACK` – active-low interrupt acknowledge from CPU to backplane.

**Enumeration bus:**

* I²C or another platform-defined control bus, as described in Part 1 and the
  Host/Backplane specs. This profile does not constrain exact pins, only that
  enumeration is available on every slot.

> Note: The **connector** is always wired for `A[31:0]`/`D[31:0]`. If the CPU
> descriptor declares narrower widths (e.g. 8- or 16-bit), higher-order lanes
> MUST be treated as **unused** and MUST NOT carry additional signals.

### 2.2.3 Clock Distribution

The Parallel Profile provides optional reference clock distribution to support timing-sensitive Tiles and coordination between Host, Bank, and peripheral devices.

**Clock Signals (normative):**

The connector provides five reference clock signals:

- **CLK_HOST** (B→D) – Reference clock sourced from the Host board, passed through the Dock to all Tiles and the Bank.
    - Pin 7 (B side)
    - The Host generates this clock based on its platform requirements (e.g., CPU clock, pixel clock derivative, or other platform-specific timing).
    - The Dock **MUST** buffer and distribute CLK_HOST to all Tile slots and to the Bank connector with minimal skew.
- **CLK_DOCK[0:3]** (B→D) – Four independent reference clocks sourced from the Dock, distributed to all Tiles, Host, and Bank.
    - CLK_DOCK0: Pin 8 (B side)
    - CLK_DOCK1: Pin 12 (A side)
    - CLK_DOCK2: Pin 13 (B side)
    - CLK_DOCK3: Pin 14 (B side)
    - The Dock generates these clocks based on its implementation (e.g., crystal oscillator, PLL, or derived from external sources).

**Electrical Requirements (normative):**

- All clock signals are **3.3V CMOS** single-ended outputs.
- Clock sources (Host or Dock) **MUST** provide sufficient drive strength to support up to 6 loads: 4 Tiles + 1 Host + 1 Bank.
- Recommended output: **CMOS with series termination** (22-33Ω) or **buffered CMOS output** capable of driving 50pF total load.
- Clock receivers (Tiles, Host, Bank) **SHOULD** present high-impedance inputs (>100kΩ, <10pF per input).
- Dock implementations **SHOULD** use clock buffers (e.g., 74LVC1G125 or equivalent) to minimize skew and loading effects.

**Timing and Skew (normative):**

- Clock skew between any two Tile slots **MUST** be ≤2ns for frequencies ≤50 MHz.
- For higher frequencies, Dock designers **SHOULD** use matched-length routing and dedicated clock distribution buffers.
- Maximum recommended clock frequency: **100 MHz** (limited by connector parasitics and trace routing).

**Usage Requirements (normative):**

- All clock signals are **optional**:
    - A Dock **MAY** leave any or all clock outputs undriven (high-impedance or tied low).
    - A Tile, Host, or Bank **MAY** ignore any or all clock inputs.
    - A compliant Tile/Host/Bank **MUST** operate correctly with all clock inputs unconnected.
- When a clock is driven, it **MUST** be:
    - Stable and free-running (not gated by device activity).
    - Clean and monotonic (no mid-level transitions or glitches).
    - Documented in frequency and duty cycle in the Dock/Host descriptor or implementation notes.

**Typical Use Cases (informative):**

- **CLK_HOST examples:**
    - CPU clock reference for cycle-accurate peripherals
    - Platform-specific timing (e.g., 14.31818 MHz for NTSC systems, 3.5 MHz for ZX Spectrum)
    - Pixel clock derivative for synchronized video output
- **CLK_DOCK[0:3] examples:**
    - CLK_DOCK0: System reference for multi-Tile synchronization (e.g., 50/60 Hz frame sync)
    - CLK_DOCK1: Audio reference (e.g., 44.1 kHz × 256 = 11.2896 MHz)
    - CLK_DOCK2: Network or serial interface reference
    - CLK_DOCK3: USB PHY clock or other peripheral timing

**Design Guidelines (informative):**

- Docks **SHOULD** provide at least one clock output (either CLK_HOST pass-through or one CLK_DOCK) for maximum Tile compatibility.
- Tiles requiring synchronized operation **SHOULD** use CLK_DOCK0 as the primary coordination clock.
- Hosts generating CLK_HOST **SHOULD** derive it from their primary system oscillator rather than generating a new frequency.
- For low-jitter applications (audio, video), use dedicated crystal oscillators rather than PLL-derived clocks.

---

## 2.3 Signal mapping to Core logical set

The Parallel Profile implements the Core’s logical signal set directly as
parallel, single-ended pins (no framing or serialization).

**CPU↔Backplane (C⇄B / C→B / B→C):**

* `/IORQ` (C→B) – CPU asserts low to qualify I/O cycles.
* `R/W_` (C→B) – CPU read/write direction.
* `A[AddressBusWidth-1:0]` (C→B) – CPU I/O address.
* `D[DataBusWidth-1:0]` (C⇄B) – bidirectional data bus.
* `/READY` (B→C) – backplane stretches CPU cycles while low.
* `/RESET` (B→C) – backplane/host reset distribution.
* `/CPU_INT[3:0]` (B→C) – routed maskable interrupt lines to CPU.
* `/CPU_NMI[1:0]` (B→C) – routed NMI lines to CPU.
* `/CPU_ACK` (C→B) – CPU interrupt acknowledge (Mode-2-style when enabled).

**Backplane↔Device (B⇄D / B→D / D→B):**

* `/CS[Slot#-1:0]` (B→D) – per-slot device select; one-hot during normal I/O.
* `R/W_` (B→D) – forwarded read/write direction from CPU.
* `A[AddressBusWidth-1:0]` (B→D) – forwarded address, unchanged.
* `D[DataBusWidth-1:0]` (B⇄D) – data bus as seen by devices.
* `/READY` (D→B) – device wait-state indication to backplane.
* `/INT_CH[1:0]` (D→B) – per-slot maskable interrupt channels.
* `/NMI_CH` (D→B) – per-slot NMI channel.
* `/INT_ACK` (B→D) – per-slot interrupt acknowledge during Mode-2.

The backplane MAY implement additional debugging or sideband signals, but they
MUST NOT alter the logical semantics above.

### 2.3.1 Bus ownership and tri-stating (normative)

To avoid bus contention:

* `A[]`, `/IORQ`, `R/W_`, `/RESET`, `/CPU_INT[]`, `/CPU_NMI[]`, `/CPU_ACK`,
  and `/CS[]` are always **driven by exactly one source** (CPU or backplane),
  and devices MUST treat them as **inputs** only.
* `D[]` is **shared**:

  * On **WRITE** cycles (`R/W_ = 0`):

    * The CPU/backplane side drives `D[DataBusWidth-1:0]` for the entire period
      where `/IORQ=0` and `/READY=0`.
    * Devices MUST treat `D[]` as input-only and MUST NOT drive it.
  * On **READ** cycles (`R/W_ = 1`):

    * The CPU/backplane MUST tri-state its drivers on `D[]` before asserting
      `/IORQ`.
    * Only the selected slot (its `/CS` asserted) MAY drive `D[]`, and only while
      `/IORQ=0` and `/READY=0`.
* When no I/O transaction is active (`/IORQ=1`), both CPU/backplane and devices
  MUST tri-state `D[]`.

For `/READY`:

* CPU sees a **single** `/READY` line.
* Only the addressed slot MAY actively drive its `(D→B)` `/READY` contribution
  (low to stretch the cycle). All other slots MUST present a high-Z / idle
  level to the backplane’s `/READY` aggregator.

---

## 2.4 Transaction semantics and timing

The Parallel Profile exposes a **single-cycle, synchronous parallel bus**. The
CPU owns all bus timing (as per the platform’s CPU board); the backplane and
devices MUST conform to the CPU board’s published timing diagrams.

**Normative properties:**

* **Cycle qualification:**

  * `/IORQ=0` and a valid `A[]`/`R/W_` define a single I/O transaction.
  * Non-I/O cycles (`/IORQ=1`) MUST be ignored by the Dock backplane.
* **Slot selection:**

  * The backplane decodes `(IOWin, IOMask, OpSel)` from `A[7:0]` as described
    in Core and asserts **exactly one** `/CS[slot]` low during the data phase
    of a mapped I/O cycle (or no `/CS` for unmapped cycles).
  * The full address is forwarded to the selected slot.
* **/READY handling:**

  * During an I/O cycle, the backplane drives CPU-visible `/READY` as the
    **logical AND** of slot-local `/READY` responses and any internal gating
    (but only the selected slot MUST actively drive its contribution).
  * Devices MAY hold slot-local `/READY` low to stretch the cycle, but the
    backplane MUST enforce the Host-declared `ReadyMaxuS` budget and MUST
    apply timeout completion (per Core/Platform) if exceeded.
* **Atomic multi-byte operations:**

  * When the CPU board issues 16- or 32-bit I/O operations, devices MUST treat
    them as atomic, consistent with Core rules. The backplane MUST not break or
    reorder the byte lanes.
* **Unmapped windows:**

  * If no `WindowMap` entry matches an I/O cycle, the backplane MUST NOT assert
    any `/CS`. Reads return all-ones (0xFF per byte) and writes are ignored,
    following platform/Core policy.

Timing diagrams and absolute setup/hold requirements are defined by the CPU
board and backplane implementation; this Part only constrains **relative**
semantics (which signal means what, and how they interact).

### 2.4.1 Example WRITE cycle (informative)

A typical 8- or 16-bit CPU write on a Parallel backplane proceeds as:

1. CPU places `ADDR` on `A[]`, data on `D[]`, and `R/W_ = 0`.
2. CPU asserts `/IORQ=0`.
3. Backplane immediately pulls CPU-visible `/READY=0` to claim the cycle.
4. Backplane:

   * Decodes `(IOWin, IOMask, OpSel)` from `A[7:0]`.
   * Asserts `/CS[slot]` to the selected slot (if any) once decode is stable.
5. Device in that slot:

   * Sees `/CS=0`, `R/W_ = 0`, and `A[]` stable.
   * If ready immediately, leaves `/READY` high.
   * If not ready, asserts `/READY=0` until internal state is ready to accept
     the write.
6. When `/READY` is high again at the CPU:

   * CPU deasserts `/IORQ` and proceeds to the next cycle.
   * Device latches data per its own internal timing (within the Core rules).

The CPU board MUST guarantee that `A[]` and `D[]` are valid and stable for the
entire window in which the device samples them (platform-specific).

### 2.4.2 Example READ cycle (informative)

A typical read on a Parallel backplane:

1. CPU places `ADDR` on `A[]`, sets `R/W_ = 1`, and tri-states its `D[]`
   drivers.
2. CPU asserts `/IORQ=0`.
3. Backplane:

   * Decodes `(IOWin, IOMask, OpSel)` from `A[7:0]`.
   * Asserts `/CS[slot]` to the selected slot (if any).
4. Device in that slot:

   * Sees `/CS=0`, `R/W_ = 1`, and `A[]` stable.
   * Drives `D[]` with the requested data when ready.
   * Holds `/READY=0` until its output data is stable.
5. When the device is ready, it releases `/READY` to 1 while still driving
   valid data on `D[]`.
6. CPU samples `D[]`, then deasserts `/IORQ`.

Devices MUST NOT drive `D[]` outside the window where `/CS=0` and `R/W_=1` and
`/IORQ=0`.

---

## 2.5 Interrupt handling

Interrupt semantics follow Core and the Dock specification; this section
summarizes how they appear on a parallel bus.

### 2.5.1 Per-slot lines and routing

**Per-slot interrupt wiring (device→backplane):**

* Each slot exposes:

  * `INT_CH[1:0]` – up to 2 maskable interrupt channels.
  * `NMI_CH` – up to 1 non-maskable interrupt channel.
* Lines are level-sensitive as per Core. Devices MUST tri-state/idle them
  appropriately when unused.

**Backplane routing (backplane→CPU):**

* The backplane consults `IntRouting[]` (from the CPU descriptor) and the
  current slot population to map `(Function, Instance, Channel)` to
  `/CPU_INT[x]` or `/CPU_NMI[y]`.
* Only one interrupt may be active at the CPU at a time, per Core’s
  serialization rules. Additional requests remain asserted at the slot but are
  blocked at the backplane until the active source clears.
  (Slots themselves are free to have multiple pending causes in their
  **status registers**; Core only serializes what is presented to the CPU pins.)

### 2.5.2 Mode-2 acknowledge over Parallel

When `IntAckMode = 0x01` (Mode-2-style) in the CPU descriptor, ack cycles are
mapped as follows:

1. The CPU performs a Mode-2 acknowledge cycle, asserting `/CPU_ACK` and
   performing a vector read per its own bus protocol.
2. The backplane:

   * Determines the **active slot/channel** from `INT_CH[1:0]` and `IntRouting`.
   * Routes `/INT_ACK` to that slot (and only that slot) for the duration of
     the acknowledge.
3. The device:

   * During `/INT_ACK` assertion, treats a read at its designated vector
     endpoint (typically `ADDR=0x00` within its window) as a **Vector Register**
     read and returns an 8-bit vector index on `D[7:0]`.
   * Outside of ack cycles, `ADDR=0x00` is a normal device register.
4. The backplane forwards this 8-bit vector value directly on the CPU data bus
   during the acknowledge cycle.

**Multiple claimants:**

* If more than one slot claims the same channel when the CPU acknowledges,
  the backplane MUST present `0xFF` to the CPU and MUST NOT assert `/INT_ACK`
  to any single slot.

**Clearing interrupts:**

* `irq_ack`-equivalent behavior in the Parallel Profile is embodied by
  `/INT_ACK` and `/CPU_ACK`. Devices MUST NOT clear interrupts solely on
  `/INT_ACK`; instead they clear when the device-specific clear sequence
  completes (per Core’s interrupt clear semantics).

### 2.5.3 IntAckMode = None (polling)

When `IntAckMode = 0x00` (no special ack cycle) in the CPU descriptor:

* The CPU MUST NOT use `/CPU_ACK` for normal interrupt processing.
* The backplane MUST ignore `/CPU_ACK` and MUST NOT assert `/INT_ACK` in
  response to CPU behavior.
* Devices MUST treat `/INT_ACK` as inactive in this mode and rely on their
  documented register-based status/clear mechanism.
* `IntRouting[]` is still used to present **which channel** reaches which
  `/CPU_INT[]` or `/CPU_NMI[]` pin, but interrupt source identification is done
  in software (polling or status register reads).

This ensures the same physical backplane can support both **polling-only**
CPUs and CPUs with true Mode-2-style vectored ack.

---

## 2.6 Widths and slot count

**Connector and backplane:**

* The Parallel Profile connector always exposes **32 address bits** and
  **32 data bits**.
* Slot count is 1–4; implementations MAY reserve additional positions for
  internal services (e.g. an internal Dock Tile or management MCU) that are
  not exposed as user slots.

**CPU descriptor interaction:**

* `AddressBusWidth` and `DataBusWidth` in the CPU descriptor declare how many
  of the `A[]` and `D[]` lanes are valid.
* Backplanes MUST:

  * Connect only the lower `AddressBusWidth` and `DataBusWidth` lanes to the
    CPU board.
  * Treat unused lanes as reserved; they MUST NOT carry unrelated signals.
* Devices MUST:

  * Respect the announced widths; accesses beyond the declared `DataBusWidth`
    or `AddressBusWidth` are undefined.
  * Ignore the state of unused high-order lanes; they may be left floating or
    tied off internally by the backplane, but MUST NOT be interpreted as
    additional address bits or sideband flags.

---

## 2.7 Compliance checklist — Device (Parallel)

A conformant Parallel-profile **device** MUST:

* Connect to `A[AddressBusWidth-1:0]`, `D[DataBusWidth-1:0]`, `/CS`, `R/W_`,
  `/READY`, `/RESET`, `INT_CH[1:0]`, `NMI_CH`, and `/INT_ACK` as specified.
* Implement register maps, windowing, and OpSel behavior as defined in Core and
  reflected in the CPU’s `WindowMap[]`.
* Implement interrupt behavior per Core:

  * Assert `INT_CH[k]`/`NMI_CH` based on internal status.
  * Provide an 8-bit Vector Register at the designated endpoint for Mode-2 and
    drive the vector index on `D[7:0]` while `/INT_ACK` is active.
  * Clear interrupts only after the documented clear sequence; not merely on
    `/INT_ACK`.
* Observe the platform’s electrical limits (drive strength, timing) on the
  shared data and control buses.
* Participate in enumeration on the platform’s enumeration bus with a valid
  Device Descriptor (per Core), including:

  * Correct Function IDs and Instances.
  * Correct declaration of supported interrupt channels.

Devices MAY:

* Leave unused interrupt channels unconnected.
* Implement additional, device-specific sideband signals via reserved pins,
  provided they do not conflict with the required logical set.
* Share a physical PCB design across profiles (Parallel, Minimal) by
  placing profile-specific front-ends in different BOM variants, so long as the
  Core behavior and device descriptors remain consistent.

---

## 2.8 Compliance checklist — Backplane (Parallel)

A conformant Parallel-profile **backplane** MUST:

* Expose `A[31:0]`, `D[31:0]`, `/IORQ`, `R/W_`, `/READY`, `/RESET`,
  `/INT_CH[1:0]`, `/NMI_CH`, `/INT_ACK`, `/CPU_INT[3:0]`, `/CPU_NMI[1:0]`,
  and `/CPU_ACK` per this Part and Core.
* Implement Core decode:

  * Decode `(IOWin, IOMask, OpSel)` from `A[7:0]`.
  * Assert exactly one `/CS[slot]` during mapped I/O cycles.
  * Forward the full CPU address and appropriate control lines to the selected
    slot.
* Implement `/READY` handling:

  * Reflect device `/READY` to the CPU, enforcing that only the selected slot
    contributes to the aggregated `/READY`.
  * Provide any platform-required watchdog or timeout behavior (e.g. failing
    a stuck-low `/READY`).
* Implement interrupt routing as per `IntRouting[]`:

  * Serialize multiple pending interrupts so only one is presented to the CPU.
  * Maintain a record of the **active source** (slot + channel) for ack routing.
  * Route `/CPU_ACK` to the correct slot via `/INT_ACK` (Mode-2).
  * Provide the `0xFF` fallback vector when multiple claimants or no claimant
    exist for a Mode-2 ack.
* Maintain electrical integrity:

  * Provide appropriate terminations, pull-ups, and filtering for interrupt and
    control lines.
  * Ensure trace lengths, loading, and connector selection meet the timing and
    SI requirements for the intended clock rate.

Backplanes MAY:

* Support fewer than 4 slots, but MUST advertise this accurately via
  descriptors.
* Provide per-slot power gating, hot-plug detection, or other conveniences
  provided they do not alter the logical contract.
* Integrate a “Dock services” Tile on an internal slot (LEDs, debug UART,
  fan control, etc.) that is not mechanically exposed.

---

## 2.9 Timing (informative)

Parallel-profile timing is dominated by the CPU’s I/O bus timing and device
response times. There is no serial pipeline; the backplane adds only routing
and buffering delay.

Builders are encouraged to:

* Target backplane/controller clocks in the **25–50 MHz** range when possible
  for mainstream hobbyist PCBs; slower clocks are acceptable for simpler
  layouts.
* Keep trace lengths and loading within typical PCIe x16 mechanical
  recommendations (solid reference planes, controlled impedance) though
  the signals are not PCIe protocol signals.
* Clearly specify in Host/Backplane documentation:

  * Maximum supported `AddressBusWidth` and `DataBusWidth`.
  * Maximum I/O clock rate.
  * Any additional skew or propagation constraints between `A[]`, `D[]`,
    `/IORQ`, and `/READY`.

Parallel-profile devices that internally run at much higher clocks (e.g., video
Tiles) SHOULD use internal FIFOs or buffering to present a **stable, slow**
register interface to the CPU, rather than exposing deep timing coupling
between real-time pipelines and I/O access timing.

---

## 2.10 Reserved values & future-proofing

* Higher `DataBusWidth` / `AddressBusWidth` values (>32) are reserved for
  future revisions.
* Additional interrupt channels per slot are reserved; v1.x mandates at most
  `INT_CH[1:0]` and one `NMI_CH`.
* Additional CPU interrupt pins (`/CPU_INT[>3]`, `/CPU_NMI[>1]`) are reserved.

Future revisions MAY:

* Extend the number of interrupts, bus widths, or slots.
* Introduce profile-specific sideband signals.
* Define “wide Parallel” connectors mechanically distinct from PCIe x16 while
  maintaining the same logical contract.

All such extensions MUST remain backward compatible with correctly implemented
v1.x devices and backplanes.

---
## Appendix C — Conformance Matrix (informative)

### C.1 Device (Parallel Profile)

| ID   | Requirement (summary)                                                                                                                                                        | Spec §               | How to verify                                                                                                                                                                      |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| D-1  | Powers all mandatory logic (enumeration + register bank) from **VCC_3V3**; may use **VCC_3V3_STBY** and optional **VCC_5V**, but must not *require* 5 V for basic operation. | 2.2, 2.7             | Power a slot with 3.3 V (and 3.3 V standby if used), leave 5 V off. Run Host self-test that enumerates the Tile and does basic register reads; confirm it works without 5 V.       |
| D-2  | Uses only the rails and pins defined in the Parallel pin map; all pins marked **NC** in §2.2 remain unbonded/undriven on the Tile.                                           | 2.2, 2.7             | Schematic/layout review: NC pads not routed. Continuity test NC pins on a bare board or assembled Tile; confirm open-circuit to all nets and supplies.                             |
| D-3  | Connects to `A[AddressBusWidth-1:0]` and ignores higher-order address pins; behavior is defined only up to declared `AddressBusWidth`.                                       | 2.3, 2.6, 2.7        | With test firmware, sweep addresses where only high bits differ (e.g. `0x0000` vs `0x8000` for 15-bit width). Use LA to confirm Tile only responds within the defined range.       |
| D-4  | Connects to `D[DataBusWidth-1:0]` and **never** drives higher-order data pins; high lanes must remain idle/high-Z from the device.                                           | 2.3, 2.2.1, 2.6, 2.7 | On a Host with 32-bit bus, perform READ cycles while monitoring all `D[31:0]` with an LA. Confirm only low `DataBusWidth` bits toggle; upper bits stay at pull level.              |
| D-5  | Obeys bus ownership: drives `D[]` only on READ cycles while `R/W_ = 1`, `/IORQ = 0` and its `/CS = 0`; never drives `D[]` on WRITE cycles.                                   | 2.2.1, 2.4, 2.7      | Connect Tile and a “bus sniffer” card or LA. Run Host test that randomly mixes reads and writes. Check that Tile’s output-enable on D matches only the legal READ windows.         |
| D-6  | Drives `/READY` only when selected (`/CS = 0`); must not pull `/READY` low when not addressed.                                                                               | 2.3.1, 2.4, 2.7      | Install two Tiles; have firmware repeatedly access only Tile A. With LA on `/CS`, `/READY`, confirm only A’s accesses cause wait-states. Tile B should never affect `/READY`.      |
| D-7  | Implements Core register map semantics under `WindowMap[]` and `OpSel`; responds only in its configured windows and ignores unmapped addresses.                              | 2.1, 2.4, 2.7        | After enumeration, have Host self-test program Tile windows and probe within/outside these ranges. Verify via LA that device only asserts `/READY` and drives `D[]` in-range.      |
| D-8  | Treats multi-byte (16/32-bit) I/O operations as **atomic**, with little-endian byte ordering on `D[]`.                                                                       | 2.4, 2.6, 2.7        | Use firmware to write 16/32-bit patterns (e.g. `0x1234`, `0x89ABCDEF`) and immediately read back. LA should show low byte on `D[7:0]`, contiguous bytes on higher lanes.           |
| D-9  | Exposes per-slot interrupt lines `INT_CH[1:0]` and `NMI_CH` with electrical behavior per Core (open-drain/level as required by platform).                                    | 2.2, 2.5, 2.7        | With scope/LA and known pull-ups on Dock, toggle device interrupt bits in firmware. Verify correct idle level, active level, and that lines can be wire-OR’d safely.               |
| D-10 | If vectored interrupts (`IntAckMode = 0x01`) are supported, provides an 8-bit **Vector Register** and returns the vector on `D[7:0]` while `/INT_ACK` is asserted.           | 2.5.2, 2.7           | Configure CPU descriptor for Mode-2. Trigger device INT, then have Host issue an ack cycle. Capture `/INT_ACK`, `A[]`, `D[7:0]` with LA; confirm expected vector byte is observed. |
| D-11 | When `IntAckMode = 0x00` (polling mode), ignores `/INT_ACK` and does not change any internal state in response to it.                                                        | 2.5.3, 2.7           | Configure Host for polling mode and still pulse `/CPU_ACK`. Verify via device status registers and LA that `/INT_CHx` behavior is unchanged by the ack pulse.                      |
| D-12 | Participates in enumeration via `SLOT_SCL`/`SLOT_SDA` and exposes a valid Device Descriptor (Function IDs, widths, interrupts, etc.).                                        | 2.2, 2.6, 2.7        | Use a simple I²C dump tool on the Host side. Read the Tile’s descriptor and check fields match the hardware (bus widths, IRQ channels, function type).                             |
| D-13 | Meets platform timing for setup/hold relative to `/IORQ`, `R/W_`, `A[]`, `D[]`, and `/READY` at the target bus frequency.                                                    | 2.4, 2.9, 2.7        | With scope/LA at max rated bus clock, run stress test (random read/write patterns). Measure setup/hold on signals at the slot; confirm margins meet Host timing diagrams.          |

---

### C.2 Backplane (Parallel Profile)

| ID   | Requirement (summary)                                                                                                                                                           | Spec §          | How to verify                                                                                                                                                                             |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| B-1  | Provides **VCC_3V3** to every slot; may provide **VCC_3V3_STBY** and optional **VCC_5V**. Respects documented per-slot and total current limits.                                | 2.2, 2.8, 2.9   | Connect programmable loads or Tiles with known consumption. Measure slot voltages and currents under worst-case population; confirm they remain within spec and no rail droop or reset.   |
| B-2  | Implements the Parallel pin map exactly; all pins marked **NC** in §2.2 are unconnected.                                                                                        | 2.2, 2.8        | Schematic/layout review of the backplane connector. Use continuity tests from connector fingers to the PCB; NC pads should not connect to any net, plane, or test point.                  |
| B-3  | Exposes `A[31:0]`, `D[31:0]`, `/IORQ`, `R/W_`, `/READY`, `/RESET`, `/CS[slot]`, `INT_CH[1:0]`, `NMI_CH`, `/INT_ACK`, `/CPU_INT[3:0]`, `/CPU_NMI[1:0]`, `/CPU_ACK` as specified. | 2.2, 2.3, 2.8   | With no Tiles or with a passive “breakout” Tile, probe slot pins while Host exercises basic cycles. Confirm presence, direction, and idle levels for all required signals.                |
| B-4  | Decodes `(IOWin, IOMask, OpSel)` from `A[7:0]` and asserts **exactly one** `/CS[slot]` (or none) for each mapped I/O cycle.                                                     | 2.1, 2.4, 2.8   | Plug in multiple Tiles or LED test cards. Run firmware that sweeps addresses. With LA, check that at most one `/CS[x]` is low for any `/IORQ` and that unmapped ranges assert none.       |
| B-5  | Forwards the **full CPU address** and `R/W_` to the selected slot unchanged.                                                                                                    | 2.1, 2.3, 2.4   | Use a Tile that can latch and expose the last address seen (e.g., via debug register). Compare CPU address vs. Tile’s latched value for a variety of accesses; they should match exactly. |
| B-6  | Aggregates `/READY` so only the **selected** slot can stretch the CPU cycle; non-selected Tiles must not affect CPU-visible `/READY`.                                           | 2.2.1, 2.4, 2.8 | Install two Tiles; have Tile A hold `/READY` low for a programmable time on access. Use LA to confirm CPU `/READY` tracks only Tile A accesses and is unaffected by Tile B behavior.      |
| B-7  | For unmapped windows, does not assert any `/CS`; CPU reads return all-ones (`0xFF`, `0xFFFF`, or `0xFFFFFFFF` depending on data width).                                         | 2.4, 2.6, 2.8   | With at least one Tile present, perform reads to clearly unmapped addresses. Confirm via LA that no `/CS` toggles and Host firmware sees all-ones patterns.                               |
| B-8  | Preserves atomicity of 16/32-bit I/O operations; must not reorder byte lanes or split wide accesses into visible partial writes to the Tile.                                    | 2.4, 2.6, 2.8   | Attach a Tile that exposes internal per-byte write strobes. Using firmware, do 16/32-bit writes while watching strobes with LA; confirm all bytes commit together, never partially.       |
| B-9  | Routes per-slot `INT_CH[1:0]` and `NMI_CH` to `/CPU_INT[3:0]` and `/CPU_NMI[1:0]` according to `IntRouting[]` from the CPU descriptor.                                          | 2.1, 2.5, 2.8   | Program routing tables; for each channel on each slot, assert interrupts in firmware and monitor CPU interrupt pins with LA. Confirm mapping matches routing configuration.               |
| B-10 | Serializes interrupts at the CPU: only one source is actively presented at a time; additional requests stay pending at Tiles until the active one is cleared.                   | 2.5.1, 2.8      | Make two Tiles assert different interrupt channels simultaneously. Observe CPU interrupts and device status: CPU should service them one-by-one while both remain asserted at the slots.  |
| B-11 | In Mode-2 (`IntAckMode = 0x01`), tracks the active source (slot + channel) and routes `/CPU_ACK` to that slot via `/INT_ACK` only.                                              | 2.5.2, 2.8      | With LA on `/CPU_ACK`, `/INT_ACK[x]` lines, trigger an interrupt, then ack. Verify only the slot that asserted the interrupt sees `/INT_ACK` during the ack cycle.                        |
| B-12 | In Mode-2, issues a vector read and forwards the 8-bit vector byte from the Tile on `D[7:0]` during the ack cycle.                                                              | 2.5.2, 2.8      | Use a Tile with known vector. On ack, capture `A[]`, `/CS`, `D[7:0]` with LA. Confirm the backplane holds `/CS` and the CPU sees the Tile’s vector byte at the correct cycle.             |
| B-13 | If multiple claimants or no claimant exist for a given ack, returns `0xFF` as vector and does not assert `/INT_ACK` to any single slot.                                         | 2.5.2, 2.8      | Configure two Tiles to assert the same channel. Trigger ack. LA should show CPU reading `0xFF` on `D[7:0]` while no `/INT_ACK[x]` line is pulsed to any specific slot.                    |
| B-14 | When `IntAckMode = 0x00` (polling mode), ignores `/CPU_ACK` and never asserts `/INT_ACK` in response.                                                                           | 2.5.3, 2.8      | Set CPU descriptor to polling mode and deliberately toggle `/CPU_ACK`. Use LA to confirm `/INT_ACK` lines remain idle for all slots.                                                      |
| B-15 | Maintains signal integrity suitable for the target bus frequency (grounding, return paths, controlled impedance and fanout).                                                    | 2.2, 2.9, 2.10  | SI review (field solver or vendor guidelines), then run at or above target MHz with several worst-case Tiles installed; check for error-free operation and absence of visible ringing.    |

---

### C.3 Interop Test Checklist (informative)

This section provides a **practical bring-up script** for a Parallel-profile Dock + Tile combination. It assumes:

* A Host board with basic μBITz firmware,
* At least one “simple” Tile (e.g., a register-mapped debug Tile),
* A logic analyzer on the Parallel bus, and optionally a scope on power rails.

#### C.3.1 Power-on & reset

1. **Rails in-spec**

   * Power the Dock with no Tiles installed. Measure `VCC_3V3`, `VCC_3V3_STBY` (if present), and `VCC_5V` (if present) at one slot.
   * Confirm voltages match the Dock documentation and remain within tolerance under a light dummy load.

2. **Tile insertion**

   * Insert a single Tile. Power-on the system. Verify inrush does not cause visible droop or resets on other logic (scope on 3.3 V rail).

3. **Reset propagation**

   * Trigger a system reset from the Host (hardware or software).
   * Check `/RESET` at the slot: it should assert low, then deassert cleanly with defined slew; Tile should re-enumerate correctly afterwards.

---

#### C.3.2 Basic I/O cycles

1. **Idle bus sanity**

   * With no firmware accessing the Tile, observe `A[]`, `D[]`, `/IORQ`, `R/W_`, `/READY`. They should remain static/idle (no spurious activity).

2. **WRITE8/16/32**

   * Run a Host self-test that writes known patterns (e.g. `0x55`, `0xAA`, `0x1234`, `0x89ABCDEF`) into a few Tile registers.
   * On LA, confirm:

     * `A[]` is stable before `/IORQ` fall and during the write,
     * `R/W_ = 0`,
     * `D[]` holds the expected data while `/IORQ = 0` and `/READY = 0`.
   * Read back from the Tile and verify values match.

3. **READ8/16/32**

   * Run a Host test that reads the same registers.
   * On LA, confirm:

     * Host tri-states `D[]` before `/IORQ` goes low and `R/W_ = 1`,
     * Tile drives `D[]` only while `/CS = 0` and `/IORQ = 0`,
     * Readback values match previously written data.

4. **Unmapped window**

   * Access an address range with no Tile mapped.
   * Confirm: no `/CS` asserts, `/READY` stays high (no stretch), CPU returns all-ones.

---

#### C.3.3 Contention & bus ownership

1. **Dual-Tile selection**

   * Install two Tiles in different slots. Configure their windows so they do **not** overlap.
   * Sweep addresses over both mappings; on LA, check only one `/CS[x]` is ever active for a given `/IORQ`.

2. **Overlap detection (negative test)**

   * Temporarily program overlapping windows in firmware (or misconfigure intentionally, on a lab setup).
   * Observe that both `/CS` lines may assert; note this as a misconfiguration. The spec does not require hardware to prevent such overlap, but your compliance tests should detect it and prevent shipping that config.

3. **D-bus tri-state**

   * With two Tiles installed, run randomized read/write test.
   * Use LA to verify there are no instances where more than one Tile drives `D[]` simultaneously during valid read windows (would show as “mushed” waveforms or illegal bus levels).

---

#### C.3.4 Interrupts

1. **Level assert / clear**

   * Configure `INT_CH0` on a Tile to assert when a particular status bit is set.
   * Trigger the condition in firmware; monitor `INT_CH0` at the slot and `/CPU_INT[x]` at the Host.
   * Clear the condition via the Tile’s documented register write; confirm both lines return to idle.

2. **Vectored Mode-2 path**

   * Configure CPU descriptor with `IntAckMode = 0x01`.
   * Trigger Tile interrupt, then issue an interrupt acknowledge cycle.
   * On LA, check:

     * CPU asserts `/CPU_ACK`,
     * Dock routes `/INT_ACK` only to the active slot,
     * `D[7:0]` during the ack contains the Tile’s configured vector.

3. **Multiple pending sources**

   * Configure two Tiles (or two channels on one Tile) to assert different interrupts at the same time.
   * Ensure that:

     * CPU sees one interrupt first, services it, then sees the second,
     * During each ack, `/INT_ACK` is routed to the correct slot and the correct vector appears on `D[7:0]`.

4. **Polling mode**

   * Switch CPU descriptor to `IntAckMode = 0x00`.
   * Assert interrupts on a Tile and confirm:

     * `/CPU_ACK` pulses (if any) do not cause `/INT_ACK` on any slot,
     * Device interrupts are cleared only via register accesses, not by ack pulses.

---

#### C.3.5 Corner cases & robustness

1. **Slow Tile (`/READY` stretching)**

   * Configure a Tile (or test firmware on a Versatile Tile) to deliberately hold `/READY` low for a programmable number of cycles on access.
   * Confirm Host correctly inserts wait states and does not time out prematurely at the nominal setting.

2. **Stuck-low `/READY`**

   * Force a Tile into a “hung” state where `/READY` never deasserts (for test purposes).
   * Verify Dock/backplane timeout behavior: backplane must complete the cycle within `ReadyMaxuS` using timeout completion semantics and latch a timeout fault; CPU/Host must recover cleanly.

3. **Reset during active I/O**

   * While the Host repeatedly accesses the Tile, assert `/RESET`.
   * Check that bus lines return to their idle state, `D[]` is tri-stated by Tiles, and after reset the system cleanly re-enumerates the Tile.

4. **Max populate & SI sanity**

   * Populate all available slots with Tiles of varying load.
   * Run a worst-case firmware pattern (back-to-back max-width reads/writes).
   * With LA/scope, verify: clean transitions on `A[]`, `D[]`, `/IORQ`, `/READY`, no obvious ringing or cross-talk at the target clock rate.
