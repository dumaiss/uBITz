# Part 1 — Core Logical Specification

**Status:** Normative
**Depends on:** Part 0 (Overview)
**Independent of:** physical profiles (Parts 2–4). Profiles MUST implement this Part exactly.

---

## 1.1 Scope

This Part defines the **software-visible model** and **logical bus semantics** shared by all μBITz profiles:

- Windowed, register-file I/O model
- Access width rules (8/16/32-bit)
- Cycle semantics and `/READY` stretching
- Interrupt model (`/INT_CH[1:0]`, `/NMI_CH`, `/INT_ACK`) including Mode-2-style acknowledge
- Enumeration model and descriptor formats (CPU & Device)
- Reset and common state machine

No physical pins, connectors, lane coding, or timing waveforms are specified here; those live in Parts 2–4.

---

## 1.2 Terms & conventions

- **Window (WID):**  a policy entry defined by (IOWin, Mask, OpSel).
- **Register (REG):** is device-internal; Core does not fix its width/count.s.
- **Little-endian lanes:** `D[7:0]` = least significant byte, then `D[15:8]`, `D[23:16]`, `D[31:24]`.
- **CPU:** Host processor/card.
- **Device:** A peripheral card implementing one or more functions/windows.
- **Backplane:** The interposer that routes power and signals and provides enumeration.
- **Enumeration bus:** The profile-defined control bus used to read descriptors.

Keywords **MUST**, **SHOULD**, **MAY** are as in RFC 2119.

---

## 1.3 Logical signal set (profile-agnostic)

Profiles MUST expose the following **logical** signals/fields to implement the Core.

**Directions:**

C→B: CPU Board to Backplane (always parallel or discrete signals) unidirectional

B→D: Backplane to Device Board (profile dependent) unidirectional

C⇄B: CPU Board to Backplane (always parallel or discrete signals) bidirectional

B⇄D: Backplane to Device Board (profile dependent) bidirectional

| Name                     | Dir.        | Purpose (logical)                                                                                                                                                                                                                                                                                      |
| ------------------------ | ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `/IORQ`                  | C→B         | **I/O request, active-low**. Bounds a single I/O transaction. Asserted by the CPU for the entire cycle; the backplane treats it as the cycle qualifier (non-I/O cycles MUST be ignored). Not forwarded to devices; the backplane translates it into `/CS` (and, for Mode-2, the routed `/INT_ACK[k]`). |
| `R/W_`                   | C→B <br>B→D | Read/Write select: **1 = READ**, **0 = WRITE** (active-low W). C→B is always parallel; B→D is profile-specific.                                                                                                                                                                                        |
| `A[AddressBusWidth-1:0]` | C→B <br>B→D | Address bus from CPU; backplane forwards to device (profile-specific encoding on B→D).                                                                                                                                                                                                                 |
| `D[DataBusWidth-1:0]`    | C⇄B <br>B⇄D | Data bus, little-endian byte lanes. Always parallel for C→B but profile specific for B→D                                                                                                                                                                                                               |
| `/READY`                 | D→B <br>B→C | Wait-state stretch (active low).                                                                                                                                                                                                                                                                       |
| `/CS[Slot#-1:0]`         | B→D         | Per-slot device select (one-hot) signal after routing. The backplane asserts exactly one `/CS` during a normal I/O data cycle, held during the whole cycle, at most 50ns after decoding a valid address to connect that slot to the bus. In Minimal (single slot), this is implicit (always selected). |
| `/RESET`                 | B→C <br>B→D | Synchronous reset for devices on the backplane.                                                                                                                                                                                                                                                        |
| `/INT_CH[1:0]`           | D→B         | ***Per-slot*** Maskable interrupt request lines. From a device to the backplane, before routing.                                                                                                                                                                                                       |
| `/CPU_INT[3:0]`          | B→C         | Maskable interrupt request lines from backplane to CPU after routing.                                                                                                                                                                                                                                  |
| `/NMI_CH`                | D→B         | ***Per-slot*** Non-maskable interrupt request line. From device to backplane, before routing.                                                                                                                                                                                                          |
| `/CPU_NMI[1:0]`          | B→C         | Non-maskable interrupt request lines from backplane to CPU after routing.                                                                                                                                                                                                                              |
| `/CPU_ACK`               | C→B         | Active-low interrupt acknowledge for the corresponding INT channel from CPU to backplane, before routing.                                                                                                                                                                                              |
| `/INT_ACK`               | B→D         | ***Per-slot*** Active-low interrupt acknowledge for the corresponding INT channel from backplane to device after routing.                                                                                                                                                                              |
| `CLK_HOST`               | C→B         | Optional reference clock from Host, distributed by Dock.                                                                                                                                                                                                                                               |
| `CLK_DOCK[3:0]`          | B→D<br>B→C  | Optional reference clocks from Dock (4 independent clocks).                                                                                                                                                                                                                                            |
| **Enumeration bus**      | —           | Control channel to read descriptors (location & pins are profile-specific).                                                                                                                                                                                                                            |
| TOTAL                    | 24-104      | Minimum:  <br>* 24 signals: 8 bits data, 8 bits address, no interrupt, 8 IO Signals  <br>Maximum:  <br>* 92 signals: 32 bits data, 32 bits address, 20 interrupts, including ack, 8 IO Signals                                                                                                         |


**`/CS` semantics:**

During a normal I/O transaction, the backplane **MUST assert at most one** `/CS`. Unselected devices **MUST** ignore `A[AddressBusWidth-1:0]` and `R/W_` and **MUST NOT** drive `D[31:0]`.

**Ack cycles:**

During a Mode-2 acknowledge, `/CS` **MUST NOT** be de-asserted; the backplane routes `/CPU_ACK` →  `/INT_ACK` to **the slot currently asserting `INT_CH[k]`**

**Per-slot interrupt architecture:**

- Each slot exposes its own set of up to 3 interrupt lines (2 INT + 1 NMI)
- Physical implementation: 20 traces total (5 slots × 3 channels)
- Backplane routes each slot's channels independently to CPU pins per IntRouting policy
- Multiple devices may share the same CPU pin via different slots' channels
- Implementations with fewer slots MUST still provide dedicated channels per slot
- Implementation may limit the number of channel per slot, including not supporting interrupts at all

**Implementation flexibility:**

- Backplanes MUST implement between 0 and 3 interrupt channels per slot
- Valid configurations: 0 (no interrupts), 1-3 channels
- Backplane MUST document which channels are implemented in its datasheet
- If a slot's channel is unimplemented, devices MUST NOT declare that IntChannel
- During enumeration, backplane SHOULD validate device IntChannel against implemented channels

---

## 1.4 Addressing model: windows, masks and registers

- The backplane selects a Window by the following operation:
    - Let the IO Port be `A[AddressBusWidth-1:0]`, the MASK be IOMask as specified in the CPU Descriptor and OP be the operation to perform Read = 1, Write = 0, ANY = FF; then
    `(A[AddressBusWidth-1:0] & MASK) == (IOWin & IOMask)` and OP permits the operation
    `(OP==0xFF || (OP==0x01 && R/W_==1) || (OP==0x00 && R/W_==0))`.
- The full address is sent to the device **as is** to interpret the register within the device. 
The backplane **does not rewrite** addresses; devices must perform any intra-device register decode.
- **Unmapped window behavior:** Reads **MUST** return all-ones on the active data width (e.g., `0xFF`, `0xFFFF`, or `0xFFFFFFFF`); writes **MUST** be ignored; `/READY` **MUST** complete immediately.
- If multiple entries match, select the one with the **greatest mask specificity** (highest popcount of `Mask`). If still tied, **enumeration must fail**.

**Register atomicity:** For 16/32-bit writes, the device MUST apply all constituent bytes as a single update (**atomic within the window**).

---

## 1.5 Access width & byte lanes (fixed by platform)

- The platform’s `DataBusWidth ∈ {8,16,32}` (from the CPU descriptor) fixes the number of bytes per I/O transaction.
- On **writes**, the CPU drives `D[7:0]` for 8-bit, `D[15:0]` for 16-bit, `D[31:0]` for 32-bit. Upper lanes MUST be ignored by devices.
- On **reads**, devices MUST drive only the active lanes; the CPU MUST ignore inactive lanes.
- **Endianness** is **little-endian** for all multi-byte register groupings.
- **Design hint (devices):** For `DataBusWidth>8`, group related 8-bit registers into aligned 2- or 4-byte fields so whole-word writes don’t clobber unrelated state. If fine-grained updates are required, provide shadow/latch regs or read-modify-write friendly layouts.

---

## 1.6 Transaction semantics

**1.6 I/O cycle bounding (/IORQ & /READY)**

A Core I/O transaction is qualified by `/IORQ=0` and completed by `/READY→1`.

### 1.6.1 Write cycle (R/W_=0)

1. **Start:** CPU drives `A[…]`, `D[…]`, `R/W_=0`, then asserts `/IORQ=0`.
2. **Claim:** Backplane asserts exactly one `/CS[n]=0` to the selected device and immediately drives `/READY=0`.
3. **Execute:** Device samples address/data while `/IORQ=0` and `/CS[n]=0`.
4. **Commit:** When the write is complete and the device’s state is stable, the backplane releases `/READY→1`.
5. **End:** CPU must keep `/IORQ=0` until it observes `/READY=1`, then deasserts `/IORQ→1`; backplane deasserts `/CS[n]→1`.

### 1.6.2 Read cycle (R/W_=1)

1. **Start:** CPU drives `A[…]`, `R/W_=1`, then asserts `/IORQ=0`.
2. **Claim:** Backplane asserts `/CS[n]=0` and `/READY=0`.
3. **Execute:** Device drives `D[…]` (active lanes only) while `/IORQ=0` and `/CS[n]=0`.
4. **Data-valid & Commit:** Backplane MUST ensure `D[…]` is valid before releasing `/READY→1`.
5. **End:** CPU samples data on (or after) `/READY→1`, then deasserts `/IORQ→1`; backplane deasserts `/CS[n]→1`.

**Rules (both directions):**

- CPU **MUST NOT** deassert `/IORQ` while `/READY=0`.
- Device **MUST NOT** drive `D[…]` unless `/CS[n]=0` **and** `/IORQ=0`.
- Backplane **MUST** keep `/CS[n]=0` from `/IORQ↓` until `/IORQ↑` (no mid-cycle deselects).
- Backplane **MUST** ignore all cycles with `/IORQ=1`.

### 1.6.3 Interrupt acknowledge cycle (Mode-2, `IntAckMode=0x01`)

1. A device holds `INT_CH[k]=0` (level) until serviced.
2. CPU asserts `/CPU_ACK=0` **while also asserting `/IORQ=0` and `R/W_=1`**.
3. Backplane routes `/CPU_ACK` to the **same slot** currently asserting `INT_CH[k]`, keeps `/CS[n]=0`, pulls `/READY=0`, and sources a **read** from that slot.
4. The device (or backplane on its behalf) drives the **8-bit vector index** on `D[7:0]`.
5. Backplane releases `/READY→1`; CPU samples the vector; CPU then deasserts `/IORQ→1` and `/CPU_ACK→1`; backplane deasserts `/CS[n]→1`.
6. Devices clear/hold the request per their documented semantics (ack alone does not clear).

**CPUs without a native I/O request pin (e.g., 6502) MUST synthesize `/IORQ` on the CPU card.**

- The CPU card SHALL assert `/IORQ=0` **iff** the current cycle matches a mapped I/O function by the Core decode rule:
    
    `(A & IOMask) == (IOWin & IOMask)` and `OpSel` matches (`READ`, `WRITE`, or `BOTH`).
    
- All other bus cycles **MUST NOT** assert `/IORQ`; the backplane MUST ignore them.
- Timing: synthesized `/IORQ` MUST meet the same “hold until `/READY→1`” rule as above.


---

## 1.7 Reset & common state

- `/RESET` asserted by the backplane MUST reset device window state machines and device-local status.

---
## 1.8 Clock Distribution (Optional)

The μBITz platform provides optional reference clock distribution to support timing-critical applications and multi-device synchronization.

**Clock Sources:**

- **CLK_HOST**: Generated by the Host board, represents platform-specific timing (CPU clock, pixel clock, etc.)
- **CLK_DOCK[0:3]**: Generated by the Dock, provides up to four independent reference frequencies

**Distribution Model:**

- CLK_HOST: Host → Dock → Tiles/Bank (broadcast)
- CLK_DOCK[n]: Dock → Host/Tiles/Bank (broadcast)

**Compliance Requirements:**

- All clock signals are **optional** for both producers and consumers
- Devices **MUST NOT** require specific clock frequencies for basic operation
- Devices **MUST** tolerate missing clocks (undriven or tied low)
- Clock usage **SHOULD** be documented in device descriptors or implementation notes

**Profile Implementation:**

- **Parallel Profile**: Physical clock pins on connector (see Part 2, §2.2.4)
- **Serial Profile**: Clock signals follow same physical pins as Parallel (see Part 3, §3.2.2)
- **Minimal Profile**: Clock distribution is implementation-defined

---

## 1.9 Interrupt model

### 1.9.1 Lines and levels

- `INT_CH[1:0]` and `NMI_CH` are interrupt request lines.
- `CPU_INT[3:0]` and `CPU_NMI[1:0]` are asserted by the backplane, following routing rules.
- **Level-active** semantics: a device keeps the line **asserted** until its condition is serviced.
- NMI behavior is CPU-specific; there is **no acknowledge** for NMI in the Core.

### 1.9.2 Acknowledge modes

The CPU declares its interrupt acknowledge mode in its **CPU Descriptor** (Section 1.11.2):

- **`IntAckMode = 0x00` (None):** No special acknowledge cycle. The CPU ISR(s) poll device status to identify the source.
- **`IntAckMode = 0x01` (Mode-2-style):**
    - The CPU acknowledges an interrupt by asserting **`/CPU_ACK=0`** for an acknowledge cycle, which asserts the `INT_ACK` on the device side that initiated the interrupt. This is determined by keeping track of the slot which asserted`INT_CH[1:0]` and `/CS`
    - The **asserting device** MUST drive an **8-bit vector index** on `D[7:0]`.
    - The CPU forms the handler address as `{I, VectorIndex}` where **`I`** is the CPU’s **internal vector base register** (not supplied by devices).
    - If no device claims the ack, the backplane MUST drive `0xFF` (all ones) on `D[7:0]`.
    - Devices MUST release `/INT_CH[k]` per their documented clear semantics (e.g., read-to-clear, write-to-clear), not merely by seeing an ack.
    - **Ack cycle timing:** During a Mode-2 ack, the CPU drives `R/W_=1` and **MUST** use the normal `/READY` handshake; the I/O address is ignored during the ack.
    
**Mode-2 Vector Endpoint:**  
Devices supporting Mode-2 interrupt acknowledge MUST implement a vector read endpoint at offset 0x00 within their assigned I/O window. The device MUST return an 8-bit vector index when:

- A read cycle targets ADDR=0x00 (within the device's window), AND
- The device's slot-local `/INT_ACK` signal is asserted

Outside of an ack cycle (when `/INT_ACK` is deasserted), the device MAY use ADDR=0x00 for other purposes or return device-specific data.

> Note: There is no M1+/IORQ coupling in the Core; profiles map the acknowledge cycle to their physical signaling.
> 

**Interrupt Clear Semantics where Mode-2 is not used:** 
Every interrupt-generating Tile MUST document in its device-specific spec: 
1. Which register(s) control interrupt enable/mask 
2. Which register(s) report interrupt status/cause 
3. The EXACT sequence to clear each interrupt source, one of: 
	- Read-to-clear: Reading status register clears the condition 
	- Write-1-to-clear: Writing 1 to status bit clears it 
	- Write-0-to-clear: Writing 0 to status bit clears it 
	- Auto-clear: Interrupt clears when underlying condition resolves (e.g., reading FIFO data) 
4. Whether the device releases `INT_CH[k]`: 
	1. Immediately after clear sequence completes, OR 
	2. After next instruction cycle boundary, OR 
	3. With documented N-cycle delay 
	
Rationale: CPU ISR must know the exact timing to avoid: 
	- Spurious re-interrupts (premature release) 
	- Stuck interrupts (never released) 

### 1.9.3 Priority & concurrency

The backplane MUST ensure only ONE interrupt is active at the CPU at any time:

1. When a device asserts `INT_CH[k]` or `NMI_CH`:
   - If NO interrupt currently active:
     a. Backplane records the (Slot, Channel) as "active source"
     b. Routes to corresponding `CPU_INT[x]` or `CPU_NMI[y]` per IntRouting[]
     c. BLOCKS all other device interrupt assertions from propagating
   
   - If an interrupt IS already active:
     a. New assertion is HELD at the backplane (not propagated to CPU)
     b. Device's `INT_CH[k]` remains asserted (device doesn't know it's blocked)
     c. Once active interrupt clears, backplane samples held assertions
     d. Implementation-defined: may select first-detected or highest-priority held interrupt

2. Interrupt is considered "cleared" when:
   - Device releases its `INT_CH[k]` or `NMI_CH` line (de-asserts to logic high)

3. For Mode-2 acknowledge:
   - Backplane routes `/CPU_ACK` to ONLY the recorded "active source" slot
   - If active source is ambiguous or lost, backplane returns 0xFF

Rationale: This serialization prevents:
- Race conditions in Mode-2 vector reads
- Interrupt masking issues if CPU has limited mask control
- Backplane complexity of tracking multiple simultaneous ack targets

### 1.9.4 Per-Slot Channel Architecture

Each slot provides **UP TO** 3 independent interrupt channels:

- `Slot_N.INT_CH[1:0]`: UP TO 2 maskable interrupt channels
- `Slot_N.NMI_CH`: UP TO 1 non-maskable interrupt channels

**Implementation notes:**

- Backplanes MAY implement fewer channels (or zero) per slot
- Unimplemented channels MUST be left unconnected (not grounded or pulled)
- Devices MUST declare only channels that exist on the backplane
- Total backplane traces: UP TO 20 (5 slots × UP TO 3 channels + ACK traces)

**Examples:**

- Full implementation: 20 traces (all channels on all slots)
	- Including Mode-2 acknowledgement
	- 4 slots + 1 internal Dock services, each 4 traces (INT_CH[0], INT_CH[1], NMI_CH, INT_ACK)
- Minimal implementation: 3 traces (Slot 0: INT_CH[0], NMI_CH; Slot 1: same)
	- No Mode-2 acknowledgement in that example
- No interrupts: 0 traces (CPU polls devices via registers only)

**Backplane routing:**

1. Device in Slot N asserts `Slot_N.INT_CH[k]`
2. Backplane determines which (Function, Instance) is in Slot N
3. Backplane searches IntRouting[] for matching (Function, Instance)
4. Backplane asserts corresponding `CPU_INT[x]` or `CPU_NMI[y]`

**Key properties:**

- Slot channels are physically independent (not OR'd together)
- Multiple slots may route to the same CPU pin (OR'd at CPU side)
- During Mode-2 ack, backplane routes `/CPU_ACK` to the specific slot that asserted `INT_CH[k]`

**Example:**

```c
// Two devices use different slots' INT_CH[0]
Slot 1: Function=VIDEO, Instance=0 → asserts Slot1.INT_CH[0]
Slot 2: Function=SOUND, Instance=0 → asserts Slot2.INT_CH[0]

// CPU descriptor routes both to same CPU pin
IntRouting[0] = { Function=VIDEO, Instance=0, DestPin=CPU_INT[2], ... }
IntRouting[1] = { Function=SOUND, Instance=0, DestPin=CPU_INT[2], ... }

// Both route to CPU_INT[2] (OR'd at CPU side)
// CPU ISR must poll both devices to identify source
```

### 1.9.5 Interrupt Routing Lookup

When a device in Slot N asserts a channel:

1. Backplane identifies (Function, Instance) assigned to Slot N
2. Determine asserted channel bitmask:
   - If `INT_CH[0]` asserted: channel_mask = 0x01
   - If `INT_CH[1]` asserted: channel_mask = 0x02
   - If `NMI_CH` asserted:    channel_mask = 0x10

3. Search IntRouting[] for entry matching:
     (entry.Function == Function) AND
     (entry.Instance == Instance) AND
     ((entry.Channel & channel_mask) != 0)

4. If found: Assert entry.DestPin per entry.Mode and Stretch_us
   If not found: Ignore (device channel not routed)
   If multiple matches: Use first match found (search order 0→15)

5. Record (Slot N, channel_mask) as "active interrupt source" for ack routing

Example:
```
  Device: VIDEO, Instance=0 in Slot 2
  IntRouting[3] = { Function=VIDEO, Instance=0, Channel=0x11, 
                    DestPin=CPU_NMI[0], Mode=EDGE }
  
  When device asserts INT_CH[0]:
    channel_mask = 0x01
    0x11 & 0x01 = 0x01 ≠ 0  → Match found
    Result: Generate edge pulse on CPU_NMI[0]
    
  When device asserts NMI_CH:
    channel_mask = 0x10
    0x11 & 0x10 = 0x10 ≠ 0  → Match found
    Result: Generate edge pulse on CPU_NMI[0]
    
  Both device channels route to the SAME CPU pin via ONE IntRouting entry.
```


### 1.9.6 NMI and Maskable Interrupt Interaction 

The relative priority and masking behavior of `NMI_CH` versus `INT_CH` is HOST-DEFINED and depends on the CPU architecture: 

Examples: 
- Z80: NMI cannot be masked, preempts INT handlers 
- 6502: NMI preempts IRQ but multiple NMIs may be lost 
- 68000: Level-7 interrupts (NMI-equivalent) preempt lower levels 
 
The backplane routes `NMI_CH` and `INT_CH` to their configured CPU pins per IntRouting[]; the CPU card implementation determines priority and masking behavior. 

Tile designers MUST document which interrupt sources map to which channels, and recommend appropriate IntRouting configurations for common CPU platforms. 

### 1.9.7 Interrupt Fairness (Informative)

The blocking mechanism may cause interrupt starvation if:
- High-frequency device (e.g., 60Hz VBLANK) has long ISR processing time
- Device fails to properly release INT_CH[k] after servicing

Best practices for Tile designers:
1. Release `INT_CH[k]` as soon as status register is read (read-to-clear pattern)
2. For continuous sources (e.g., VBLANK), require explicit ISR re-enable after each service
3. Document worst-case assertion time for each interrupt source

Best practices for Host firmware:
1. Service interrupts promptly (minimize ISR execution time)
2. For low-priority devices sharing high-frequency CPU pin, consider polling
   instead of interrupt-driven operation
3. Implement watchdog to detect stuck interrupts (device never releases)

Future versions of this spec may add priority arbitration or time-sliced interrupt scheduling

---

## 1.10 Bus width disclosure (CPU → backplane)

A CPU MUST publish its **logical bus widths** via its CPU Descriptor:

- `AddressBusWidth ∈ {8,16,32}`
- `DataBusWidth ∈ {8,16,32}`

**Profile rules:**

- **Serial (Part 2):** Backplane/devices MUST either support the declared widths or fail enumeration.
- **Parallel/Minimal (Parts 3–4):** The physical bus **always exposes** `A[AddressBusWidth-1:0]` and `D[31:0]`; backplane/devices MUST adapt to the CPU’s declared widths.

---

## 1.11 Window & register behavior (device side)

Devices MUST document for each claimed window:

- **Register map** (names, device-defined offsets, reset defaults).
- **Access widths supported** per register or register group (8-only vs. 8/16/32).
- **Side effects** (read-to-clear, write-1-to-clear, latching, FIFOs).
- **Timing hints** (expected `/READY` hold for slow paths).
- **Interrupt relationship** (which bits assert which `INT_CH`).

---

## 1.12 Enumeration model & descriptors

Enumeration discovers:

1. The CPU’s capabilities (widths, ack mode, platform ID).
2. Each slot’s device(s), the function they expose, and their function capabilities.

The **Enumeration bus** is profile-defined (I²C recommended). The logical **descriptor layout** is defined here.

### 1.12.1 CPU descriptor

```c
// Total: 416 bytes
struct CPUDescriptor {
    // Header (16 bytes)
    uint8_t  MagicNumber[4];      // "UPCI" (0x55 0x50 0x43 0x49)
    uint8_t  Version;             // Descriptor version (0x01)
    uint8_t  DeviceType;          // 0x01 = CPU
    uint8_t  Reserved1[10];       // All set to 0x00
    
    // Metadata (16 bytes)
    char     Manufacturer[16];

    // Platform Info (32 bytes)
    char     PlatformID[28];      // "C64", "APPLE2", "ZX48K", etc. 
                                  // ASCII Fixed length NUL-Padded
    uint8_t  CPUType;             // 0x01=8080, 0x02=8085, 0x03=Z80,
                                  // 0x04=6502, 0x05=6809, 0x06=68000, etc.
    uint8_t  DataBusWidth;        // Valid value one of [8, 16, 32] (bits)
    uint8_t  AddressBusWidth;     // Valid value one of [8, 16, 32] (bits)
    uint8_t  IntAckMode;          // 0x00=None, 0x01=Mode2

    // I/O Window Mapping (224 bytes, 16 windows × 14 bytes each)
    struct {
        uint8_t  Function; // Function ID (0x00=none, 0x01-0xFF)
        uint8_t  Instance; // Instance number (0-6)
        uint32_t  IOWin;  // IO Window Address for specified function see Sec.1.4
        uint32_t  Mask;   // Mask for IO Windows address see Sec.1.4
        uint8_t  OpSel;   // Operation 1=read, 0=write, FF=both
        uint8_t  Flags;   // Bit 0: Required (fail boot if device funct. missing)
        uint8_t  Reserved[2];     // All set to 0x00
    } WindowMap[16];              
    // Window[n] selection based on Address & mask = IOWin then operation R/W
    // Example:  
    //   IO Address 0xBF & Mask 0xE0 = C0 --> match IO Win to C0
    //   if Operation is read (0) or write (1) will select different devices
    
    // Interrupt Routing (128 bytes, 16 entries × 8 bytes each)
    struct {
        uint8_t  Function;   // Function ID (0x00 = disabled, 0x01-0xFF)
        uint8_t  Instance;   // Instance ID (0-6)
        uint8_t  Channel;    // Logical channel identifier (bitfield):
                             //   0b0000|0001 (0x01) = INT_CH0
                             //   0b0000|0010 (0x02) = INT_CH1
                             //   0b0000|0011 (0x03) = INT_CH0 and INT_CH1
                             //   0b0001|0000 (0x10) = NMI_CH
                             //   0b0001|0001 (0x11) = NMI_CH and INT_CH0
                             //   0b0001|0010 (0x12) = NMI_CH and INT_CH1
                             //   0b0001|0011 (0x13) = All chaennels 
                             
				             // Other values are reserved 
				             // in v1.x and MUST be set to 0x00.
        uint8_t  DestPin;    // CPU pin to drive:
                             //   0x00-0x03 = CPU_INT[0..3]
                             //   0x10-0x11 = CPU_NMI[0..1]
                             // Other values are reserved.
        uint8_t  Mode;       // 0x00 = EDGE, 0x01 = LEVEL
        uint8_t  Stretch_us; 
			        // For EDGE mode: pulse width in microseconds (0 = minimum)
        uint8_t  Reserved[2];// All set to 0x00
    } IntRouting[16];
};

// For each WindowMap[i]: if Function=0x00, must be ignored by backplane; 
// if Flags.Required=1 and no matching peripheral appears, enumeration fails
// IntRouting: If Function=0x00 (Disabled) → ignore entry; 
```

**IntRouting lookup semantics:**

- A routing entry is matched by `(Function, Instance, Channel)`.
- If `Function = 0x00`, the entry is disabled and MUST be ignored.
- If multiple entries have the same `(Function, Instance, Channel)` the backplane MUST treat this as a configuration error and fail enumeration.
- If no entry exists for a given `(Function, Instance, Channel)` then that channel produces no CPU-visible interrupt.


**Reserved Function values:**

- `Function=0x00`: Disabled/no routing for this entry
- `Function=0xFE`: Reserved (not currently used)
- `Function=0xFF`: Wildcard (implementation-specific; not required)

**Function IDs (Standard):**

```
0x00: None/Unmapped
0x01: VIDEO  (display controller)
0x02: SOUND  (audio synthesis)
0x03: HUMAN INPUT DEVICE (keyboard, joystick, mouse)
0x04: STORAGE (disk, tape, cartridge)
0x05: SERIAL (UART, RS-232)
0x06: PARALLEL (printer port)
0x07: NETWORK (Ethernet, WiFi, modem)
0x08: RTC (real-time clock)
0x09: GPIO (general purpose I/O)
0x0A-0x0F: Reserved for future standards
0x10-0xFF: Vendor-specific

```

### 1.12.2Device descriptor

A device exposes **one descriptor per card** plus one or more **Function records** that claim windows.

```c
// Total: 256 bytes
struct PeripheralDescriptor {
    // Header (16 bytes)
    uint8_t  MagicNumber[4];      // "UPCI"
    uint8_t  Version;             // 0x01
    uint8_t  DeviceType;          // 0x02 = Peripheral
    uint8_t  Reserved1[10];       // All set to 0x00

    // Device Identity (32 bytes each up to 7 == 224)
    struct {
		    uint8_t  Function;         // Function ID (0x01-0xFF)
		    uint8_t  Instance;         // Instance number (0-6)
		    uint8_t  DataBusWidth;     // Valid value one of [8, 16, 32] (bits)
            uint8_t  AddressBusWidth;  // Valid value one of [8, 16, 32] (bits)
		    uint8_t  IntAckMode;       // 0x00=None, 0x01=Mode2
		                               // must match CPU or return 0xFF
	        uint8_t  IntChannel;    // Logical channel identifier (bitfield):
	                             //   0b0000|0001 (0x01) = INT_CH0
	                             //   0b0000|0010 (0x02) = INT_CH1
	                             //   0b0000|0011 (0x03) = INT_CH0 and INT_CH1
	                             //   0b0001|0000 (0x10) = NMI_CH
	                             //   0b0001|0001 (0x11) = NMI_CH and INT_CH0
	                             //   0b0001|0010 (0x12) = NMI_CH and INT_CH1
	                             //   0b0001|0011 (0x13) = All chaennels 
					             // Other values are reserved 
					             // in v1.x and MUST be set to 0x00.		
		    uint8_t  HardwareVersion;     // Card revision
		    uint8_t  FirmwareVersion;     // Device firmware version
		    char     FunctionName[16];    // "VIC-II", "UART16550", etc. 
		                                  // ASCII Fixed length NUL-Padded
		    uint8_t  Reserved2[7];        // All set to 0x00
		} DeviceInstance[7]
    
    uint8_t  Reserved3[16];           // All set to 0x00
 }

```

> **Conflict rule:** If two devices claim the same WindowID required by the CPU policy, **enumeration fails** (FAULT LED on). The backplane does **not** remap WIDs.
> 

### 1.12.3 Memory descriptor

```c
// BankDescriptor — version 0x01
// Stored in the Bank EEPROM at I²C address 0x51.
// Total: 256 bytes56

typedef struct MemoryDescriptor
{
    // --- Common header (shared with CPUDescriptor / PeripheralDescriptor) ---
    uint8_t MagicNumber[4];   // "UPCI" — common descriptor magic.
    uint8_t SpecVersion;      // Descriptor format version. Must be 0x01 for this layout.
    uint8_t DeviceType;       // 0x03 = Bank (Memory Board).
    uint8_t Reserved1[10];    // Zero; reserved for future common header flags.

    // --- Manufacturer / vendor identity ---
    char    VendorID[16];     // ASCII, fixed length. Short vendor name.

    // --- Board identity / platform binding ---
    char    BoardID[16];      // Board model identifier, e.g. "BANK-SRAM-512K". ASCII Fixed Length
    uint8_t BankRevision;     // Board hardware revision (0x00..0xFF).
    
    // --- Memory summary (Word RAM / ROM / NVRAM) ---
    uint8_t RAMAddrWidth;    // Number of address lines implemented for RAM (e.g., 18 ⇒ 256 KiB locations).
    uint8_t ROMAddrWidth;    // Number of address lines implemented for ROM (e.g., 18 ⇒ 256 KiB locations).
    uint8_t DataBusWidth;    // Must be compatible with Host `DataBusWidth`.
    uint8_t Reserved2[204]; // Zero; pad to 204-byte summary block.
} BankDescriptor;

```

### 1.12.4 Enumeration flow (normative)

1. **Reset backplane** and ensure all devices are in default state.
2. **Read CPU descriptor** and validate `AddressBusWidth`, `DataBusWidth`, `IntAckMode`.
3. **Probe slots** (profile-specific addressing) and read each **Device descriptor**.
4. **Build window map: I**nstantiate the set of `(Function,Instance) → Slot` bindings and the CPU policy **WindowMap[]** of `(IOWin, Mask, OpSel) → (Function,Instance)`. **No remapping at runtime.** Two **Required** WindowMap entries must not resolve to different slots for the same `(Function,Instance)`; duplicate identical `(IOWin,Mask,OpSel)` for the same `(Function,Instance)` is illegal.
5. **Coverage sanity:** For every **Required** entry, at least one enumerated peripheral exposes the same `(Function,Instance)` and is compatible with the platform `DataBusWidth`; otherwise **FAIL**.

If the Serial backplane cannot support the CPU’s bus widths, the backplane MUST fail enumeration and signal an error (profile-specific).
6. **Bus width compatibility rules:**
    1. Device DataBusWidth ≤ CPU DataBusWidth: PASS (device uses subset of lanes)
    2. Device DataBusWidth > CPU DataBusWidth: FAIL
7. **Interrupt routing validation:**
- For each enumerated device:
    - Extract IntChannel bitmask from device descriptor
    - For each set bit in IntChannel (channel device uses):
    a. Verify backplane implements that channel on device's slot
    b. Determine channel index from bitmask bit position:
        - Channel = 0x01-0x03 (INT_CH[0-1] either or both or none if == 0x10)
        - Channel = 0x10 (NMI_CH) 
        c. Verify IntRouting[] contains entry with matching (Function, Instance, Channel)
        d. If any check fails: **FAIL enumeration** with FAULT LED
- If IntChannel = 0x00: No validation needed (device uses polling only)

**Example validation pseudocode:**

```
   for each device:
       intmask = device.IntChannel
       if intmask == 0x00:
           continue  // No interrupts

       // Check INT_CH[0-1]
       for bit in [0..1]:
           if (intmask & (1 << bit)) != 0:
               channel_id = bit  // 0x00-0x03
               if !backplane_has_channel(device.slot, channel_id):
                   FAIL("Device uses unimplemented INT_CH[%d]", bit)
               if !introuting_has(device.func, device.inst, channel_id):
                   FAIL("INT_CH[%d] not routed to CPU", bit)

       // Check NMI_CH
       for bit in [4]:
           if (intmask & (1 << bit)) != 0:
               channel_id = 0x10 + (bit - 4)  // 0x10-0x13
               if !backplane_has_channel(device.slot, channel_id):
                   FAIL("Device uses unimplemented NMI_CH[%d]", bit-4)
               if !introuting_has(device.func, device.inst, channel_id):
                   FAIL("NMI_CH[%d] not routed to CPU", bit-4)

```

- For Mode-2 ack configurations:
    - If multiple devices in different slots have same (Function, Instance)
    - And both declare the same IntChannel
    - Then backplane MUST fail enumeration (ambiguous ack target)

**Duplicate routing entries:**

- If multiple IntRouting entries have identical (Function, Instance, Channel):
    - Backplane MUST fail enumeration with FAULT LED
    - Rationale: Ambiguous routing target

---

## 1.13 Timing model (abstract)

- The Core defines **ordering** and **handshake**; exact cycle counts and setup/hold are profile-specific.
- Required guarantees:
    - Devices MUST latch `A[AddressBusWidth-1:0]`, and `R/W_` (1=read, 0=write) at the **start** of the cycle.
    - Devices MUST NOT sample new address fields while `/READY=0`.
    - For reads, data on `D[…]` MUST be valid **before** `/READY` returns to 1 (completion).
    - For writes, data on `D[…]` MUST be valid for the entire period where the device samples it (profile timing defines this window).
    - The backplane/device path MUST latch the effective address (`A[7:0]`) and operation (`R/W_`) at cycle start.
    - /CS assertion timing:
        - Address and R/W_ must be stable before /CS falls
        - /CS must remain asserted until /READY=1 (transaction complete)

---

## 1.14 Power & low-power (logical)

- Devices MAY implement **idle** and **sleep** states surfaced via registers (e.g., `POWER_CTL`).
- Entering a low-power state MUST NOT change register defaults or window claims; wake on access SHOULD be supported via `/READY` stretching.
- Physical power gating, slot-level rails, and sequencing are profile-specific.

---

## 1.15 Compliance checklist (Core)

A **CPU implementation** MUST:

- Publish a valid CPU Descriptor with widths and `IntAckMode`.
- Handle `/READY` stretching and implement a timeout policy.
- For `IntAckMode=Mode2`, assert exactly one `/CPU_ACK` during an ack cycle and consume an **8-bit** vector index from `D[7:0]`.
- Assert `/IORQ=0` to qualify every Core I/O cycle, hold it until `/READY=1`, then release.
- For Mode-2, assert `/IORQ=0`, `R/W_=1`, and `/CPU_ACK=0` for the entire acknowledge cycle.

A **Device implementation** MUST:

- Provide a proper Device Descriptor and Function records for each claimed window.
- Implement atomic multi-byte register semantics and ignore inactive lanes on writes.
- Obey alignment rules and document undefined cases.
- Assert and clear interrupts per its documentation; if supporting Mode-2, source an **8-bit** vector index on ack.

A **Backplane implementation** MUST:

- Implement enumeration and conflict-free window assignment.
- For Mode-2 acks with no claimant, source `0xFF` on `D[7:0]`.
- If multiple entries match, select the one with the **greatest mask specificity** (highest popcount of `Mask`). If still tied, **enumeration must fail**.
- Assert exactly one `/CS[n]=0` for the duration of `/IORQ=0`; never deassert `/CS[n]` before `/IORQ→1`.
- Keep `/READY=0` from claim until data valid/commit, then release `/READY→1`.
- Ignore cycles with `/IORQ=1`.
- Route per-slot interrupt channels to CPU pins per IntRouting policy
- Track which slot asserted each interrupt for Mode-2 ack routing
- During Mode-2 ack, assert `/INT_ACK` to the specific slot that asserted `INT_CH[k]`
- If slot identification fails or multiple slots assert same channel, drive `D[7:0]=0xFF`
- Document which interrupt channels are implemented (in backplane datasheet)
- Validate device IntChannel declarations against implemented channels during enumeration
- Fail enumeration if device declares unimplemented IntChannel

---

## 1.16 Reserved values & future-proofing

- `IntAckMode=0x02..0xFF` reserved.
- Descriptors include **lengths** and **offsets** so future revisions can append fields without breaking v1.0 parsers.

---

## 1.17 Informative examples

### 1.17.1 32-bit write to a 16-bit timer pair

- CPU sets `ADDR=0x40 (TIMER register 0)`, asserts a WRITE (drive`R/W_` low), drives `D[31:0]=0x0001_F400` (1,000,000).
- Device applies `REG0..REG3` atomically, sets timer reload to 1 MHz.

### 1.17.2 Mode-2-style interrupt

- Device asserts `/INT_CH[1]` when a frame is ready.
- CPU acks by asserting `/CPU_ACK=0`.
- Device (or backplane) drives `D[7:0]=0x42`.
- CPU jumps to address `{I, 0x42}` (high byte from CPU’s I register).
- ISR reads status in `WID=DEVICE_WID` to de-assert the interrupt.

### **1.17.3 Coleco-style shared ranges (write→SOUND, read→HID):**

```
CPU Platform: DataBusWidth=8, AddressBusWidth=8
WindowMap entries:
// SOUND on writes to 0xC0–0xDF (top 3 bits = 110)
{ Function=SOUND, Instance=0, IOWin=0xC0, IOMask=0xE0, OpSel=0x00 (WRITE), Flags=Required }

// HID on reads from 0xC0–0xDF (top 3 bits = 110)
{ Function=HID,   Instance=0, IOWin=0xC0, IOMask=0xE0, OpSel=0x01 (READ),  Flags=Required }

Accesses:
OUT (0xD5),A  → match SOUND (WRITE, 110xxxxx)
IN  A,(0xC2)  → match HID   (READ,  110xxxx
```

---

## 1.18 Minimal annex: recommended defaults (informative)

If the CPU descriptor is absent (Minimal profile with defaulting), the backplane/MCU SHOULD assume:

- `AddressBusWidth=8`, `DataBusWidth=8`
- `IntAckMode=None`
- A project-defined **default window map** (documented in Part 4).

---

## **1.19. ADDRESSING & ROUTING**

### **1.19.1 Function-Based Addressing**

**Concept:**

- CPU software uses I/O addresses like 0x30-0x3F for "sound chip"
- Backplane translates Function + Instance → Physical Slot
- Same software works regardless of which slot card is in

**Address Decode:**

```
CPU I/O Address: A[7:0]
  Mask = 0xF0 --> [7:4] = Window (Function identifier, 0x0-0xF)

Example:
  CPU executes: OUT (0x35), A
  Backplane sees:
    Window = 0x3 (due to: 0x35 & 0xF0)
  Lookup table:
    Window 0x3 → Function "SOUND", Instance 0
    Function "SOUND" Instance 0 → Slot 2
  Action:
    Assert /CS[2] (/CS for slot 2)
    Send : WRITE, ADDR=0x35, DATA=A
```

### **1.19.2 I/O Route Table**

**Built During Enumeration:**

```
For each window 0x0-0xF:
  Mapping: Mask 0xF0, (Window) → (Function, Instance, Slot, WidthCaps)

Example C64 Platform:
  Window 0x00, Mask 0xF0, Op = 0xFF: Unmapped
  Window 0x10, Mask 0xF0, Op = 0xFF: VIC-II   → Slot 0, 8-bit
  Window 0x20, Mask 0xF0, Op = 0xFF: SID      → Slot 1, 8-bit
  Window 0x30, Mask 0xF0, Op = 0xFF: CIA1     → Slot 2, 8-bit
  Window 0x40, Mask 0xF0, Op = 0xFF: CIA2     → Slot 2, 8-bit (same slot, inst=1)
  Window 0x5-0xF: Unmapped (return 0xFF on read)

```

**Mapping Source:**

- CPU card EEPROM declares: “Window 0x3 = Function SOUND, Instance 0”
- Device card EEPROM declares: “I am Function SOUND, Instance 0”
- Backplane matches them: “Window 0x3 → Slot N (wherever SOUND instance 0 is)”

**No-Match Handling:**

```
If CPU policy expects Function SOUND but no card provides it:
  → Enumeration FAILS (refuse to boot, blink error LED)
  → User must install correct card or change CPU policy

If device is present but not mapped to any window:
  → Boot succeeds (device ignored, not accessible)
  → Could be intentional (spare card, disabled feature)
```

**Software view:** after enumeration, software treats `(WID, REG)` as a **global I/O namespace**. The backplane guarantees those pairs reach the assigned function.

---

## **1.20. INTERRUPT ROUTING**

**Lines:** `INT_CH[1:0]` and `NMI_CH` are dedicated per device. `/CPU_ACK` acknowledges **INT** channels (not NMIs).

**Who goes on which CPU line? (Channel Assignment Table, CAT):**

- At enumeration time, the backplane creates a **Channel Assignment Table (CAT)** that maps **each device function** (i.e., each claimed `WindowID`) to **one of the 4 CPU INT channels** `CPU_INT[0:3]`.
- NMI sources, if any, follow the same policy into `CPU_NMI[1:0]` (platform-defined; often reserved for highest-priority events).

**Mode-2-style acknowledge :**

- CPU asserts the interrupt line**`/CPU_ACK=0`**. Selected slot is the same as the interrupt source.
- The **asserting device path** (device and/or backplane) places an **8-bit vector index** on `D[7:0]`. The CPU uses its **internal I register** (or some other register mechanism) as the high byte; the effective vector address is `{I, VectorIndex}`.
- If multiple devices share channel **k**, the backplane MUST respond on behalf of the device with 0xFF.
- If no device claims the ack, the backplane drives `0xFF` on `D[7:0]`.
- Devices clear their INT condition per their documented semantics (read-to-clear, write-to-clear, etc.); **ack alone does not clear**.

**Summary of mappings to CPU pins:**

- **INT request**: Device → its assigned `INT_CH[x]` (from CAT; open-drain OR to CPU pin).
- **NMI request**: Device → its assigned `NMI_CH[y]` (policy-specific).
- **Ack**: CPU → `/CPU_ACK` for the chosen channel; device/backplane returns **vector index** on `D[7:0]`.

### 1.20.1 Signal Topology

**Per-Slot Interrupt Lines:**

Each slot exposes up to 8 dedicated interrupt traces:

```
Slot N:
  INT_CH[1:0]  : up to 2 maskable interrupt channels
  INT_ACK      : Mode-2 interrupt acknowledgement
  NMI_CH       : up to 1 non-maskable interrupt channels

Total backplane traces: up to 20 (5 slots × 4 channels)

```

Each trace:

- Open-drain, active-low
- Pull-up resistor on backplane (typically 3.3kΩ to +3.3V)
- Device sinks current to assert
- Device releases (high-impedance) to de-assert

**CPU Card Physical Interface:**

```
CPU card exposes pins:
  CPU_INT[3:0]  : CPU interrupt input pins
  CPU_NMI[1:0]  : CPU NMI input pins
  CPU_ACK       : CPU interrupt acknowledge outputs (Mode-2 only)

```

**Backplane Routing:**

- Backplane maps each slot's channels to CPU pins per IntRouting policy
- Multiple slots may route to the same CPU pin (OR'd at CPU side)
- CPU ISR must identify which device interrupted (by polling device status)

### **1.20.2 Routing Configuration**

**CPU Card EEPROM Policy:**

```
For each board channel (INT_CH[1:0], NMI_CH, INT_ACK):
  DestPin:   Which CPU_INT[0-3] or CPU_NMI[0-1] to drive
  Mode:      EDGE or LEVEL
  Stretch:   0-255 µs (pulse width for edge mode)
  Active:    true/false (enable/disable this channel)

Example (8085 CPU):
  INT_CH0 → CPU_INT[2], EDGE, 0µs      (RST5.5, no stretch needed)
  INT_CH1 → CPU_INT[3], EDGE, 0µs      (RST6.5)
    NMI_CH0 → CPU_NMI[0], EDGE, 0µs      (TRAP)
  
Example (68000 CPU):
  INT_CH0 → CPU_INT[0], LEVEL          (IPL0, autovector level 1)
  INT_CH1 → CPU_INT[1], LEVEL          (IPL1, autovector level 2)
  NMI_CH0 → CPU_NMI[0], EDGE           (TRAP)

```

**Device Card EEPROM:**

```
Device declares which channels it uses:
  IntChannels:  Bitmask [1:0] (which INT_CH lines)
  NmiChannels:  Bitmask [4] (which NMI_CH lines)

Example (Sound card):
  IntChannels = 0b0000|0001 (uses INT_CH0 for buffer-ready events)
  NmiChannels = 0b0000|0000 (does not use NMI)
  NmiChannels = 0b0001|0000 (uses NMI)

```

### **1.20.3 Backplane Interrupt Logic**

**Per-Channel State Machine:**

```
For each board channel (INT_CH[x], NMI_CH[x]):
  1. Monitor line for assertion (active low)
  2. Lookup Channel, DestPin, Mode, Stretch from CPU policy
  3. Execute:

     EDGE Mode:
       - Detect falling edge on board channel
       - Generate pulse on DestPin for Stretch duration
       - Minimum pulse: 100ns if Stretch=0
       - Device may release or hold line (ignored after edge)

     LEVEL Mode:
       - Pass through board channel state to DestPin
       - No pulse generation
       - CPU sees level until device releases or ISR reads status

```

### **1.20.4 Interrupt Service Routine (ISR) Flow**

**CPU Perspective:**

```
1. CPU receives interrupt on RST7.5 (or whatever pin)
2. Jump to ISR vector
3. ISR reads device status registers via IO operation:
   - IN A, (0x30)  ; Read device 0 status
   - TEST bit 0    ; Check interrupt flag
   - If set: handle, write back to clear flag
   - If clear: check next device
4. Return from interrupt

No "interrupt acknowledge" or "claim register" needed.
Device status register read is the acknowledgment.

```

**Error Handling in ISR:**

```
If device read returns 0xFF (timeout):
  - Spurious interrupt or device fault
  - Log error, increment counter
  - Return from ISR without handling
  - Do NOT retry indefinitely (hang risk)

If no device has interrupt pending:
  - Spurious interrupt (EMI, race condition)
  - Increment spurious counter
  - Return from ISR

```

### 1.20.5 Enumeration outcome & fault indication

**Goal:** If the system can’t come up because descriptors/mapping are bad or unsupported, make it obvious to the builder. No logs, no codes, no host protocol required.

**A) Outcome classes (internal to the enumerator)**

- **SUCCESS:** All required windows/functions are present and uniquely mapped; widths and profile constraints satisfied.
- **FATAL:** Any condition that makes the system unusable (e.g., missing required function, duplicate WID claim, width unsupported).
- **NON-FATAL:** Extra devices present but unmapped/ignored (system still usable).

> The enumerator MAY keep internal reasons for debugging, but the Core does not define any way to export them.
> 

**B) What the backplane MUST/MAY do**

- **MUST provide one visual FAULT indicator LED** on the backplane (labeled “FAULT” or “ERROR”).
- On **FATAL**, the backplane **MUST** turn the FAULT LED **solid ON** within 100 ms of power-good or `/RESET` release and keep it ON until the next power cycle or `/RESET`.
- On **SUCCESS**, the FAULT LED **MUST be OFF**.
- On **NON-FATAL**, the FAULT LED **MUST be OFF** (informational conditions are not indicated).

**Optional (non-normative):**

- A separate **STATUS** LED may blink during enumeration and turn solid ON when ready.
- Builders MAY implement their own blink patterns, but the Dock specification does not standardize them.

**C) Interaction with profiles**

- **Serial/Parallel/Minimal:** same rule—exactly one FAULT LED on the backplane; no error channel or POST code is required or defined by the Core. If no EEPROM descriptor is used in the Minimal profile, FAULT LED is optional.

---
### Appendix A

**Mode-2 Debugging Tips (Informative)** 

**Common Mode-2 ack issues:** 
1. Device never responds to vector read: 
	1. → Check that device implements ADDR=0x00 vector endpoint 
	2. → Verify device sees /INT_ACK assertion on its slot 
	3. → Confirm device INT_CH[k] is still asserted during ack cycle 
2. Backplane returns 0xFF: 
	1. → Multiple devices asserting same INT_CH[k] (check enumeration) 
	2. → Backplane lost track of asserting slot (rare, check state machine) 
	3. → Device released INT_CH[k] before CPU acknowledged (timing race) 
3. System hangs on ack: 
	1. → Device not releasing /READY in Serial profile 
	2. → Framing timeout not implemented in backplane 
	3. → CPU /IORQ assertion timing incorrect (check CPU card) 

Test procedure: 
	1. Test without Mode-2 (polling mode) first 
	2. Verify interrupt assertion/clearing works 
	3. Enable Mode-2 and confirm vector reads succeed 
	4. Use logic analyzer to capture ack cycle timing