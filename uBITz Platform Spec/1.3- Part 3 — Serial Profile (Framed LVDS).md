# Part 3 — Serial Profile (Framed LVDS)

**Status:** Normative
**Version:** 1.0
**Date:** 2025

**Depends on:** Part 1 (Core)

---

## 3.1 Scope and relationship to Core

This Part defines the framed serial transport used between the backplane and a Serial-Profile device over LVDS pairs. It refines—but does not alter—the Core’s logical model. On any conflict, **Core prevails**.

**Core requirements preserved by this profile (normative):**

- **Addressing:** The backplane selects a slot by `(IOWin, IOMask, OpSel)` on `A[7:0]` and forwards the **entire CPU I/O address** to the device unchanged.
- **IO Transaction semantics:** CPU asserts `/IORQ` as per Core, Backplane will hold`/READY` low during the IO Transaction. Devices may stretch `/READY`; the CPU implements a timeout policy. This profile virtualizes `/READY` over the framed link.
- **Bus widths:** `AddressBusWidth ∈ {8,16,32}`, `DataBusWidth ∈ {8,16,32}`; Serial MUST support the declared widths or fail enumeration.
- **Interrupt topology:** Channels are **per-slot**; Mode-2 ack returns an **8-bit vector** on `D[7:0]` and is routed to the asserting slot.

---

## 3.2 Physical link (summary)

- **Lanes:** One LVDS data pair **B→D** and one **D→B** (full-duplex). Implementations may add forwarded clock pairs if the PHY requires it; embedded-clock is typical.
- **Signaling:** AC-coupled differential pairs, **100 Ω** at enabled receivers; keep pairs short/matched; weak bias acceptable for defined idle CM.
- **Power:** Device SERDES/PHY powered from the **standard per-slot 3V3 VCC** supplied by the backplane.
- **Enumeration bus:** I²C is unaffected by this profile (location/pins are profile-specific per platform).

---

## 3.3 Line coding (Parity-10)

This profile uses **10 bits per byte** carried as **two 5-bit symbols** (nibble + parity for each nibble).

### 3.3.1 Data symbol format

- A transmitted **symbol** is `D[3:0], P0, D[7:4], P1` (LS nibble first).
- **Parity rule:** `P0` = **even parity** over `D[3:0]`; `P1` = **even parity** over `D[7:4]`. Receivers **MUST** verify both parity bits.
- **Error classification:** A parity-invalid 10-bit value matching a **reserved control token** (3.3.2) is a **control**; any other parity-invalid value is a **symbol error**.

### 3.3.2 Control tokens (reserved, parity-invalid)

To replace 8b/10b K-codes (SOF/EOF/ERR/IDLE), reserve **four 10-bit tokens** that are **not valid under the parity rule**. Receivers MUST recognize these tokens regardless of parity:

- **SOF** — Start of Frame
- **EOF** — End of Frame
- **IDLE** — Link idle/training fill
- **ERR** — Error indication (NAK, timeout, decode error)

(*Rationale:* parity-invalid sentinels provide unambiguous framing)

| Token | Low half (first) | High half (next) | 10-bit (hi:lo) |
| --- | --- | --- | --- |
| SOF | `00001` | `11111` | `11111_00001` |
| EOF | `11111` | `00001` | `00001_11111` |
| IDLE | `10101` | `10101` | `10101_10101` |
| ERR | `00111` | `00111` | `00111_00111` |

### 3.3.3 DC balance and run-length

Implementations **SHOULD** maintain average DC balance and cap run-length (e.g., byte-wise scrambler on data, token alternation for IDLE). Parity-10 does **not** inherently provide disparity control like 8b/10b; this is a PHY/SI consideration, not visible to software.

### 3.3.4 Rationale: Parity-10 vs. 8b/10b and CRC (informative)

**Why not 8b/10b or CRC?**

- **No FPGA or MCU requirement:** Full 8b/10b decoding typically implies an FPGA (comma/disparity/K-code handling). Frame-level CRCs are easy in software but tend to push builders toward an MCU (or a larger logic budget) on every device.
- **What most SERDES already expose:** Commodity SERDES geared for 8b/10b usually present a **10-bit parallel symbol** at the PCS boundary. We exploit that width to carry **8 data bits + 2 parity bits** (one per nibble), enabling **very simple error checking and control tokens** in small PLDs or simple glue logic—no FPGA/MCU required.

**Detection properties (nibble parity):**

- Detects **all single-bit errors**.
- Detects any error pattern with an **odd** number of flips in either nibble.
- Misses only **even-count flips confined within the same nibble** (e.g., 2-bit flips both in D[3:0], or both in D[7:4]). Among exactly two-bit errors across the whole byte, the undetected subset is those where both flips land in the same nibble:
    
    - count = C(4,2) per nibble, so fraction = **C(4,2) / C(8,2) = 6/28 ≈ 21.4%** of 2-bit errors;
    
    - but 2-bit errors are already far rarer than 1-bit errors on a healthy LVDS link.
    
- Frame integrity still benefits from **EOF-commit atomicity**: malformed or aborted frames do not partially apply.

**Control symbols without K-codes:**

- Because data symbols must satisfy nibble parity, we can reserve **parity-invalid 10-bit patterns** for **SOF/EOF/IDLE/ERR**. These tokens are trivial to detect in hardware and cannot collide with valid data, achieving the “comma/K-code” role without full 8b/10b.

**DC/disparity considerations:**

- Parity-10 provides **no inherent disparity control**. Keep receivers happy with a lightweight PHY measure (e.g., IDLE toggling or a simple data scrambler). This stays **below the protocol layer** and does not burden device logic with 8b/10b complexity.

**Why this is the right trade-off for µBITz:**

- Preserves the **10-bit symbol cadence** many parts already support.
- Keeps device-side logic **tiny** (flip-flops + XOR trees + a small FSM).
- Retains robust, unambiguous **framing** and **basic error signaling** (ERR token).
- Leaves room for **optional upgrades** (e.g., negotiated frame CRC8/CRC16) in future revisions without breaking the base profile.

---

## 3.4 Frame format and semantics

A **transaction** is exactly one **request** frame; reads have one **response** frame. All multi-byte payload fields are **little-endian on wire** (LSB first). (Little-endian **on wire** as in Core.)

- **Byte 0 = Control Octet** (R/W, SZ, AL, 3×RES=0)
- **ADDR = AL-selected bytes** (8/16/32), **little-endian**
- **Byte N = FLAGS Octet** (low nibble = FLAGS, high nibble = 0)
- (WRITE only) **DATA bytes** = SZ-selected (8/16/32), little-endian

Each octet on wire is still encoded as Parity-10 (4+P,4+P) per §3.3.

At most **one** outstanding transaction **per slot**. Devices **MUST NOT** transmit unsolicited frames; only the request’s matching response.

---

### 3.4.1 Request header (B→D) — Frame on wire (with parity shown)

**Bit order convention (normative):**

- **Time flows left → right.**
- **Within each octet**, bits are sent **LSB-first**.
- Each octet is carried as **two 5-bit symbols**:
    - **Symbol A** = `d0 d1 d2 d3 P0`
    - **Symbol B** = `d4 d5 d6 d7 P1`
        
        where **P0/P1 are even parity** over their 4 data bits (set to make nibble+parity even).
        

**Control tokens** (10-bit each) are **two halves of 5 bits** and are chosen to be **parity-invalid** in both halves so they can’t collide with data symbols:

- `SOF  = 00001 | 11111` (both halves parity-invalid)
- `EOF  = 11111 | 00001`
- `IDLE = 10101 | 10101`
- `ERR  = 00111 | 00111`
    
    *(Left half is transmitted first; the vertical bar is just a visual divider.)*
    

### Frame structure

```
        ┌──────────────┐  ┌─────────────────────┐  ┌──────────────┐
B  →  D │  SOF (10 b)  │→ │   HEADER + [DATA]*  │→ │  EOF (10 b)  │
        └──────────────┘  └─────────────────────┘  └──────────────┘
                       (DATA present on WRITE only)

(each octet → two 5-bit syms)
```

**HEADER octets:**

- **Octet 0 (CONTROL):** `R/W | SZ | AL` packed as `000_AL_SZ_R/W`
- **Octets 1..k (ADDR):** AL-selected width (8/16/32), **little-endian**
- **Octet k+1 (FLAGS):** high nibble **0000**, low nibble **FLAGS**

Each **octet** becomes **two 5-bit symbols** on the wire:

```
One octet (value: d7..d0):
  Symbol A (first):  d0 d1 d2 d3 P0
  Symbol B (next):   d4 d5 d6 d7 P1
  where P0 = parity_even(d0..d3), P1 = parity_even(d4..d7)

```

---

### 3.4.1.1 CONTROL octet mapping (quick reference)

`CONTROL = (AL << 3) | (SZ << 1) | (R/W)` with `[b7..b5]=000`

- `AL`: `00=8b addr`, `01=16b`, `10=32b` (`11=reserved`)
- `SZ`: `00=8b data`, `01=16b`, `10=32b` (`11=reserved`)
- `R/W`: `0=WRITE`, `1=READ`

---

### 3.4.1.2 Worked frames **with parity bits shown**

> Notation: each octet is shown as 
AAAAA|BBBBB = Symbol A d0 d1 d2 d3 P0  | Symbol B d4 d5 d6 d7 P1.
**SOF/EOF** are the 10-bit control tokens listed above.
> 

### A) 32-bit **WRITE** @ `0x0010_0004`, `FLAGS=0011`, `DATA=0xA1B2C3D4`

- CONTROL: `AL=10, SZ=10, R/W=0` → `0x14`
- ADDR (LE): `04 00 10 00`
- FLAGS: `0x03` (upper nibble 0000)
- DATA (LE): `D4 C3 B2 A1`

**On wire (10-bit groups; left→right in time):**

```
SOF: 00001|11111
      00101|10001   (0x14 CONTROL)
      00101|00000   (0x04 ADDR[7:0])
      00000|00000   (0x00 ADDR[15:8])
      00000|10001   (0x10 ADDR[23:16])
      00000|00000   (0x00 ADDR[31:24])
      11000|00000   (0x03 FLAGS)
      00101|10111   (0xD4 DATA0)
      11000|00110   (0xC3 DATA1)
      01001|11011   (0xB2 DATA2)
      10001|01010   (0xA1 DATA3)
EOF: 11111|00001

```

### B) 8-bit **READ** @ `0x7F`, `FLAGS=0000`

- CONTROL: `AL=00, SZ=00, R/W=1` → `0x01`
- ADDR: `7F`
- FLAGS: `00`

**Request (B→D):**

```
SOF: 00001|11111
      10001|00000   (0x01 CONTROL)
      11110|11101   (0x7F ADDR)
      00000|00000   (0x00 FLAGS)
EOF: 11111|00001

```

**Response (D→B):** `SOF | <DATA octet as two 10-bit symbols> | EOF`

*(Example: DATA `0xAB` → `11011|01000`)*

### C) 16-bit **WRITE** @ `0x1234`, `FLAGS=0001`, `DATA=0x55AA`

- CONTROL: `AL=01, SZ=01, R/W=0` → `0x0A`
- ADDR (LE): `34 12`
- FLAGS: `01`
- DATA (LE): `AA 55`

**On wire:**

```
SOF: 00001|11111
      01010|00000   (0x0A CONTROL)
      00101|11000   (0x34 ADDR[7:0])
      01001|10001   (0x12 ADDR[15:8])
      10001|00000   (0x01 FLAGS)
      01010|01010   (0xAA DATA0)
      10100|10100   (0x55 DATA1)
EOF: 11111|00001

```

---

### 3.4.1.3 Decoder cheat-sheet (nibble parity)

- **Even parity rule:** parity bit = `1` iff the 4 data bits contain an **odd** number of 1s.
- **Data symbol** (valid): `(d0+d1+d2+d3+P0) mod 2 = 0` and `(d4+d5+d6+d7+P1) mod 2 = 0`.
- **Control token** (SOF/EOF/IDLE/ERR): **both halves parity-invalid** (sum mod 2 = 1), and must match one of the reserved 10-bit constants above.
- **Error:** any other parity-invalid half **not** matching a control token.

### 3.4.2 Read response (D→B)

Device sends: **SOF | DATA(1/2/4) | EOF**. No header is required in the response. 

```
        ┌────────┐  ┌───────────┐  ┌───────────┐
D  →  B │  SOF   │→ │  [DATA]+  │→ │   EOF     │
        └────────┘  └───────────┘  └───────────┘
                    (READ only)
```

```
[DATA] (READ only; SZ-selected, little-endian) Octet k+1 until EOF

SZ=00 (8-bit):   1 byte  → DATA[7:0]
SZ=01 (16-bit):  2 bytes → DATA[7:0], DATA[15:8]
SZ=10 (32-bit):  4 bytes → DATA[7:0], DATA[15:8], DATA[23:16], DATA[31:24]

```

### 3.4.3 Error reporting

- ERR token: A device MAY transmit ERR to signal NAK/invalid access/overflow. ERR MUST appear only after SOF and before EOF of the current frame. Once ERR is sent, the sender MUST NOT emit any further octets for that frame (no EOF is required).
- Timeouts and aborted frames:
    - If a device cannot complete a request within the platform watchdog, the backplane aborts the transaction.
    - If a request is aborted or times out after SOF, the backplane MUST complete the CPU read with all-ones for the requested width (8/16/32).
    - Writes that do not reach EOF MUST NOT take effect. Writes that have reached EOF are considered committed.

**In-frame contiguity:**
Frames **MUST** be contiguous: after SOF, only data halves are permitted until EOF. **No IDLE** or other control tokens may appear inside a frame. A sender may terminate a frame early with **ERR**, after which only **IDLE** or a new **SOF** may follow.

---

## 3.5 Transaction mapping to Core

- **Addressing:** The backplane decodes `(IOWin, IOMask, OpSel)` on `A[7:0]`, asserts exactly one `/CS[slot]`, and forwards the full address in the **ADDR** field; the device performs any internal register decode.
- **Widths:** Data width is the Core transaction width (`SZ`). The device **MUST** treat multi-byte ops as atomic per 3.4 and Core rules.
- **/READY virtualization:** There is **no** physical `/READY` wire on the serial link; the backplane stretches CPU-visible `/READY` while the framed transaction is in flight.
- **Unmapped windows:** If no WindowMap entry matched, the backplane **must not** issue a frame; reads complete with all-ones and writes are ignored, per Core/platform policy.

---

## 3.6 Link bring-up and idle

- After reset/enumeration, both ends transmit **IDLE** continuously until a valid **SOF** is detected. A minimum IDLE run may be required by the receiver for CDR/lock (implementation-defined). (Behavior parallel to retired Pro bring-up.)
- Forwarded clocks MAY be used if the PHY requires them; otherwise, embedded clocking is typical.
- After reset or loss-of-lock, transmit at least 16 IDLE tokens before SOF.
- On any invalid parity pair that does not form a defined control token, receivers MUST drop to a FIND_SOF state and ignore traffic until a valid SOF is detected.
- Receivers SHOULD declare an in-frame timeout if inter-half spacing exceeds T_ifg (recommended ≥ 64 UI); the frame is aborted. (UI = Unit Interval, the serial bit period)

---

## 3.7 Interrupt handling

- **Per-slot interrupt wiring:** Each slot exposes dedicated physical interrupt lines device→backplane: `INT_CH[1:0]` and `NMI_CH`. The LVDS link carries no interrupt signaling; it is used only for framed requests/responses. The backplane routes these lines to the CPU per **IntRouting**.
- **Mode-2 ack over Serial (vector read at conventional endpoint):**
    1. On a CPU `/CPU_ACK`, the backplane identifies the **asserting slot** from the per-slot lines and **holds `/CS`** to that slot. It also **forwards the ack** to that slot (slot-local **`/INT_ACK`** asserted for the duration of the cycle).
    2. The backplane issues a **READ** transaction to the device’ **vector read endpoint**:
        - **CONTROL:** `R/W=1, SZ=00 (8-bit), AL=00 (8-bit address)`
        - **ADDR:** `0x00`
        - **FLAGS:** `0x00`
            
            Devices **MUST** implement a read-only 8-bit **Vector Register** at `ADDR=0x00` for the Serial profile. 
            
            > This endpoint is only interpreted as a vector read while the slot-local **`/INT_ACK`** is asserted; otherwise, a read at `ADDR=0x00` is treated as a normal device register per the device’s map.
            > 
    3. The device returns the **8-bit vector index** in the read response. If the device cannot provide a vector index **or** did not assert the channel, it **MUST** return `0xFF`. The backplane forwards this value on `D[7:0]` during the CPU’s ack cycle.
- **Multiple claimants:** If more than one slot asserts the same `INT_CH[k]` at the time of the CPU ack, the backplane **MUST** present `0xFF` to the CPU and **MUST NOT** query any slot’s Vector Endpoint.
- **NMI:** `NMI_CH` are not vectored. The backplane **MUST NOT** perform a Vector Endpoint read for NMI; devices **MUST** ignore `/INT_ACK` during an NMI event.

---

## 3.8 Compliance checklist — Device (Serial)

A conformant Serial-profile **device** MUST:

- Power its LVDS SERDES/PHY from **slot 3V3 VCC**; no dedicated LVDS rail.
- Implement **Parity-10** (3.3), **SOF/EOF/IDLE/ERR** tokens (3.3.2), the header fields (3.4.1), **commit-on-EOF**, and the one-frame read reply (3.4.2).
- Provide a valid **Device Descriptor** and function claims for windows; support declared bus widths or fail enumeration.
- Drive INT_CH[1:0]/NMI_CH per Core electrical rules and return the vector index in response to a **vector read at `ADDR=0x00` while `/INT_ACK[k]` is asserted** if Mode-2 is claimed.

---

## 3.9 Compliance checklist — Backplane (Serial)

A conformant Serial-profile **backplane** MUST:

- Provide per-slot LVDS pairs per the platform pin map; provision **3V3 VCC** for expected SERDES load (no Serial/Parallel power distinction).
- Implement Core decode/forwarding: assert exactly one `/CS[slot]` and forward **full address** in the frame.
- Virtualize `/READY` to the CPU while framed transactions are active; implement a platform watchdog for timeouts.
- Route per-slot interrupts per **IntRouting**, and implement Mode-2 ack routing and `0xFF` fallback when no device claims.
- Provide pull-ups/conditioning for per-slot INT_CH[1:0]/NMI_CH.

---

## 3.10 Timing (informative)

End-to-end latency is the SERDES pipeline plus device FSM (~a few parallel clocks), with deterministic completion at EOF; the CPU only observes `/READY` stretching. (Parallel clocks of **25–50 MHz** with ~**250–600 Mb/s** line rate were used in the retired Pro; similar class is suitable here.)

---

## 3.11 Reserved values & future-proofing

- `SZ=11b` and `AL=11b` are **reserved**.
- Additional control tokens may be reserved by future revisions; receivers MUST reject any parity-invalid symbol that is not a defined control token.

---

### Appendix (informative) — Symbol encoder/decoder sketch

### A.1 Bit order & tokens (recap)

- **Octet on wire ⇒ two 5-bit symbols (total 10 bits).**
    
    **Symbol A** (sent first): `d0 d1 d2 d3 P0`
    
    **Symbol B** (next):       `d4 d5 d6 d7 P1`
    
    where `P0 = parity_even(d0..d3)` and `P1 = parity_even(d4..d7)`.
    
    *Even parity rule:* the XOR of each nibble’s 4 bits **plus** its parity bit is **0**.
    
- **Control tokens** are single **10-bit** values (two 5-bit halves) that are **parity-invalid** in both halves and therefore cannot collide with data:
    - `SOF = 00001 | 11111` → `0b11111_00001`
    - `EOF = 11111 | 00001` → `0b00001_11111`
    - `IDLE = 10101 | 10101` → `0b10101_10101`
    - `ERR = 00111 | 00111` → `0b00111_00111`
    
    *(We write “low half | high half”, and the combined 10-bit constant is `(high<<5)|low`.)*
    

---

### A.2 Helper: parity & packing

```c
// Return 1 if 'v' has an odd number of 1s (XOR-reduction of 4 bits).
inline uint1 parity4_odd(uint4 v) { return ((v ^ (v>>1) ^ (v>>2) ^ (v>>3)) & 1); }

// Even parity bit to APPEND to nibble so that nibble+parity is even:
// 1 if nibble is odd, else 0
inline uint1 parity_bit_even(uint4 v) { return parity4_odd(v); } 

// Pack two 5-bit halves into one 10-bit token:   [hi5][lo5]
inline uint10 pack10(uint5 lo, uint5 hi) { return ((uint10)hi << 5) | lo; }

```

---

### A.3 Encoder: one octet ⇒ two 5-bit symbols

```c
// Input:  b = 8-bit data octet
// Output: symA = d0 d1 d2 d3 P0   (LS nibble first)
//         symB = d4 d5 d6 d7 P1   (MS nibble next)
void encode_octet(uint8_t b, uint5 *symA, uint5 *symB) {
    uint4 lo =  b        & 0xF;     // d3..d0 are lo[3:0]; sent bit order d0,d1,d2,d3
    uint4 hi = (b >> 4)  & 0xF;     // d7..d4 are hi[3:0]; sent bit order d4,d5,d6,d7
    uint1 p0 = parity_bit_even(lo); // make lo+parity even
    uint1 p1 = parity_bit_even(hi); // make hi+parity even
    *symA = ((lo >> 0) & 1) | (((lo >> 1) & 1) << 1) | (((lo >> 2) & 1) << 2) | (((lo >> 3) & 1) << 3) | (p0 << 4);
    *symB = ((hi >> 0) & 1) | (((hi >> 1) & 1) << 1) | (((hi >> 2) & 1) << 2) | (((hi >> 3) & 1) << 3) | (p1 << 4);
}

```

**Verilog helper (optional):**

```verilog
function [4:0] enc_half;
  input [3:0] nib;              // {d3,d2,d1,d0}
  begin
    enc_half = { nib[0], nib[1], nib[2], nib[3], ^nib }; 
    // send LSB first; parity = XOR(nib)
  end
endfunction

// Example: symA = enc_half(b[3:0]); symB = enc_half(b[7:4]);

```

---

### A.4 Decoder: two 5-bit halves ⇒ octet (with control handling)

**Half classification:**

```c
typedef enum { HALF_DATA_VALID, HALF_CONTROL_CANDIDATE, HALF_GARBAGE } half_kind_t;

half_kind_t classify_half(uint5 h) {
    uint4 nib = ((h >> 0) & 1) | (((h >> 1) & 1) << 1) | (((h >> 2) & 1) << 2) | (((h >> 3) & 1) << 3);
    uint1 pb  = (h >> 4) & 1;
    uint1 want = parity_bit_even(nib);   // what the parity bit SHOULD be for a data half
    if (pb == want) return HALF_DATA_VALID;    // nibble+parity is even → data half
    return HALF_CONTROL_CANDIDATE;             // parity-invalid → could be part of a control token
}

```

**Token match (10-bit):**

```c
#define TOK_SOF  ((uint10)((0b11111 << 5) | 0b00001))
#define TOK_EOF  ((uint10)((0b00001 << 5) | 0b11111))
#define TOK_IDLE ((uint10)((0b10101 << 5) | 0b10101))
#define TOK_ERR  ((uint10)((0b00111 << 5) | 0b00111))

typedef enum { TOK_NONE, TOK_SOF_E, TOK_EOF_E, TOK_IDLE_E, TOK_ERR_E } tok_t;

tok_t classify_token(uint10 t) {
    if (t == TOK_SOF)  return TOK_SOF_E;
    if (t == TOK_EOF)  return TOK_EOF_E;
    if (t == TOK_IDLE) return TOK_IDLE_E;
    if (t == TOK_ERR)  return TOK_ERR_E;
    return TOK_NONE;
}

```

**Reassemble octets from a stream of 5-bit halves:**

```c
// Consume 5-bit halves in time order. Yields:
//  - CONTROL tokens (SOF/EOF/IDLE/ERR)
//  - DATA octets (when two valid halves arrive back-to-back)
// Any parity-invalid half must be the first part of a control token; otherwise it's an error.

typedef struct {
    bool     have_lo;     // waiting for next data half
    uint4    nib_lo;      // stored low nibble
    bool     hold_ctrl;   // we just saw a parity-invalid half
    uint5    ctrl_lo;     // stored low 5b half of a token
} rx_sym_agg_t;

bool rx_agg_init(rx_sym_agg_t *s) { memset(s,0,sizeof(*s)); return true; }

typedef enum { EV_NONE, EV_DATA_OCTET, EV_SOF, EV_EOF, EV_IDLE, EV_ERRTOK, EV_BADSYM } ev_t;

ev_t rx_agg_push(rx_sym_agg_t *s, uint5 half, uint8_t *out_octet) {
    half_kind_t k = classify_half(half);

    // data half
    if (k == HALF_DATA_VALID) {
        uint4 nib = ((half >> 0)&1) | (((half>>1)&1)<<1) | (((half>>2)&1)<<2) | (((half>>3)&1)<<3);
        if (!s->have_lo) {
            s->nib_lo = nib; s->have_lo = true;
            return EV_NONE; // need high nibble next
        } else {
            // Assemble octet (low nibble first, little-endian inside byte)
            *out_octet = (uint8_t)((nib << 4) | (s->nib_lo & 0xF));
            s->have_lo = false;
            return EV_DATA_OCTET;
        }
    }

    // control candidate
    if (!s->hold_ctrl) {
        // first (low) parity-invalid half → store and wait for second half
        s->ctrl_lo = half; s->hold_ctrl = true;
        return EV_NONE;
    } else {
        // second parity-invalid half → classify full 10-bit token
        uint10 t = pack10(s->ctrl_lo, half); // hi=second, lo=first
        s->hold_ctrl = false;
        switch (classify_token(t)) {
            case TOK_SOF_E:  s->have_lo = false; return EV_SOF;
            case TOK_EOF_E:  s->have_lo = false; return EV_EOF;
            case TOK_IDLE_E: s->have_lo = false; return EV_IDLE;
            case TOK_ERR_E:  s->have_lo = false; return EV_ERRTOK;
            default:                     return EV_BADSYM; // invalid parity-invalid pair
        }
    }
}

```

---

### A.5 TX/RX framing FSMs (minimal)

**Transmitter (B→D):**

```c
enum TXS { TX_IDLE, TX_SOF, TX_HDR, TX_ADDR, TX_FLAGS, TX_DATA, TX_EOF };
struct {
  TXS  st;
  uint8_t *p; size_t n; // pointer/length into current section
  uint5 symA, symB; bool haveB;
} tx;

void tx_begin_frame() { tx.st=TX_SOF; tx.haveB=false; }

bool tx_next_bit(uint1 *bit_out) {
  switch (tx.st) {
    case TX_IDLE: *bit_out = IDLE_STREAM_BIT(); return true; // repeatedly send IDLE token halves
    case TX_SOF:  return emit_token_bits(TOK_SOF, &tx.st, bit_out); // helper shifts 10 bits then advances to TX_HDR
    case TX_HDR:  return emit_octet_bits(control_octet(), &tx.st, &tx.haveB, bit_out, next=TX_ADDR);
    case TX_ADDR: return emit_bytes_bits(addr_bytes(), &tx.st, &tx.haveB, bit_out, next=TX_FLAGS);
    case TX_FLAGS:return emit_octet_bits(flags_octet(), &tx.st, &tx.haveB, bit_out, next = (is_write()?TX_DATA:TX_EOF));
    case TX_DATA: return emit_bytes_bits(data_bytes(), &tx.st, &tx.haveB, bit_out, next=TX_EOF);
    case TX_EOF:  return emit_token_bits(TOK_EOF, &tx.st, bit_out); // then TX_IDLE
  }
}

```

*(Helpers `emit_token_bits`, `emit_octet_bits`, `emit_bytes_bits` just wrap `encode_octet()` and serialize halves/10-bit tokens MS-to-LS or LS-first per §3.3.)*

**Receiver (D→B):**

```c
enum RXS { RX_FIND_SOF, RX_IN_FRAME };
rx_sym_agg_t agg; RXS rx = RX_FIND_SOF;

void rx_push_half(uint5 half) {
  uint8_t byte;
  switch (rx_agg_push(&agg, half, &byte)) {
    case EV_SOF:   rx = RX_IN_FRAME;      break;
    case EV_EOF:   rx = RX_FIND_SOF;      frame_complete(); break;
    case EV_IDLE:  /* ignore */           break;
    case EV_ERRTOK:frame_error(ERR_LINK); rx = RX_FIND_SOF; break;
    case EV_DATA_OCTET:
        consume_frame_octet(byte);        break;
    case EV_BADSYM:
        frame_error(ERR_BADSYM);          rx = RX_FIND_SOF; break;
    default: /* EV_NONE */                break;
  }
}

```

---

### A.6 Test vectors (sanity checks)

- **Data octet 0x00** → halves: `0000|0` and `0000|0` (i.e., `00000` then `00000`).
- **Data octet 0xFF** → halves: `1111|0` and `1111|0` (XOR of 1111 is 0, so parity bit 0 keeps even).
- **Data octet 0xA5 (1010_0101)**
    - lo nibble 0101 → XOR=0 → P0=0 → `1 0 1 0 | 0` (sent as `0 1 0 1 0`)
    - hi nibble 1010 → XOR=0 → P1=0 → `0 1 0 1 | 0`
- **Control SOF** must be detected only as the 10-bit token `0b11111_00001`; each 5-bit half individually is parity-invalid and **must never** be mistaken for data.

---

### A.7 Notes & options

- **Error policy:** On `EV_BADSYM` (parity-invalid pair not forming a known token), implementations should drop to `RX_FIND_SOF` and optionally count a link error.
- **Optional enhancements:** A scrambler for data octets (e.g., self-synchronizing x^9+x^5+1) can improve DC/run-length without changing the symbol/parity rules; it must **not** operate on control tokens.
- **Timing:** IDLE tokens may be interleaved between frames for CDR; receivers must ignore standalone IDLE tokens outside frames.

---

This appendix should be sufficient for a quick-and-clean reference implementation in either small programmable logic (ATF/GreenPAK/CPLD), an FPGA, or even a tiny MCU bit-pushing a serializer.

---

## Appendix— Interop Test Checklist (informative)

### B.1 Link bring-up

- Power-on: slot 3V3 within Core budget; device LVDS receivers present 100 Ω.
- Backplane emits ≥ 16 **IDLE** tokens; device locks; both ends remain in **FIND_SOF** until valid **SOF**.
- Loss-of-sync: inject one parity-invalid non-token half → both sides fall back to **FIND_SOF**.

### B.2 Framing sanity

- **Contiguity:** Send `SOF | CONTROL | ADDR | FLAGS | EOF` (no DATA) → device ignores (READ) or NOP (WRITE 0 bytes).
- **No IDLE in-frame:** Inserting any **IDLE** between header bytes must be treated as frame error and dropped.
- **ERR early-terminate:** Mid-frame **ERR** → backplane completes CPU read with all-ones; writes are not committed.

### B.3 Transactions (one outstanding per slot)

1. **READ8**: `AL=00,SZ=00` to a readable register; verify D→B returns exactly 1 octet.
2. **READ16/32**: `AL=01/10,SZ=01/10`; verify little-endian ordering on wire.
3. **WRITE8/16/32**: commit-on-**EOF**; verify partial (pre-EOF) writes don’t take effect.
4. **Unmapped window**: backplane must not issue a frame; CPU read returns all-ones.

### B.4 Interrupts

- **Level assert:** Device asserts `INT_CH[k]` → CPU sees interrupt; during `/CPU_ACK`, backplane holds `/CS` and asserts slot-local `/INT_ACK`.
- **Vector read (Mode-2):** While `/INT_ACK` asserted, backplane issues vector read (`CONTROL=0x01`, `ADDR=0x00`, `FLAGS=0x00`); device returns vector (0xFF if unclaimed).
- **Multiple claimants:** Two slots assert same `INT_CH[k]` → backplane returns `0xFF` without querying any slot.
- **NMI:** `NMI_CH` not vectored; no vector read performed; devices ignore `/INT_ACK`.

### B.5 Golden symbol checks

- Token encodings match table: `SOF=11111_00001`, `EOF=00001_11111`, `IDLE=10101_10101`, `ERR=00111_00111`.
- Data octet encoding: for 0xAB → `11011|01000` (even parity per nibble).

### B.6 Timing & robustness

- Inter-half timeout ≥ **64 UI** triggers frame abort.
- Back-to-back frames (`EOF` → next `SOF`) with zero idle gap accepted.
- Optional scrambler OFF by default; if enabled, it MUST NOT affect control tokens.

# Appendix C — Conformance Matrix (informative)

### C.1 Device (Serial Profile)

| ID   | Requirement (summary)                                                                                | Spec §       | How to verify                                                        |
| ---- | ---------------------------------------------------------------------------------------------------- | ------------ | -------------------------------------------------------------------- |
| D-1  | SERDES/PHY powered from slot **3V3**                                                                 | 3.2          | Inspect BOM/power tree; measure 3V3 draw at slot.                    |
| D-2  | Implements **Parity-10** (nibble even parity)                                                        | 3.3, A.3/A.4 | Transmit/receive vectors: 0x00, 0xFF, 0xA5; check halves and parity. |
| D-3  | Recognizes control tokens **SOF/EOF/IDLE/ERR** (bit-true)                                            | 3.3.2, A.1   | Send each token; verify state transitions and no data emission.      |
| D-4  | Little-endian **on wire** for ADDR/DATA                                                              | 3.4          | Probe a 16/32-bit op and confirm byte order.                         |
| D-5  | **Commit on EOF** for writes; pre-EOF writes do **not** take effect                                  | 3.4, 3.4.3   | Mid-frame ERR → no state change; full frame → state updated.         |
| D-6  | **One** outstanding transaction per slot; no unsolicited frames                                      | 3.4          | Attempt to pipeline; device must not respond until prior completes.  |
| D-7  | HEADER layout: CONTROL/ADDR/FLAGS with FLAGS high-nibble 0                                           | 3.4.1        | Send non-zero FLAGS high nibble; device must ignore.                 |
| D-8  | Read response framing: **SOF                                                                         | DATA         | EOF** (no header)                                                    |
| D-9  | Handles in-frame error/abort correctly (no more octets after **ERR**)                                | 3.4.3        | Inject ERR; verify immediate stop and stable FSM.                    |
| D-10 | **INT_CH/NMI_CH** electrical behavior per Core                                                       | 3.7, 3.8     | Level/edge tests; open-drain/pull-ups confirmed at slot.             |
| D-11 | Mode-2: while **/INT_ACK** asserted, READ at `ADDR=0x00` returns 8-bit vector (0xFF if not claimant) | 3.7          | Drive interrupt; ack; verify vector byte; test non-claim = 0xFF.     |
| D-12 | Ignores vector read when **/INT_ACK** deasserted (acts as normal reg)                                | 3.7          | Read `0x00` without /INT_ACK; confirm device-defined behavior.       |
| D-13 | Loss-of-sync handling (drop to FIND_SOF on invalid non-token pair)                                   | 3.6, A.4     | Corrupt one half; device RX returns to FIND_SOF.                     |
| D-14 | Inter-half timeout handling (abort ≥ **T_ifg** recommended)                                          | 3.6          | Stall between halves; device aborts frame.                           |

### C.2 Backplane (Serial Profile)

| ID   | Requirement (summary)                                                                                                              | Spec §     | How to verify                                               |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------- | ---------- | ----------------------------------------------------------- |
| B-1  | Provides per-slot LVDS pairs; **100 Ω** term at receiver                                                                           | 3.2        | SI inspection; measure differential impedance/termination.  |
| B-2  | Supplies per-slot **3V3** within Core budget                                                                                       | 3.2        | Load test; current headroom for SERDES+logic.               |
| B-3  | Decodes `(IOWin, IOMask, OpSel)`, asserts exactly one `/CS[slot]`                                                                  | 3.5        | Address sweep; ensure single-slot selection.                |
| B-4  | Forwards **full address** in frame (AL-selected width)                                                                             | 3.5, 3.4.1 | Device echoes latched ADDR; verify wire image.              |
| B-5  | **/READY** virtualization during framed ops                                                                                        | 3.5        | Observe CPU WAIT stretch equals frame duration.             |
| B-6  | No frame for unmapped windows; CPU read → **all-ones**                                                                             | 3.5        | Read unmapped; verify `0xFF/0xFFFF/0xFFFFFFFF`.             |
| B-7  | **IDLE** preamble ≥ 16 tokens after reset/loss-of-lock                                                                             | 3.6        | Scope link after reset; count tokens.                       |
| B-8  | Loss-of-sync recovery to **FIND_SOF** on bad pair                                                                                  | 3.6        | Inject parity-invalid non-token; observe state machine.     |
| B-9  | **Contiguity**: no tokens inside frames; may terminate with **ERR**                                                                | 3.4.3      | Insert IDLE mid-frame → drop; inject ERR → abort.           |
| B-10 | Timeout/abort policy: reads → **all-ones**, partial writes not committed                                                           | 3.4.3      | Stall device; verify CPU-side result and no writes applied. |
| B-11 | Interrupt routing per-slot; CPU **/CPU_ACK** handling                                                                              | 3.7, 3.9   | Assert device line; see CPU interrupt; observe ack flow.    |
| B-12 | Mode-2: identify asserting slot; hold `/CS`; assert slot **/INT_ACK**; issue vector read (`CONTROL=0x01`,`ADDR=0x00`,`FLAGS=0x00`) | 3.7        | Logic trace of ack cycle; capture request frame.            |
| B-13 | Multiple claimants: return **0xFF** (don’t query any slot)                                                                         | 3.7        | Two devices assert same channel; check CPU-side vector.     |
| B-14 | NMI not vectored; don’t attempt vector read                                                                                        | 3.7        | NMI test; confirm no Serial vector transaction.             |
| B-15 | Inter-half timeout **T_ifg ≥ 64 UI** (recommended)                                                                                 | 3.6        | Stall between halves; confirm abort behavior.               |