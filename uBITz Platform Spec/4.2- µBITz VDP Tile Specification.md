
# µBITz VDP Tile Specification v1.0

## Video Display Processor for µBITz Platform

**Status:** Draft v1.0

**Date:** 2025

**Function:** VIDEO (0x01)

---

# Part 0 — Overview and Architecture

## 0.1 What is µBITz VDP Tile?

The µBITz VDP Tile is a **programmable video display processor** designed as a µBITz Tile peripheral device. It is built on top of the Media Versatile Tile design. It provides modern graphics capabilities with a retro-friendly register interface, enabling both classic video display emulation and contemporary visual effects.

**Key Characteristics:**
- **True retro interface**: Register-based VDP model (no direct VRAM access)
- **Modern capabilities**: RGB888 framebuffer, 256 sprites, programmable effects
- **CPU-agnostic**: Works with any µBITz Host (Z80, RISC-V, 6502, 68000, etc.)
- **Programmable FX Core**: Soft RISC-V core for custom effects instead of fixed logic
- **Self-contained**: Private 256MB DDR3 memory, no system RAM sharing
- **Deterministic timing**: Predictable scanout, no race conditions

---

## 0.2 Design Philosophy

### 0.2.1 VDP Heritage

The VDP Tile follows the classic Video Display Processor model pioneered by chips like the TMS9918, V9938, and SNES PPU:

- **Register-based control**: CPU programs VDP via I/O registers
- **Private memory**: VDP owns all graphics memory (CPU cannot access directly)
- **Autonomous operation**: VDP generates video independently; CPU only configures
- **Predictable timing**: VBlank/HBlank windows for safe updates

**Modern enhancements:**
- Programmable effects core (RISC-V) instead of fixed copper logic
- True-color framebuffer alongside indexed sprites
- Hardware blitter for fast fills/copies
- Flexible palette system with per-scanline updates

### 0.2.2 Design Principles

1. **CPU Independence**
    - Works with any µBITz Host CPU
    - Same register interface across all platforms
    - No CPU-specific optimizations required
2. **Memory Protection**
    - CPU cannot corrupt VRAM directly
    - All updates via register interface or DMA
    - Prevents timing-sensitive bugs
3. **Programmability**
    - User-uploadable FX code (RISC-V)
    - Standard C toolchain
    - Library of common effects
4. **Deterministic Operation**
    - Predictable VBlank/HBlank windows
    - Configurable safety modes
    - Cycle budgets for FX code
5. **Hobbyist Accessibility**
    - ~$75-85 BOM cost
    - Hand-solderable FPGA package
    - Comprehensive documentation
    - Open-source design

---

## 0.3 System Architecture

```
┌─────────────────────────────────────────────────────────┐
│                  µBITz VDP TILE                         │
│                                                         │
│  ╔═══════════════════════════════════════╗              │
│  ║  µBITz Dock Connector                 ║              │
│  ║  - Parallel or Serial Profile         ║              │
│  ╚═══════════════╦═══════════════════════╝              │
│                  ║                                      │
│  ┌───────────────▼───────────────────────┐             │
│  │    µBITz Dock Interface Logic         │             │
│  │  - /CS decode                         │             │
│  │  - /IORQ handling                     │             │
│  │  - /READY generation                  │             │
│  │  - Register bank (32 registers)       │             │
│  └───────────────┬───────────────────────┘             │
│                  │                                     │
│  ┌───────────────▼───────────────────────┐             │
│  │         FPGA Core                     │             │
│  │  (Xilinx Artix-7 XC7A50T)             │             │
│  │                                       │             │
│  │  ┌─────────────────────────────────┐  │             │
│  │  │   Display Timing (800×600)      │  │             │
│  │  └─────────────┬───────────────────┘  │             │
│  │                │                      │             │
│  │  ┌─────────────▼───────────────────┐  │             │
│  │  │   Scanout Engine                │  │             │
│  │  │   - Line buffers (RGB888)       │  │             │
│  │  │   - Pixel pipeline              │  │             │
│  │  └─────────────┬───────────────────┘  │             │
│  │                │                      │             │
│  │  ┌─────────────▼───────────────────┐  │             │
│  │  │   Object Engine                 │  │             │
│  │  │   - 256 objects @ 64×64         │  │             │
│  │  │   - 48/scanline limit           │  │             │
│  │  │   - 8bpp indexed color          │  │             │
│  │  └─────────────┬───────────────────┘  │             │
│  │                │                      │             │
│  │  ┌─────────────▼───────────────────┐  │             │
│  │  │   Compositor                    │  │             │
│  │  │   - Blend BG + sprites          │  │             │
│  │  │   - CLUT lookup (4 banks)       │  │             │
│  │  └─────────────┬───────────────────┘  │             │
│  │                │                      │             │
│  │  ┌─────────────▼───────────────────┐  │             │
│  │  │   Blitter Core (RISC-V)         │  │             │
│  │  │   - Fixed firmware              │  │             │
│  │  │   - Rect fill, copy, line       │  │             │
│  │  └─────────────────────────────────┘  │             │
│  │                                       │             │
│  │  ┌─────────────────────────────────┐  │             │
│  │  │   FX Core (RISC-V)              │  │             │
│  │  │   - User programmable           │  │             │
│  │  │   - Copper-like effects         │  │             │
│  │  │   - Palette cycling, parallax   │  │             │
│  │  └─────────────────────────────────┘  │             │
│  │                                       │             │
│  │  ┌─────────────────────────────────┐  │             │
│  │  │   DDR3 Memory Controller        │  │             │
│  │  │   - Xilinx MIG                  │  │             │
│  │  └─────────────┬───────────────────┘  │             │
│  └────────────────┼──────────────────────┘             │
│                   │                                    │
│  ┌────────────────▼──────────────────────┐             │
│  │    DDR3 SDRAM (256MB)                 │             │
│  │    MT41K128M16JT-125                  │             │
│  │    - Framebuffer                      │             │
│  │    - Object tiles                     │             │
│  │    - FX program storage               │             │
│  └───────────────────────────────────────┘             │
│                                                        │
│  ┌───────────────────────────────────────┐             │
│  │      DVI Encoder (TFP410PAP)          │             │
│  └──────────────┬────────────────────────┘             │
│                 │                                      │
│           ┌─────▼──────┐                               │
│           │ HDMI/DVI   │ ← Card edge                   │
│           │ Output     │                               │
│           └────────────┘                               │
│                                                        │
│  INT_CH[0] ──────────────────────────────► VBlank IRQ  │
│                                                        │
│  [PWR] [ACT] [VSYNC] [ERR] ← Status LEDs               │
└────────────────────────────────────────────────────────┘
```

---

## 0.4 Feature Summary

### Display Output

- **Resolution:** 800×600 @ 60Hz (VESA standard)
- **Pixel clock:** 40 MHz
- **Output:** DVI/HDMI via TMDS
- **Sync:** Standard VESA timings (H: 128px, V: 4 lines)
- **Latency:** 1-line pipeline (scanout → blend → TMDS)

### Color and Framebuffer

- **Background layer:** RGB888 (true color) framebuffer
- **Objects/sprites:** 8bpp indexed into CLUT
- **CLUT:** 4 banks × 256 entries × 24-bit
    - Bank 0: Background palette
    - Bank 1-2: Object palettes
    - Bank 3: FX/effects palette
- **Palette updates:** Per-scanline or mid-scanline (via FX Core)

### Object Engine (Sprites)

- **Total objects:** 256 in Object Attribute Memory (OAM)
- **Per scanline:** Up to 48 visible (after culling)
- **Sizes:** 8×8, 16×16, 32×32, 64×64 (power-of-two)
- **Format:** 8bpp indexed color
- **Features:**
    - Per-object palette bank selection
    - Priority (Z-order)
    - Horizontal/vertical flip
    - Transparent color (key)
    - Alpha blending (0%, 50%, 100%)

### Programmable Cores

**Blitter Core (Fixed Firmware):**
- Rectangle fill
- Rectangle copy (with transparency)
- Line drawing
- Box drawing
- 8bpp↔︎8bpp and 8bpp→24bpp expansion

**FX Core (User Programmable):**
- Soft RISC-V processor
- Upload custom code via registers
- Effects library: copper, palette cycling, raster bars, parallax, sprite multiplex, etc.
- Deterministic modes:
- Safe-window (HBlank/VBlank only)
- Budgeted (N cycles/line)
- Free-run (developer responsibility)
- Debug: cycle counter, UART printf, trace FIFO

### Memory Architecture

- **External DDR3:** 256MB (MT41K128M16JT-125)
- **DDR3-400:** 800 MT/s, 1.6 GB/s theoretical
- **Usage:**
    - Framebuffer: ~1.44 MB (RGB888, 800×600)
    - Double-buffer: Optional +1.44 MB
    - Object tiles: Configurable (few MB)
    - FX program: 64 KB per user program
    - Staging: Ring buffers
- **On-FPGA BRAM:** CLUTs, line FIFOs, FX/Blitter scratch

### Host Interface

- **Function:** VIDEO (0x01)
- **Bus width:** 8-bit data (retro-friendly)
- **Registers:** 32 addressable via A[4:0]
- **Control pins:** CS#, R/W#, /IORQ, /READY, INT_CH[0]
- **Timing:** Asynchronous with /READY stretch
- **Interrupt:** VBlank on INT_CH[0] (Mode-2 compatible)

---

## 0.5 Compliance and Compatibility

### µBITz Dock Compliance

The VDP Tile is a conformant µBITz Dock peripheral device and MUST:

- Provide valid Device Descriptor via I²C EEPROM (address 0x52-0x55)
- Declare Function=VIDEO (0x01), Instance=0
- Support declared AddressBusWidth and DataBusWidth from CPU
- Implement register interface per µBITz Core specification
- Handle /IORQ qualification and /READY stretching
- Drive INT_CH[0] per open-drain requirements
- Support Mode-2 interrupt acknowledge (vector at ADDR=0x00)

### Profile Support

**Parallel Profile (Primary):**
- Full A[7:0], D[7:0] exposure
- Direct register access
- Recommended for prototyping

**Serial Profile (Future):**
- Framed LVDS transport
- Parity-10 encoding
- Requires carrier board

---

## 0.6 Development Targets

### Prototyping Platform

- **Board:** QMTech Artix-7 XC7A100T
- **Advantages:** On-board DDR3, 104 I/O, JTAG
- **Use:** Development, testing, validation
- **Cost:** ~$100 (already owned)

### Production Platform

- **FPGA:** Xilinx Artix-7 XC7A50T-FGG256
- **Package:** 17×17mm, 1mm pitch (hand-solderable)
- **Utilization:** 37% LUT, 15% FF, 89% BRAM
- **Cost:** ~$40 (single), ~$28 (qty 100)
- **BOM:** $73-78 complete card

---

## 0.7 Document Structure

This specification consists of:

**Part 0:** Overview and Architecture (this document)
**Part 1:** Register Map and Programming Model
**Part 2:** Memory Organization and DMA
**Part 3:** Display Timing and Video Output
**Part 4:** Object Engine and Sprites
**Part 5:** FX Core and Programmability
**Part 6:** Hardware Design and BOM
**Part 7:** Software Development Guide

---

# Part 1 — Register Map and Programming Model

## 1.1 Scope

This Part defines the software-visible interface to the µBITz VDP Tile: register addresses, bit layouts, access semantics, and programming patterns.

---

## 1.2 Register Organization

The VDP exposes **32 registers** via µBITz Dock addressing:

**Base Address:** Assigned by CPU WindowMap (example: IOWin=0xD0)
**Address Range:** Base + 0x00 through Base + 0x1F
**Access Width:** 8-bit data bus (D[7:0])
**Addressing:** A[4:0] selects register

---

## 1.3 Register Map Summary

```
Address   Name                R/W   Description
─────────────────────────────────────────────────────────────
0x00      DATA_PORT           R/W   Sequential VRAM access
0x01      ADDR_LO             W     VRAM address bits [7:0]
0x02      ADDR_HI             W     VRAM address bits [15:8]
0x03      ADDR_HI2            W     VRAM address bits [23:16]
0x04      STATUS              R     VDP status flags
0x05      CONTROL             W     VDP control register

0x06      R0_MODE1            W     Mode control 1
0x07      R1_MODE2            W     Mode control 2
0x08      R2_FB_BASE_HI       W     Framebuffer base (high)
0x09      R3_FB_BASE_LO       W     Framebuffer base (low)
0x0A      R4_OBJ_PAT_HI       W     Object pattern base (high)
0x0B      R5_OBJ_PAT_LO       W     Object pattern base (low)
0x0C      R6_OAM_BASE_HI      W     OAM base (high)
0x0D      R7_OAM_BASE_LO      W     OAM base (low)
0x0E      R8_SCROLL_X_LO      W     Scroll X (low byte)
0x0F      R9_SCROLL_X_HI      W     Scroll X (high byte)
0x10      R10_SCROLL_Y_LO     W     Scroll Y (low byte)
0x11      R11_SCROLL_Y_HI     W     Scroll Y (high byte)

0x12      CLUT_BANK           W     CLUT bank select (0-3)
0x13      CLUT_INDEX          W     CLUT entry index (0-255)
0x14      CLUT_DATA_R         W     CLUT red component
0x15      CLUT_DATA_G         W     CLUT green component
0x16      CLUT_DATA_B         W     CLUT blue component

0x17      BLIT_CMD            W     Blitter command
0x18      BLIT_SRC_LO         W     Blitter source (low)
0x19      BLIT_SRC_HI         W     Blitter source (high)
0x1A      BLIT_DST_LO         W     Blitter destination (low)
0x1B      BLIT_DST_HI         W     Blitter destination (high)
0x1C      BLIT_WIDTH          W     Blitter width
0x1D      BLIT_HEIGHT         W     Blitter height

0x1E      FX_CONTROL          W     FX Core control
0x1F      FX_STATUS           R     FX Core status
```

---

## 1.4 Register Descriptions

### 0x00: DATA_PORT (R/W)

**Purpose:** Sequential VRAM access port

**Write Operation:**
- Write data byte to VRAM at current address
- Address auto-increments after write
- Used for uploading sprites, framebuffer data, etc.

**Read Operation:**
- Read data byte from VRAM at current address
- Address auto-increments after read

**Example (Z80):**

```nasm
; Upload 256 bytes to VRAM
LD   HL, source_data
LD   B, 0               ; 256 iterations
                        ; Set destination address first (see ADDR_LO/HI)
LD   A, 0x00
OUT  (VDP_ADDR_LO), A
OUT  (VDP_ADDR_HI), A

.loop:
    LD   A, (HL)
    OUT  (VDP_DATA), A  ; Auto-increments address
    INC  HL
    DJNZ .loop
```

---

### 0x01-0x03: ADDR_LO/HI/HI2 (W)

**Purpose:** Set VRAM address for DATA_PORT access

**Address Range:** 24-bit (16MB address space)
- ADDR_LO: Bits [7:0]
- ADDR_HI: Bits [15:8]
- ADDR_HI2: Bits [23:16]

**Usage:**

```nasm
; Set address to 0x012345
LD   A, 0x45OUT  (VDP_ADDR_LO), A
LD   A, 0x23OUT  (VDP_ADDR_HI), A
LD   A, 0x01OUT  (VDP_ADDR_HI2), A
```

---

### 0x04: STATUS (R)

**Purpose:** Read VDP status flags

```
Bit 7: VBlank       (1 = in vertical blanking)
Bit 6: HBlank       (1 = in horizontal blanking)
Bit 5: Sprite overflow (>48 sprites on scanline)
Bit 4: Sprite collision (sprites overlapped)
Bit 3: Command busy (blitter/FX executing)
Bit 2: FIFO full
Bit 1: VRAM ready (1 = can access)
Bit 0: Frame parity (toggles each frame)
```

**Usage:**

```nasm
; Wait for VBlank
.wait:    
	IN   A, (VDP_STATUS)
	BIT  7, A
    JR   Z, .wait
```

---

### 0x05: CONTROL (W)

**Purpose:** VDP control register

```
Bit 7: Display enable (0=blank, 1=active)
Bit 6: VBlank IRQ enable
Bit 5: Sprites enable
Bit 4: Background enable
Bit 3-0: Reserved (write 0)
```

---

### 0x06-0x11: R0-R11 (Internal Registers)

Direct register access for common VDP parameters.

**R0 (0x06): Mode Control 1**
- Same as CONTROL register (alternate access)

**R2/R3 (0x08-0x09): Framebuffer Base**
- 16-bit address (×256 bytes)
- Points to RGB888 framebuffer start in VRAM

**R4/R5 (0x0A-0x0B): Object Pattern Base**
- Points to sprite tile data in VRAM

**R6/R7 (0x0C-0x0D): OAM Base**
- Points to Object Attribute Memory

**R8-R11 (0x0E-0x11): Scroll X/Y**
- 16-bit scroll offsets for background layer

---

### 0x12-0x16: CLUT (Palette) Access

**CLUT_BANK (0x12):**
- Select palette bank (0-3)

**CLUT_INDEX (0x13):**
- Select palette entry (0-255)

**CLUT_DATA_R/G/B (0x14-0x16):**
- Write RGB components (8-bit each)

**Example:**

```nasm
; Set bank 0, entry 5 to red (0xFF0000)
LD   A, 0
OUT  (VDP_CLUT_BANK), A
LD   A, 5
OUT  (VDP_CLUT_INDEX), A
LD   A, 0xFF
OUT  (VDP_CLUT_DATA_R), A
XOR  A
OUT  (VDP_CLUT_DATA_G), A
OUT  (VDP_CLUT_DATA_B), A
```

---

### 0x17-0x1D: Blitter Registers

**BLIT_CMD (0x17):**

```
Bit 7: GO (1=start operation)
Bits 6-4: Operation
  000 = Fill
  001 = Copy
  010 = Transparent copy
  011 = Line
  100 = Box
Bits 3-0: Flags (transparent color, etc.)
```

**BLIT_SRC/DST (0x18-0x1B):**
- 16-bit source/destination addresses

**BLIT_WIDTH/HEIGHT (0x1C-0x1D):**
- Operation dimensions

**Example:**

```nasm
; Fill 64×64 rectangle at 0x1000 with color 5
LD   A, 0x00
OUT  (VDP_BLIT_SRC_LO), A
OUT  (VDP_BLIT_SRC_HI), A  ; Source = color index
LD   A, 0x00
OUT  (VDP_BLIT_DST_LO), A
LD   A, 0x10
OUT  (VDP_BLIT_DST_HI), A  ; Dest = 0x1000
LD   A, 64
OUT  (VDP_BLIT_WIDTH), A
OUT  (VDP_BLIT_HEIGHT), A
LD   A, 0x80               ; GO | FILL
OUT  (VDP_BLIT_CMD), A
```

---

### 0x1E-0x1F: FX Core Registers

**FX_CONTROL (0x1E):**

```
Bit 7: Run (1=execute, 0=halt)
Bit 6: Reset core
Bit 5-4: Safety mode
  00 = Safe-window (HBlank/VBlank only)
  01 = Budgeted (cycle limit per line)
  10 = Free-run
Bits 3-0: Reserved
```

**FX_STATUS (0x1F):**

```
Bit 7: Running
Bit 6: Halted (error or completion)
Bit 5: Uploading (code transfer in progress)
Bit 4-0: Error code (if halted)
```

---

## 1.5 Programming Patterns

### Pattern 1: Initialize VDP

```c
void vdp_init(void) {
    // Disable display    
    VDP_CONTROL = 0x00;    
    // Set framebuffer base at 0x000000    
    VDP_R2_FB_BASE_HI = 0x00;    
    VDP_R3_FB_BASE_LO = 0x00;    
    // Set object pattern base at 0x100000    
    VDP_R4_OBJ_PAT_HI = 0x10;    
    VDP_R5_OBJ_PAT_LO = 0x00;    
    // Set OAM base at 0x200000    
    VDP_R6_OAM_BASE_HI = 0x20;    
    VDP_R7_OAM_BASE_LO = 0x00;    
    // Clear scroll    
    VDP_R8_SCROLL_X_LO = 0;    
    VDP_R9_SCROLL_X_HI = 0;    
    VDP_R10_SCROLL_Y_LO = 0;    
    VDP_R11_SCROLL_Y_HI = 0;    
    // Enable display + sprites + BG + VBlank IRQ    
    VDP_CONTROL = 0xF0;
}
```

### Pattern 2: Wait for VBlank

```nasm
; Z80 wait_vblank:

.loop:
    IN   A, (VDP_STATUS)
    BIT  7, A
    JR   Z, .loop
    RET
; Clear VBlank flag by reading    
    IN   A, (VDP_STATUS)
```

### Pattern 3: Upload Sprite Data

```c
void vdp_upload_sprite(uint8_t sprite_num,
                       const uint8_t* data,
                       uint16_t size) {    // Calculate VRAM address    uint32_t addr = 0x100000 + (sprite_num * 4096);    // Set address    VDP_ADDR_LO = addr & 0xFF;    VDP_ADDR_HI = (addr >> 8) & 0xFF;    VDP_ADDR_HI2 = (addr >> 16) & 0xFF;    // Upload data    for (uint16_t i = 0; i < size; i++) {        VDP_DATA_PORT = data[i];    }}
```

### Pattern 4: Update OAM Entry

```c
typedef struct {    int16_t x;    int16_t y;    uint8_t width_code;   // 0=8×8, 1=16×16, 2=32×32, 3=64×64    uint8_t height_code;    uint16_t pattern_addr;    uint8_t priority;    uint8_t flags;        // flip, transparency, etc.} OAMEntry;void vdp_update_oam(uint8_t obj_num, const OAMEntry* obj) {    uint32_t addr = 0x200000 + (obj_num * 12);    VDP_ADDR_LO = addr & 0xFF;    VDP_ADDR_HI = (addr >> 8) & 0xFF;    VDP_ADDR_HI2 = (addr >> 16) & 0xFF;    VDP_DATA_PORT = obj->x & 0xFF;    VDP_DATA_PORT = (obj->x >> 8) & 0xFF;    VDP_DATA_PORT = obj->y & 0xFF;    VDP_DATA_PORT = (obj->y >> 8) & 0xFF;    VDP_DATA_PORT = (obj->width_code << 4) | obj->height_code;    VDP_DATA_PORT = obj->pattern_addr & 0xFF;    VDP_DATA_PORT = (obj->pattern_addr >> 8) & 0xFF;    VDP_DATA_PORT = obj->priority;    VDP_DATA_PORT = obj->flags;}
```

---

## 1.6 Interrupt Handling

### VBlank Interrupt (INT_CH[0])

The VDP asserts INT_CH[0] at the start of VBlank period.

**Mode-2 (Z80):**

```nasm
; Setupsetup_interrupts:    LD   A, HIGH(vector_table)    LD   I, A
    IM   2    EI
    RET; Vector table (256-byte aligned)vector_table:    DS   256; VDP returns vector index 0x10    ORG  vector_table + 0x10    DW   vblank_handler
; ISRvblank_handler:    PUSH AF
    PUSH HL
    ; Read STATUS to acknowledge    IN   A, (VDP_STATUS)    ; Update graphics during VBlank    CALL update_sprites
    CALL update_palette
    ; Set frame ready flag    LD   A, 1    LD   (frame_ready), A
    POP  HL
    POP  AF
    EI
    RETI
```

**Polling Mode:**

```nasm
game_loop:    ; Wait for VBlank    CALL wait_vblank
    ; Update during VBlank window    CALL update_graphics
    ; Game logic    CALL process_input
    CALL update_physics
    JR   game_loop
```

---

---

## Appendix A: Quick Reference

### A.1 Register Quick Reference

```
0x00  DATA       Sequential VRAM access
0x01  ADDR_LO    VRAM address [7:0]
0x02  ADDR_HI    VRAM address [15:8]
0x03  ADDR_HI2   VRAM address [23:16]
0x04  STATUS     VDP status (read-only)
0x05  CONTROL    VDP control
0x12  CLUT_BANK  Palette bank (0-3)
0x13  CLUT_INDEX Palette entry (0-255)
0x14  CLUT_R     Red (0-255)
0x15  CLUT_G     Green (0-255)
0x16  CLUT_B     Blue (0-255)
0x17  BLIT_CMD   Blitter command
0x1E  FX_CTRL    FX Core control
0x1F  FX_STATUS  FX Core status
```

### A.2 Memory Map Quick Reference

```
0x000000  Framebuffer (RGB888, 1.44MB)
0x100000  Object tiles (configurable)
0x200000  OAM (256 entries × 12 bytes)
0x300000  FX program storage (64KB)
0x400000+ Free space
```

### A.3 Pinout Quick Reference (FGG256)

See detailed pinout table in schematic documentation.

**Critical pins:**
- DDR3: Banks 34, 35
- HDMI: Bank 16
- µBITz Interface: Bank 14
- Configuration: Bank 0

---

*This specification is released as open-source hardware under the CERN-OHL-S v2 license. Builders may manufacture for personal use or small-scale distribution.*