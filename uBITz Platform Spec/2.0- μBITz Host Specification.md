#  μBITz Host Specification v1.0 (Draft)

**Status:** Draft 0.1  
**Audience:** Hardware/FPGA designers, platform implementers, emulator authors  
**Normativity:** Sections marked “Requirements” are normative for v1.0. Examples and annexes are informative.

---

## 0. Scope and Context

### 0.1 Purpose

The **μBITz Host** is the CPU board. It implements the platform personality (C64, Apple II, ZX Spectrum, etc.), generates all bus timing, and presents a clean logical view of memory and I/O to the rest of the μBITz Platform. 

This document defines:

- The **logical contracts** between a Host and:
  - μBITz Bank (memory subsystem)
  - μBITz Dock (I/O subsystem)
- The **address space model** and the required “Address Space Mapper” block
- The **CPU Descriptor** format and required fields
- Timing, `/READY`, and interrupt behavior from the Host’s point of view

It does **not** define any particular CPU core; those are provided as separate reference implementations (e.g., “Z80 Core Host”, “6502 C64 Host”, “68000 Host”).

### 0.2 Dependencies

This specification relies on and refines:

- **μBITz Platform Specification v1.0** (overall architecture, enumeration, profiles) 
- **μBITz Bank Specification v1.0** (memory behavior and timing)
- **μBITz Dock Specification v1.0** (I/O routing, windows, interrupts)

If conflicts arise, the Platform specification takes precedence; this Host spec should then be updated to match.

### 0.3 Design Goals

The Host spec is designed to:

1. Allow wildly different CPUs (Z80, 6502, 68000, RISC-V, etc.) to share a **single** μBITz Dock & Bank ecosystem.
2. Make Bank, Dock and Tile cards **simple**: each sees a 0-based address space selected by control signals, not raw CPU addresses.
3. Keep all “platform personality” quirks (C64 shadows, Apple II soft switches, Spectrum ULA weirdness, etc.) on the Host, not in generic Tiles.
4. Support 8/16/32-bit address and data widths with clear negotiation rules. 

---

## 1. Host Role and Responsibilities

### 1.1 Role (Summary)

A **μBITz Host**:

- Executes the platform CPU instruction set.
- Generates all bus timing and control signals.
- Implements platform-specific chipset logic (interrupt controllers, timers, DMA, etc.).
- Provides a CPU Descriptor via I²C EEPROM at address `0x50`, declaring its capabilities and preferences.   

### 1.2 Responsibilities (Requirements)

A v1.0-compliant μBITz Host **MUST**:

1. Provide a valid CPU Descriptor (see §4).
2. Declare:
   - `AddressBusWidth` ∈ {8, 16, 32}
   - `DataBusWidth` ∈ {8, 16, 32}
   - `IntAckMode`
   - `WindowMap[]` (I/O mapping policy)
   - `IntRouting[]` (interrupt routing policy)   
3. Generate all required control signals for:
   - **Memory operations** toward μBITz Bank
   - **I/O operations** toward μBITz Dock
4. Implement an **Address Space Mapper** that converts CPU addresses into:
   - A selected **logical space**: RAM, ROM, or IO
   - A **0-based offset** within that space
   - Corresponding control signals (`/MREQ`, `/IORQ`, `/RAMSEL`, `/ROMSEL`, etc.)
1. Handle `/READY` stretching from Bank/Dock with a defined timeout policy.   
2. Implement the declared `IntAckMode` (e.g., Mode-2 style vectored acknowledge) where applicable.   

Informative: A Host may also include debug headers, watchdogs, and other nice-to-haves; Platform Appendix B already sketches recommended design guidelines. 

---

## 2. External Interfaces

This section defines the **logical** interfaces. Physical pin-maps and profile-specific electrical details are defined in the Dock/Bank specs.

### 2.1 CPU-Side Interface (Informative)

The specifics of the CPU-local bus (PHI2, /AS, /DTACK, etc.) are implementation-defined. The Host is responsible for:

- Adapting the CPU’s native bus to the μBITz logical signals
- Meeting all timing constraints of the chosen CPU

Implementers are encouraged to isolate CPU signals into an internal **Core** block and a **Host Bridge** block that drives the μBITz side.

### 2.2 μBITz Memory Interface (Host → Bank)

From the Bank’s perspective, the Host exposes a **logical memory space** which is already separated into RAM vs ROM via control signals and 0-based offsets.   

**Key Signals (logical):**

- `A[AddressBusWidth-1:0]`  
  0-based **offset** within the selected memory space (RAM or ROM).
- `D[DataBusWidth-1:0]` (bidirectional)
- `/MREQ` – Memory request qualifier
- `R/W_` – 1 = read, 0 = write
- `/RAMSEL` – Active-low RAM space select
- `/ROMSEL` – Active-low ROM space select
- `/READY` – Ready/wait indication from Bank to Host

**Requirements:**

1. For any **memory** cycle issued toward the Bank:
   - Exactly one of `/RAMSEL`, `/ROMSEL` **MUST** be asserted low.
   - `A[]` **MUST** be a 0-based offset within the corresponding space, independent of the CPU’s 
1. The Bank **MUST NOT** see raw CPU addresses; all base-of-window subtraction/masking is the Host’s responsibility.
2. The Host **MUST** sample `/READY` and extend the CPU cycle appropriately when slow memory is in use.

### 2.3 μBITz I/O Interface (Host → Dock)

From the Dock’s perspective, the Host exposes I/O transactions that are already classified as **I/O space** with a 0-based offset. The Dock then maps these into windows and routes them to slots.  

**Key Signals (logical):**

- `A[AddressBusWidth-1:0]` – 0-based I/O address (offset in IO space)
- `D[DataBusWidth-1:0]`
- `/IORQ` – I/O request qualifier
- `R/W_` – 1 = read, 0 = write
- `/CPU_ACK[3:0]` – Interrupt acknowledge lines (when vectored)
- `/READY` – Ready/wait from Dock to Host
- `CPU_INT[3:0]`, `CPU_NMI[3:0]` – Interrupt inputs from Dock

**Requirements:**

1. For any **I/O** cycle:
   - `/IORQ` **MUST** be asserted.
   - `A[]` **MUST** be a 0-based I/O address; any platform-specific address (e.g., `$D000` on a C64, `$FE` on a Spectrum) is mapped down inside the Host.   
1. The Host **MUST** implement `/CPU_ACK[k]` behavior consistent with its declared `IntAckMode` when the platform uses vectored interrupts.
2. The Host **MUST** honor `/READY` from the Dock and extend CPU cycles or insert wait states.

### 2.4 Management / Descriptor Interface

The Host exposes a read-only **CPU Descriptor EEPROM** at I²C address `0x50`.   

The backplane (or minimal-profile supervisor) reads this during enumeration to:

- Learn CPU type and widths
- Validate compatibility with Bank and Dock
- Build I/O and interrupt routing tables

Descriptor contents are described in §4.

---

## 3. Address Space Model

### 3.1 Logical Spaces

μBITz defines three **logical address spaces**:

1. **RAM space** – `0x0000 … RAM_MAX`
2. **ROM space** – `0x0000 … ROM_MAX`
3. **IO space** – `0x0000 … IO_MAX`   

These spaces are distinguished not by high bits of the address, but by **control signals**:

- RAM: `/MREQ` + `/RAMSEL = 0`
- ROM: `/MREQ` + `/ROMSEL = 0`
- IO: `/IORQ = 0` (and all memory selects inactive)   

**Requirement:**  
The Host **MUST** ensure that Bank and Dock only ever see these 0-based offsets and space selects, never raw CPU addresses.

### 3.2 Address Space Mapper (Core Block)

Each Host **MUST** implement an internal **Address Space Mapper**:

```text
Inputs:
  CPU_A[N:0], CPU_R/W_, clock/qualifier (e.g., PHI2, /AS, etc.)

Outputs (to μBITz side):
  UBITZ_A[AddressBusWidth-1:0]    -- offset
  /MREQ, /IORQ
  /RAMSEL, /ROMSEL                -- or equivalent encoded space ID
  /READY                          -- returned to CPU
  ```
  
  The Mapper is responsible for:

1. Deciding **which space** (RAM/ROM/IO) a given CPU address belongs to, according to the platform personality.
    
2. Computing the 0-based **offset** within that space:
    
    - e.g., for a 6502 Host you might define:        
        - `$0000–$7FFF` → RAM, offset = `CPU_A[14:0]`            
        - `$8000–$80FF` → IO, offset = `CPU_A[7:0]`            
        - `$C000–$FFFF` → ROM, offset = `CPU_A[13:0]`
            
3. Asserting the proper combination of `/MREQ`, `/IORQ`, `/RAMSEL`, `/ROMSEL` lines.    
4. Passing `/READY` back to the CPU and inserting wait states as needed.
    

**Implementation Notes (Informative):**

- Typical implementations use a small CPLD (e.g., ATF22V10 / ATF1504, XC95xx) or tiny FPGA.    
- For “nice” map boundaries (4/8/16 KiB), the logic is mostly a handful of decoders and multiplexers.    

### 3.3 Platform Personalities

The **exact mapping** from CPU address to (Space, Offset) is platform-dependent and must be documented in that Host’s own notes / reference section.

Examples (informative, summarized from Platform Appendix A):

- C64-style (6502)
    
    - CPU sees RAM + ROM + IO at familiar locations (`$0000`, `$A000`, `$D000`, `$E000`).        
    - Host Mapper collapses those into the three 0-based spaces for the Bank/Dock.
        
- Apple II-style (6502)    
    - Soft switches and expansion ROM in `$C000–$CFFF` region.        
    - Host Mapper turns that into IO space windows.
        
- ZX48K-style (Z80)    
    - I/O registers at `$FE`, joystick at `$1F`.        
    - Host asserts `/IORQ` and presents small 0-based IO offsets to Dock.
        

Each concrete Host implementation **SHOULD** provide a small mapping table in its documentation (CPU address → Space → Dock offset) similar to the 6502 example above.

---

## 4. CPU Descriptor

### 4.1 Storage and Access

- Stored in an I²C EEPROM on the Host PCB at address `0x50`, write-protected in normal operation.
    
- Read during enumeration Phase 1.    
    μBITz Platform Specification v1…


### 4.2 Required Fields (Minimum v1.0)

A v1.0 Host **MUST** expose at least:

- `SpecVersion` – Host spec version (e.g., `0x0100` for 1.0)    
- `PlatformID` – ASCII tag (e.g., `"C64"`, `"APPLE2"`, `"ZX48K"`, `"CUSTOM32"`)    
- `CPUFamily` – Enumerated ID (Z80, 6502, 68000, RISC-V, etc.)    
- `AddressBusWidth` – 8 / 16 / 32 bits    
- `DataBusWidth` – 8 / 16 / 32 bits    
- `IntAckMode` – e.g.,    
    - `0x00` = no hardware ack (polling)        
    - `0x01` = Mode-2 style vectored ack    (Others reserved for future use.)
        
        μBITz Platform Specification v1…
        
- `WindowMap[]` – Default I/O windows (function + instance → I/O window/mask)    
- `IntRouting[]` – Default mapping (function + instance + channel → CPU_INT/CPU_NMI pin)
    

---

## 5. Timing and `/READY` Handling

### 5.1 General Rules

The Host is the **timekeeper** for the entire platform. Bank and Dock may add wait states via `/READY`, but they do not drive the CPU clock directly.

**Requirements:**

1. The Host **MUST** sample `/READY` at the appropriate point in the CPU cycle (implementation-dependent).    
2. When `/READY` is asserted (not ready):
    
    - The Host **MUST** stall the CPU bus cycle:        
        - Either by using the CPU’s native WAIT mechanism, or            
        - By stretching the relevant phase (e.g., PHI2 high, /AS low) as allowed by the CPU.
            
3. The Host **MUST** implement a timeout or watchdog policy for pathological cases (device never ready).

### 5.2 Memory Timing (Informative)

Platform Appendix B already sketches a typical timing diagram (e.g., 4 MHz Z80): T1/T2/T3 + optional Tw. Hosts may refer to that as a baseline.


---

## 6. Interrupt Handling

### 6.1 Inputs and Acknowledge

The Host exposes:

- `CPU_INT[3:0]` – Maskable interrupt inputs    
- `CPU_NMI[3:0]` – Non-maskable interrupt inputs    
- `/CPU_ACK[3:0]` – Per-channel acknowledge lines (where supported)    

The Dock routes per-slot interrupt channels (`INT_CH[3:0]`, `NMI_CH[3:0]`) onto these pins according to `IntRouting[]`.

### 6.2 Modes

- `IntAckMode = 0x00` (Polling)
    
    - Host never asserts `/CPU_ACK`.        
    - CPU services interrupts by polling status registers in Tiles.
        
- `IntAckMode = 0x01` (Mode-2 style vectored)

    - On interrupt, CPU performs a special vector read cycle.        
    - Host asserts `/CPU_ACK[k]`, `/IORQ`, `R/W_ = 1`, and samples an 8-bit vector index from `D[7:0]`.                
    - CPU jumps to `{VectorBase, VectorIndex}` as per its architecture.

Other modes are reserved for future versions and must not be used in v1.0 descriptors.

---

## 7. Compliance Checklist (v1.0)

A CPU board may call itself a **μBITz Host 1.0** if:

1. It provides a valid CPU Descriptor at `0x50` with all mandatory fields.        
2. It implements an Address Space Mapper that:    
    - Presents RAM/ROM/IO as separate spaces        
    - Provides 0-based offsets to Bank/Dock        
    - Never exposes raw CPU addresses to Bank/Dock.        
                
3. It generates `/MREQ`, `/IORQ`, `/RAMSEL`, `/ROMSEL`, `R/W_`, `A[]`, and `D[]` according to this specification.    
4. It implements `/READY` handling and any declared `IntAckMode`.    
5. It successfully passes the Platform enumeration and compatibility checks described in the μBITz Platform spec.


---

## Annex A: Example 6502 C64-Style Host (Informative)

This annex is non-normative and just illustrates how a concrete Host might implement a C64-style mapping using the μBITz Address Space Mapper. It is derived from the “address-decoder” discussion and the C64 memory map.

### A.1 CPU View (Simplified)

- `$0000–$9FFF` → main RAM    
- `$A000–$BFFF` → BASIC ROM (8 KiB)    
- `$C000–$CFFF` → RAM    
- `$D000–$DFFF` → IO + character ROM region    
- `$E000–$FFFF` → KERNAL ROM (8 KiB)    

### A.2 μBITz Interpretation

- **RAM space:** `0x0000…0xCFFF` (52 KiB), including “under ROM/IO” shadows.    
- **ROM space:** single ROM space with:    
    - BASIC at offset `0x0000`        
    - KERNAL at offset `0x2000`        
- **IO space:** `0x0000…0x0FFF` (4 KiB)    

The Address Space Mapper implements:

- Address decode on `CPU_A[15:0]` to select RAM/ROM/IO regions.    
- Offset calculation:    
    - RAM: `offset = CPU_A[14:0]` (for all RAM regions)        
    - IO: `offset = CPU_A[11:0]` (for `$D000–$DFFF`)        
    - ROM: `offset = CPU_A[13:0] - base_of_ROM_region`
        
- Space selects:    
    - RAM: `/RAMSEL = 0`, `/ROMSEL = 1`, `/IORQ = 1`, `/MREQ = 0`        
    - ROM: `/ROMSEL = 0`, `/RAMSEL = 1`, `/IORQ = 1`, `/MREQ = 0`        
    - IO: `/IORQ = 0`, `/MREQ = 1`, `/RAMSEL = 1`, `/ROMSEL = 1`
        

A small CPLD (ATF22V10/ATF1504/XC9572) is sufficient for this mapping.