#  μBITz Host Specification v1.0 (Draft)

**Status:** Draft 0.1  
**Audience:** Hardware/FPGA designers, platform implementers, emulator authors  
**Normativity:** Sections marked “Requirements” are normative for v1.0. Examples and annexes are informative.

---

## 0. Scope and Context

### 0.1 Purpose

The **μBITz Host** is the CPU board. It implements the platform personality (C64, Apple II, ZX Spectrum, etc.), generates all bus timing, and presents a clean logical view of memory and I/O to the rest of the μBITz Platform. 

This document defines:

- The **logical contracts** between a Host and:
  - μBITz Bank (memory subsystem)
  - μBITz Dock (I/O subsystem)
- The **address space model** and the required “Address Space Mapper” block
- The **CPU Descriptor** format and required fields
- Timing, `/READY`, and interrupt behavior from the Host’s point of view

It does **not** define any particular CPU core; those are provided as separate reference implementations (e.g., “Z80 Core Host”, “6502 C64 Host”, “68000 Host”).

### 0.2 Dependencies

This specification relies on and refines:

- **μBITz Platform Specification v1.0** (overall architecture, enumeration, profiles) 
- **μBITz Bank Specification v1.0** (memory behavior and timing)
- **μBITz Dock Specification v1.0** (I/O routing, windows, interrupts)

If conflicts arise, the Platform specification takes precedence; this Host spec should then be updated to match.

### 0.3 Design Goals

The Host spec is designed to:

1. Allow wildly different CPUs (Z80, 6502, 68000, RISC-V, etc.) to share a **single** μBITz Dock, Bank and Tile ecosystem.
2. Make Bank, Dock and Tile cards **simple**: devices see canonical μBITz bus cycles with Dock-provided chip-selects; a device may decode only low address bits as an internal offset (mirroring permitted).
3. Keep all “platform personality” quirks (C64 shadows, Apple II soft switches, Spectrum ULA weirdness, etc.) on the Host, not in generic Tiles.
4. Support 8/16/32-bit address and data widths with clear negotiation rules. 

---

## 1. Host Role and Responsibilities

### 1.1 Role (Summary)

A **μBITz Host**:

- Executes the platform CPU instruction set.
- Generates all bus timing and control signals.
- Implements platform-specific chipset logic (interrupt controllers, timers, DMA, etc.).
- Provides a CPU Descriptor via I²C EEPROM at address `0x50`, declaring its capabilities and preferences.   

### 1.2 Responsibilities (Requirements)

A v1.0-compliant μBITz Host **MUST**:

1. Provide a valid CPU Descriptor (see §4).
2. Declare:
   - `AddressBusWidth` ∈ {8, 16, 32}
   - `DataBusWidth` ∈ {8, 16, 32}
   - `IntAckMode`
   - `WindowMap[]` (I/O mapping policy)
   - `IntRouting[]` (interrupt routing policy)   
3. Generate all required control signals for:
   - **Memory operations** toward μBITz Bank
   - **I/O operations** toward μBITz Dock
4. Implement an **Address Space Mapper** that converts CPU addresses into:
   - A selected **logical space**: RAM, ROM, or IO
   - A canonical μBITz bus address on `A[]` (zero-extended as needed)
   - Corresponding control signals (`/MREQ`, `/IORQ`, `R/W_`, etc.)
1. Handle `/READY` stretching from Bank/Dock within the Host-declared `ReadyMaxuS` budget and tolerate platform-enforced timeout completion semantics.   
2. Implement the declared `IntAckMode` (e.g., Mode-2 style vectored acknowledge) where applicable.   

The Host **SHALL** drive raw CPU address onto `A[]` (zero-extended as needed) together with `/MREQ`, `/IORQ`, and `R/W_` as cycle qualifiers. The Host **SHALL NOT** drive `/MEM0_CS` or `/MEM1_CS` in the Dock-decoded model. The Host **SHALL** provide a CPU Descriptor sufficient for Dock decode (address width plus memory-map ranges and space IDs).

Informative: A Host may also include debug headers, watchdogs, and other nice-to-haves; Platform Appendix B already sketches recommended design guidelines. 

---

## 2. External Interfaces

This section defines the **logical** interfaces. Physical pin-maps and profile-specific electrical details are defined in the Dock/Bank specs.

### 2.1 CPU-Side Interface (Informative)

The specifics of the CPU-local bus (PHI2, /AS, /DTACK, etc.) are implementation-defined. The Host is responsible for:

- Adapting the CPU’s native bus to the μBITz logical signals
- Meeting all timing constraints of the chosen CPU

Implementers are encouraged to isolate CPU signals into an internal **Core** block and a **Host Bridge** block that drives the μBITz side.

### 2.2 μBITz Memory Interface (Host → Bank)

From the Bank’s perspective, the Host exposes canonical μBITz bus cycles separated into RAM vs ROM via Dock-provided chip-selects. Devices may internally decode only low address bits as offsets (mirroring permitted).   

**Key Signals (logical):**

- `A[AddressBusWidth-1:0]`  
  CPU/canonical address for the cycle (zero-extended as needed).
- `D[DataBusWidth-1:0]` (bidirectional)
- `/MREQ` – Memory request qualifier
- `R/W_` – 1 = read, 0 = write
- `/MEM0_CS` – Active-low ROM/RAM space select bit 1
- `/MEM1_CS` – Active-low ROM/RAM  space select bit 2
- `/READY` – Ready/wait indication from Bank to Host

The Dock derives `/MEM0_CS` and `/MEM1_CS` from Host-provided `A[]`, `/MREQ`, `/IORQ`, and `R/W_` when the Bank slot is selected.

**Requirements:**

1. For any **memory** cycle issued toward the Bank:
   - During Bank memory cycles (Bank selected, `/MREQ=0`, `/IORQ=1`), the Dock **MUST** drive `/MEM0_CS` and `/MEM1_CS` to indicate the selected Bank space. Otherwise, the Dock **MUST** drive `/MEM0_CS=/MEM1_CS=1` (inactive).
   - `A[]` **SHALL** carry the CPU/canonical address for the cycle (zero-extended as needed).
1. The Bank does not need to interpret the CPU memory map; it may decode only a subset of low address bits as an internal offset (mirroring permitted; see Bank spec).
2. The Host **MUST** sample `/READY` and extend the CPU cycle appropriately when slow memory is in use.
### 2.3 μBITz I/O Interface (Host → Dock)

From the Dock’s perspective, the Host exposes I/O transactions with canonical addresses; the Dock maps these into windows and routes them to slots.  

**Key Signals (logical):**

- `A[AddressBusWidth-1:0]` – CPU/canonical address for the cycle (zero-extended as needed)
- `D[DataBusWidth-1:0]`
- `/IORQ` – I/O request qualifier
- `R/W_` – 1 = read, 0 = write
- `/CPU_ACK` – Interrupt acknowledge lines (when vectored)
- `/READY` – Ready/wait from Dock to Host
- `CPU_INT[3:0]`, `CPU_NMI[1:0]` – Interrupt inputs from Dock

**Requirements:**

1. For any **I/O** cycle:
   - `/IORQ` **MUST** be asserted.
   - `A[]` **MUST** be a 0-based I/O address; any platform-specific address (e.g., `$D000` on a C64, `$FE` on a Spectrum) is mapped down inside the Host.   
1. The Host **MUST** implement `/CPU_ACK` behavior consistent with its declared `IntAckMode` when the platform uses vectored interrupts.
2. The Host **MUST** honor `/READY` from the Dock and extend CPU cycles or insert wait states.

### 2.4 Management / Descriptor Interface

The Host exposes a read-only **CPU Descriptor EEPROM** at I²C address `0x50`.   

The backplane (or minimal-profile supervisor) reads this during enumeration to:

- Learn CPU type and widths
- Validate compatibility with Bank and Dock
- Build I/O and interrupt routing tables

Descriptor contents are described in §4.

---

## 3. Address Space Model

### 3.1 Logical Spaces

μBITz defines five **logical address spaces**:

1. **RAM space** – `0x0000 … RAM_MAX`
2. **ROM space** 0 – `0x0000 … ROM1_MAX`
3. **ROM space** 1 – `0x0000 … ROM2_MAX`
4. **ROM space** 2 – `0x0000 … ROM3_MAX`
5. **IO space** – `0x0000 … IO_MAX`   

The different ROM spaces could be materialized by different ROM ICs and/or cartrige slot(s).

These spaces are distinguished not by high bits of the address, but by **control signals**:

- RAM: `/MREQ` + `/MEM0_CS = 0 + /MEM1_CS = 1`
- ROM 0: `/MREQ` + `/MEM0_CS = 1 + /MEM1_CS = 0`
- ROM 1: `/MREQ` + `/MEM0_CS = 0 + /MEM1_CS = 0`
- ROM 2: `/MREQ` + `/MEM0_CS = 1 + /MEM1_CS = 1`
- IO: `/IORQ = 0` (and all memory selects inactive)   

The Dock drives `/MEM0_CS` and `/MEM1_CS` according to these combinations when the Bank is selected.

**Requirement:**  
The Host **MUST** ensure that Bank and Dock only ever see canonical addresses on `A[]` with Dock-derived space selects; raw CPU addresses may be zero-extended as needed.

### 3.2 Address Space Mapper (Core Block)

Each Host **MUST** implement an internal **Address Space Mapper**:

```text
Inputs:
  CPU_A[N:0], CPU_R/W_, clock/qualifier (e.g., PHI2, /AS, etc.)

Outputs (to μBITz side):
  UBITZ_A[AddressBusWidth-1:0]    -- CPU/canonical address (zero-extended as needed)
  /MREQ, /IORQ
  /READY                          -- returned to CPU
  ```
  
  The Mapper is responsible for:

1. Deciding **which space** (RAM/ROM/IO) a given CPU address belongs to, according to the platform personality.
    
2. Computing the 0-based **offset** within that space:
    
    - e.g., for a 6502 Host you might define:        
        - `$0000–$7FFF` → RAM, offset = `CPU_A[14:0]`            
        - `$8000–$80FF` → IO, offset = `CPU_A[7:0]`            
        - `$C000–$FFFF` → ROM, offset = `CPU_A[13:0]`
            
3. Driving `/MREQ`, `/IORQ`, `R/W_`, and `A[]`; the Dock uses these to perform memory-space decode and drive `/MEM0_CS` and `/MEM1_CS` when the Bank is selected.    
4. Passing `/READY` back to the CPU and inserting wait states as needed.

The Host provides `A[]`, `/MREQ`, `/IORQ`, and `R/W_`. The Dock performs memory-space decode and drives `/MEM0_CS` and `/MEM1_CS` when the Bank is selected.

**Implementation Notes (Informative):**

- Typical implementations use a small CPLD (e.g., ATF22V10 / ATF1504, XC95xx) or tiny FPGA.    
- For “nice” map boundaries (4/8/16 KiB), the logic is mostly a handful of decoders and multiplexers.    

### 3.3 Platform Personalities

The **exact mapping** from CPU address to (Space, Offset) is platform-dependent and must be documented in that Host’s own notes / reference section.

Examples (informative, summarized from Platform Appendix A):

- C64-style (6502)
    
    - CPU sees RAM + ROM + IO at familiar locations (`$0000`, `$A000`, `$D000`, `$E000`).        
    - Host Mapper collapses those into the three 0-based spaces for the Bank/Dock.
        
- Apple II-style (6502)    
    - Soft switches and expansion ROM in `$C000–$CFFF` region.        
    - Host Mapper turns that into IO space windows.
        
- ZX48K-style (Z80)    
    - I/O registers at `$FE`, joystick at `$1F`.        
    - Host asserts `/IORQ` and presents small 0-based IO offsets to Dock.
        

Each concrete Host implementation **SHOULD** provide a small mapping table in its documentation (CPU address → Space → Dock offset) similar to the 6502 example above.

---

## 4. CPU Descriptor

### 4.1 Storage and Access

- Stored in an I²C EEPROM on the Host PCB at address `0x50`, write-protected in normal operation.
    
- Read during enumeration Phase 1.    
    μBITz Platform Specification v1…


### 4.2 Required Fields (Minimum v1.0)

A v1.0 Host **MUST** expose at least:

- `SpecVersion` – Host spec version (e.g., `0x0100` for 1.0)    
- `PlatformID` – ASCII tag (e.g., `"C64"`, `"APPLE2"`, `"ZX48K"`, `"CUSTOM32"`)    
- `CPUFamily` – Enumerated ID (Z80, 6502, 68000, RISC-V, etc.)    
- `AddressBusWidth` – 8 / 16 / 32 bits    
- `DataBusWidth` – 8 / 16 / 32 bits    
- `IntAckMode` – e.g.,    
    - `0x00` = no hardware ack (polling)        
    - `0x01` = Mode-2 style vectored ack    (Others reserved for future use.)
        
        μBITz Platform Specification v1…
        
- `ReadyMaxuS` – Maximum time the Dock/backplane may hold CPU-visible `/READY=0` for a single **Core I/O** cycle (`/IORQ=0`). Used by the Dock/backplane to bound wait-stretching and apply timeout completion.
- `WindowMap[]` – Default I/O windows (function + instance → I/O window/mask)    
- `IntRouting[]` – Default mapping (function + instance + channel → CPU_INT/CPU_NMI pin)
    

---

## 5. Timing and `/READY` Handling

### 5.1 General Rules

The Host is the **timekeeper** for the entire platform. Bank and Dock may add wait states via `/READY`, but they do not drive the CPU clock directly.

**Requirements:**

1. The Host **MUST** sample `/READY` at the appropriate point in the CPU cycle (implementation-dependent).    
2. When `/READY` is asserted (not ready):
    
    - The Host **MUST** stall the CPU bus cycle:        
        - Either by using the CPU’s native WAIT mechanism, or            
        - By stretching the relevant phase (e.g., PHI2 high, /AS low) as allowed by the CPU.
            
3. The Host **MUST** declare `ReadyMaxuS` in its CPU Descriptor and MUST tolerate platform-enforced timeout completion semantics (including reads returning all-ones accompanied by a timeout fault report).

### 5.2 Memory Timing (Informative)

Platform Appendix B already sketches a typical timing diagram (e.g., 4 MHz Z80): T1/T2/T3 + optional Tw. Hosts may refer to that as a baseline.


---

## 6. Interrupt Handling

### 6.1 Inputs and Acknowledge

The Host exposes:

- `CPU_INT[3:0]` – Maskable interrupt inputs    
- `CPU_NMI[1:0]` – Non-maskable interrupt inputs    
- `/CPU_ACK` – Per-channel acknowledge lines (where supported)    

The Dock routes per-slot interrupt channels (`INT_CH[1:0]`, `NMI_CH`) onto these pins according to `IntRouting[]`.

### 6.2 Modes

- `IntAckMode = 0x00` (Polling)
    
    - Host never asserts `/CPU_ACK`.        
    - CPU services interrupts by polling status registers in Tiles.
        
- `IntAckMode = 0x01` (Mode-2 style vectored)

    - On interrupt, CPU performs a special vector read cycle.        
    - Host asserts `/CPU_ACK`, `/IORQ`, `R/W_ = 1`, and samples an 8-bit vector index from `D[7:0]`.                
    - CPU jumps to `{VectorBase, VectorIndex}` as per its architecture.

Other modes are reserved for future versions and must not be used in v1.0 descriptors.

---

## 7. Compliance Checklist (v1.0)

A CPU board may call itself a **μBITz Host 1.0** if:

1. It provides a valid CPU Descriptor at `0x50` with all mandatory fields.        
2. It implements an Address Space Mapper that:    
    - Presents RAM/ROM/IO as separate spaces        
    - Provides canonical addresses on `A[]`        
    - Does not require pre-translation of `A[]` into 0-based offsets for Bank/Dock (the bus carries canonical addresses).        
                
3. It drives `/MREQ`, `/IORQ`, `R/W_`, `A[]`, and `D[]` according to this specification; the Dock drives `/MEM0_CS` and `/MEM1_CS` when the Bank is selected.    
4. It implements `/READY` handling and any declared `IntAckMode`.    
5. It successfully passes the Platform enumeration and compatibility checks described in the μBITz Platform spec.


---

## Annex A: Example 6502 C64-Style Host (Informative)

This annex is non-normative and just illustrates how a concrete Host might implement a C64-style mapping using the μBITz Address Space Mapper. It is derived from the “address-decoder” discussion and the C64 memory map.

### A.1 CPU View (Simplified)

- `$0000–$9FFF` → main RAM    
- `$A000–$BFFF` → BASIC ROM (8 KiB)    
- `$C000–$CFFF` → RAM    
- `$D000–$DFFF` → IO + character ROM region    
- `$E000–$FFFF` → KERNAL ROM (8 KiB)    

### A.2 μBITz Interpretation

- **RAM space:** `0x0000…0xCFFF` (52 KiB), including “under ROM/IO” shadows.    
- **ROM space:** single ROM space with:    
    - BASIC at offset `0x0000`        
    - KERNAL at offset `0x2000`        
- **IO space:** `0x0000…0x0FFF` (4 KiB)    

The Address Space Mapper implements:

- Address decode on `CPU_A[15:0]` to select RAM/ROM/IO regions.    
- Offset calculation:    
    - RAM: `offset = CPU_A[14:0]` (for all RAM regions)        
    - IO: `offset = CPU_A[11:0]` (for `$D000–$DFFF`)        
    - ROM: `offset = CPU_A[13:0] - base_of_ROM_region`
        
- Dock-driven space selects (active-low) when the Bank is selected:    
    - RAM: `/MEM0_CS = 0`, `/MEM1_CS = 1`, `/IORQ = 1`, `/MREQ = 0`        
    - ROM 0: `/MEM0_CS = 1`, `/MEM1_CS = 0`, `/IORQ = 1`, `/MREQ = 0`        
    - ROM 1: `/MEM0_CS = 0`, `/MEM1_CS = 0`, `/IORQ = 1`, `/MREQ = 0`        
    - ROM 2: `/MEM0_CS = 1`, `/MEM1_CS = 1`, `/IORQ = 1`, `/MREQ = 0`        
    - IO: `/IORQ = 0`, `/MREQ = 1`, `/MEM0_CS = 0`, `/MEM1_CS = 0`
        

A small CPLD (ATF22V10/ATF1504/XC9572) is sufficient for this mapping.
