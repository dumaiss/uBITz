# µBITz Sound Processor Tile Specification v1.0

# µBITz Sound Processor Tile Specification v1.0

## Programmable Audio Processor for µBITz Platform

**Status:** Draft v1.0
**Date:** 2025
**Function:** SOUND (0x02)

---

# Part 0 — Overview and Architecture

## 0.1 What is µBITz Sound Processor Tile?

The µBITz Sound Processor Tile is a **programmable audio engine** implemented as a µBITz Tile on the Dock bus. It behaves like a “modern super-synth” with a retro-friendly register interface:

- **256 fully independent voices** with identical per-voice DSP chains
- **Sample-accurate scheduling** via an on-board FX core (“audio copper”)
- **High-quality 24-bit S/PDIF output**, with 32-bit floating-point internal mix
- **Sample-based, but not just a sampler**: per-voice filters, distortion, delay, ring-mod and sends

It is intended to be one of the standard **Versatile Media Tile personalities** (same Artix-7 + DDR3 hardware family as the VDP), but it can also be implemented on any compatible µBITz Tile.

**Key characteristics:**

- **True “sound chip” model**: register-based control, not a PCI audio interface
- **256 simultaneous voices** at 48 kHz with full per-voice processing
- **Modern DSP**: float mix, per-voice biquad + waveshaper + delay
- **Programmable FX Core**: executes “stride-like” music bytecode so the Host doesn’t spam “note on / note off” every frame
- **Self-contained sample RAM** in DDR3 (256–512 MB)
- **Deterministic block processing**: fixed block size (e.g., 512 samples), sync IRQ to Host and optional sync to VDP

---

## 0.2 Design Philosophy

### 0.2.1 “Sound Chip”, Not Just Audio Output

The Sound Processor Tile follows the lineage of classic sound chips (SID, OPLx, Paula, SPC700, etc.), but with modern DSP resources:

- **Register-driven**: the Host writes concise commands and parameters, the Sound Processor does the heavy lifting.
- **Private sample RAM**: the audio engine owns its own DDR3 pool; the Host never pokes sample buffers directly on the audio timeline.
- **Autonomous playback**: once a song/pattern/stride script is loaded, the FX Sound Core can run the show for many seconds with only occasional Host intervention.

Where it differs from “just hit play” designs:

- The Host is still expected to **do some work** (pattern loading, asset management, game-side decisions), not just fire a single “start stream” command.
- The Sound Processor provides a **rich per-voice pipeline** and a programmable FX Core so that composing/engine work feels closer to a tracker or a demoscene synth than to a simple PCM DAC.

### 0.2.2 Design Principles

1. **CPU Independence (within a block)**
    - Audio runs in fixed-size blocks (e.g., 512 samples).
    - Within a block, the Sound Processor is fully autonomous.
    - Host interaction is primarily at **block boundaries** (block IRQ) and via queued “stride” events.
2. **Sample-Based, Voice-Centric Architecture**
    - All sound originates from **PCM assets** in DDR3.
    - Each voice has its own playback engine, envelope, filter, distortion, delay, and sends.
    - Textures, drums, pads, and even “oscillators” (single-cycle waves) are all just samples with different parameters.
3. **Programmable FX Core (“audio copper”)**
    - A small RISC-V core runs custom C code or a compact music bytecode (“stride”).
    - It **walks patterns**, triggers notes, automates parameters, and schedules sample assets (including vocals).
    - The goal: the Host sends high-level commands; the FX Core drives per-block detail.
4. **Deterministic Block Timing**
    - The engine processes fixed-size blocks (N samples), at a fixed sample rate.
    - FX IRQs are tied to block boundaries (e.g., every 512 samples ≈ 93.75 Hz at 48 kHz).
    - Optional sync input from the VDP (VBlank/frame counter) allows **tight A/V sync** (e.g., Bad Apple).
5. **Host-Friendly, Retro-Friendly**
    - 8-bit register access over µBITz Dock.
    - Compact command FIFOs instead of large DMA descriptors.
    - Z80/6502-class hosts can drive complex music without being swamped.

---

## 0.3 System Architecture

### 0.3.1 High-Level Block Diagram

```
┌─────────────────────────────────────────────────────────┐
│               µBITz SOUND PROCESSOR TILE                │
│                                                         │
│  ╔═══════════════════════════════════════╗              │
│  ║  µBITz Dock Connector                 ║              │
│  ║  - Parallel or Serial Profile         ║              │
│  ╚═══════════════╦═══════════════════════╝              │
│                  ║                                      │
│  ┌───────────────▼───────────────────────┐              │
│  │    µBITz Dock Interface Logic         │              │
│  │  - /CS decode                         │              │
│  │  - /IORQ handling                     │              │
│  │  - /READY generation                  │              │
│  │  - Register bank + command FIFO       │              │
│  │  - INT_CH[x] generation               │              │
│  └───────────────┬───────────────────────┘              │
│                  │                                      │
│  ┌───────────────▼───────────────────────┐              │
│  │           FPGA Core (Artix-7)         │              │
│  │                                       │              │
│  │  ┌─────────────────────────────────┐  │              │
│  │  │   Sample / Asset Manager        │  │              │
│  │  │   - Upload to DDR3              │  │              │
│  │  │   - Asset table (PCM, vocals)   │  │              │
│  │  └─────────────┬───────────────────┘  │              │
│  │                │                      │              │
│  │  ┌─────────────▼───────────────────┐  │              │
│  │  │   Voice Array (256 voices)      │  │              │
│  │  │   - Playback engine             │  │              │
│  │  │   - Envelope                    │  │              │
│  │  │   - Volume/pan                  │  │              │
│  │  │   - Dual biquad filter          │  │              │
│  │  │   - Waveshaper/distortion       │  │              │
│  │  │   - Ring-mod / AM               │  │              │
│  │  │   - Per-voice delay tap         │  │              │
│  │  │   - 4× send levels              │  │              │
│  │  └─────────────┬───────────────────┘  │              │
│  │                │                      │              │
│  │  ┌─────────────▼───────────────────┐  │              │
│  │  │   Global Mixer & FX Busses      │  │              │
│  │  │   - 32-bit float summing        │  │              │
│  │  │   - 4 aux busses (reverb, etc.) │  │              │
│  │  │   - Master EQ/comp (optional)   │  │              │
│  │  │   - Final limiter + dither      │  │              │
│  │  └─────────────┬───────────────────┘  │              │
│  │                │                      │              │
│  │  ┌─────────────▼───────────────────┐  │              │
│  │  │   S/PDIF Output Engine          │  │              │
│  │  │   - IEC60958 framing            │  │              │
│  │  │   - 24-bit audio payload        │  │              │
│  │  └─────────────┬───────────────────┘  │              │
│  │                │                      │              │
│  │  ┌─────────────▼───────────────────┐  │              │
│  │  │   FX Sound Core (RISC-V)        │  │              │
│  │  │   - Stride/music bytecode       │  │              │
│  │  │   - Per-block automation        │  │              │
│  │  │   - A/V sync & scheduling       │  │              │
│  │  └─────────────┬───────────────────┘  │              │
│  │                │                      │              │
│  │  ┌─────────────▼───────────────────┐  │              │
│  │  │   DDR3 Memory Controller        │  │              │
│  │  │   - Sample fetch                │  │              │
│  │  │   - Delay lines                 │  │              │
│  │  │   - Asset tables & sequences    │  │              │
│  │  └─────────────┬───────────────────┘  │              │
│  └────────────────┼──────────────────────┘              │
│                   │                                     │
│  ┌────────────────▼──────────────────────┐              │
│  │    DDR3 SDRAM (256–512MB)             │              │
│  │    - Sample data (PCM)                │              │
│  │    - Vocal segments                   │              │
│  │    - Delay buffers                    │              │
│  │    - FX/stride programs, tables       │              │
│  └───────────────────────────────────────┘              │
│                                                         │
│  ┌───────────────────────────────────────┐              │
│  │      S/PDIF Transmitter               │              │
│  │   (discrete or direct from FPGA)      │              │
│  └──────────────┬────────────────────────┘              │
│                 │                                       │
│           ┌─────▼──────┐                                │
│           │ S/PDIF Out │ ← Coax/TOSLINK                 │
│           └────────────┘                                │
│                                                         │
│ INT_CH[x] ──► Block IRQ / event IRQ to Host             │
│                                                         │
│ [PWR] [CLK] [ACT] [ERR] ← Status LEDs                   │
└─────────────────────────────────────────────────────────┘
```

---

## 0.4 Feature Summary

### 0.4.1 Hard Limits (Audio Engine)

| Parameter | Value / Behaviour |
| --- | --- |
| Voices | 256 fully independent voices (no channel stealing) |
| Internal mix | 32-bit floating-point summing and processing |
| Input formats | 8/16/24-bit PCM samples → converted to float |
| Output format | 24-bit, noise-shaped S/PDIF (IEC60958 compliant) |
| Sample rates | 48 kHz (fixed base), switchable 96/192 kHz via register |
| Sample RAM | 256–512 MB DDR3 shared pool, byte-addressable |
| Resampling | High-quality ASRC or 16-tap polyphase FIR per voice |
| Polyphony headroom | 256 voices @ 48 kHz with per-voice biquad + distortion <~70% DSP budget |

**Goal:** full 256-voice polyphony with “everything on” at 48 kHz, and still enough headroom to run the FX Core and global FX.

---

### 0.4.2 Per-Voice DSP Pipeline

Each of the 256 voices implements the same fixed pipeline. All parameters are exposed via registers / control structures that the FX Core and Host can modify in real time.

| Stage | Parameters (typical) | Use cases |
| --- | --- | --- |
| **Playback engine** | start, end, loop_start, loop_end (byte addrs)playback_rate (32.32 fixed-point, 1.0 = original)direction (forward/reverse/ping-pong)root_key + detune (cents) | Classic sampler, granular tricks, oscillators (single-cycle) |
| **Amplitude envelope** | ADSR or 256-point envelope table | Natural instrument envelopes, chiptune gates, ramps |
| **Volume / panning** | volume_l, volume_r (float), pan law select | True stereo imaging, smooth fades |
| **Filter (dual biquad)** | type (LP/HP/BP/notch/peak/allpass)cutoff (20 Hz–20 kHz)resonance/Q (0.5–20) | Moog-style sweeps, wah, formants, phasers |
| **Waveshaper / distort** | 256×16-bit LUT or built-in models (softclip, tanh, crush, fold) | Guitar-like distortion, bit-crush, lo-fi |
| **Ring mod / AM** | carrier frequency **or** second voice ID | Metallic FM-ish tones, 80s-style effects |
| **Per-voice delay tap** | delay time (0–500 ms), feedback, mix | Chorus, flanger, slapback, Haas effects |
| **Sends (4×)** | send_0..3 levels (float) | Send to global reverb, echo, bus FX |

All processing is done in float or high-res fixed, then mixed down and dithered to 24-bit at the output.

---

### 0.4.3 Global Mixer / FX

| Feature | Details |
| --- | --- |
| Main mix | 256 voices summed in float, per-voice pan, global gain |
| Aux busses | 4 global aux returns (reverbs, multi-tap delays, bus compressors, etc.) |
| Master FX | Optional global EQ/comp/limiter block implemented in DSP fabric |
| Limiter | Look-ahead limiter, hard or soft knee, ensures no S/PDIF clipping |
| Dither | TPDF dither + high-order noise shaping to 24-bit output |

The FX Core can control **all global parameters** (e.g., reverb size, master EQ, bus compression) in sync with patterns and visuals.

---

### 0.4.4 FX Sound Core (“audio copper”)

The FX Sound Core is the **brain** that keeps the sound chip doing useful work without constant Host babysitting.

| Parameter | Value / Notes |
| --- | --- |
| Core | VexRiscv RV32IMAC @ 100–150 MHz |
| Code/data RAM | ~128 KB BRAM, loaded by Host at init |
| IRQ sources | Block boundary (e.g., every 512 samples) + optional VDP sync (frame/VBlank) |
| Access | R/W access to all voice control blocks, global mixer params, asset tables, and a mailbox shared with Host |

Typical tasks:

- Interpret “stride-like” music bytecode (patterns, rows, effects)
- Step pattern / song positions at block boundaries
- Fire **note on/off** events by writing voice parameters
- Trigger **vocal asset segments** at specific audio blocks or synced video frames
- Perform **parameter automation** (filters sweeps, pan, LFOs, sends)
- Implement **music engine logic** (looping, section transitions, game adaptive music)

The intention is that **Bad Apple-level** synchronization (vocals, music, visual cuts) can be handled largely inside the FX Core once asset tables / scripts are loaded.

---

### 0.4.5 Vocals and Asset Playback

Vocals are treated as just another class of PCM assets:

- Raw or compressed vocals are preprocessed offline to PCM.
- Audio is cut into **segments (“slices”)**, each referenced by an **asset ID**.
- Asset descriptors store: base address, length, root pitch (if needed), nominal time, etc.
- The FX Core’s stride script schedules these slices at block boundaries or at specific **frame counters** (if synced with the VDP).

This means:

- The Host doesn’t stream full-bandwidth vocal data in real-time; it just loads asset tables and sends a compact list of **“play asset N at time T”** events.
- Lipsync / scene changes can be tied to either **audio time** (block count) or **video time** (frame count) depending on the demo.

---

## 0.5 Host Interface

### 0.5.1 Logical View

From the µBITz Host’s perspective, the Sound Processor appears as a single µBITz Tile:

- **Function:** SOUND (0x02)
- **Interface:** Register window + command FIFO + status registers
- **Interrupts:** At least one INT_CH line, typically used for block IRQs and/or event notifications.

The exact register map lives in *Part 1 — Register Map and Programming Model*, but the Host sees roughly:

- **Global control registers**
    - Sample rate selection (48/96/192 kHz)
    - Global mute/volume, FX enable flags
    - S/PDIF configuration
- **Command / event FIFOs**
    - Queue stride programs or compact music commands
    - Queue “fire asset”, “set voice params”, “upload data chunk” operations
- **Voice control window**
    - One or more indexed windows to read/write voice parameters by voice ID
    - Optional auto-increment for patch uploads
- **FX Core control/status**
    - Start/stop/reset
    - Safety modes (budgeted, free-run)
    - Error codes, debug flags
- **Status / IRQ sources**
    - Block complete
    - FX Core error/halt
    - Asset end / loop end
    - Underrun/overrun flags

All access is via the µBITz Dock’s I/O transaction model, with `/READY` stretching if needed.

---

### 0.5.2 Timing & IRQ Model (Conceptual)

- Audio processing runs at **fixed block rate** (N samples per block).
- At the end of each block, the engine:
    1. Mixes and commits the block to the S/PDIF output pipeline.
    2. Advances internal time counters.
    3. Triggers **FX Core IRQ** so it can step stride logic and update voice params for the next block.
    4. Optionally asserts a **Host IRQ** (INT_CH[x]) if the Host subscribed to block ticks.

This gives you three levels of control:

1. **Sample-accurate inside the engine** (FX Core manipulation of voice params).
2. **Block-accurate at the FX Core level** (stride patterns, automation).
3. **Frame/block-level from the Host** (coarse control, asset loading, scene changes).

---

## 0.6 µBITz Dock Compliance

The Sound Processor Tile is a conformant µBITz Dock peripheral device and MUST:

- Provide a valid **Device Descriptor** via I²C EEPROM
    - Function=SOUND (0x02)
- Support the declared `AddressBusWidth` and `DataBusWidth` from the Host.
- Implement the µBITz **I/O transaction model**, including `/IORQ` qualification and `/READY` stretching.
- Use `INT_CH[x]` lines per µBITz Core specification (Mode-2 compatible if needed).
- Support either Parallel and/or Serial Dock profiles where applicable (depending on carrier/backplane).

---

## 0.7 Development Targets

### 0.7.1 Prototyping Platform

- **Board:** QMTech Artix-7 (XC7A100T) development board (already used for VDP prototyping)
- **Advantages:**
    - On-board DDR3
    - Sufficient LUT/DSP headroom for 256 voices at 48 kHz
    - Plenty of I/O for S/PDIF + Dock interface
- **Use:**
    - Prototype and validate the voice engine, FX Core, mixer, and S/PDIF.
    - Experiment with stride music VM and asset playback (including vocals).

### 0.7.2 Production Platform

- **Versatile Media Tile hardware:**
    - Artix-7 XC7A50T (or similar)
    - 256–512 MB DDR3
    - S/PDIF output (coax or TOSLINK) via a small transmitter IC or direct FPGA output
- **Form factor:**
    - Same as VDP Tile (100×150mm M.2 or PCIe format)
- **Personality:**
    - The Sound Processor is a **bitstream personality** on this Media Tile.
    - Other personalities (VDP, OPL3 clone, etc.) can be flashed on the same physical card.

---

## 0.8 Document Structure

A full Sound Processor spec would be organized as:

- **Part 0:** Overview and Architecture *(this document)*
- **Part 1:** Register Map and Programming Model
    - Global registers, voice parameter access, FX Core control, command FIFOs
- **Part 2:** Memory Organization and Asset Management
    - Sample storage layout, asset tables, vocal segments, delay lines
- **Part 3:** FX Sound Core and Stride VM
    - Bytecode format, scheduling model, sync with VDP, safety modes
- **Part 4:** S/PDIF Output and Clocking
    - IEC60958 framing, sample rate selection, jitter considerations
- **Part 5:** Hardware Design and Reference Implementation
    - How to map this personality onto the Versatile Media Tile
- **Part 6:** Software Development Guide
    - Toolchain, C APIs, example engines (tracker-style, pattern-based, scripted)